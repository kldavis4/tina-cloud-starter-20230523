---
title: 'Front-End Performance Checklist 2019 [PDF, Apple Pages, MS Word]'
slug: front-end-performance-checklist-2019-pdf-pages
author: vitaly-friedman
image: >-
  //archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png
date: 2019-01-07T12:00:13.000Z
summary: >-
  Let’s make 2019... fast! An annual front-end performance checklist (PDF/Apple Pages/MS Word), with everything you need to know to create fast experiences today. Updated since 2016.
description: >-
  Let’s make 2019... fast! A front-end performance checklist (PDF/Apple Pages/MS Word),
  with everything you need to know to create fast experiences today.
disable_ads: true
categories:
  - Performance
  - CSS
  - JavaScript
  - Service Workers
  - Checklists
---
<p>Web performance is a tricky beast, isn’t it? How do we actually know where we stand in terms of performance, and what our performance bottlenecks <em>exactly</em> are? Is it expensive JavaScript, slow web font delivery, heavy images, or sluggish rendering? Is it worth exploring tree-shaking, scope hoisting, code-splitting, and all the fancy loading patterns with intersection observer, server push, clients hints, HTTP/2, service workers and &mdash; oh my &mdash; edge workers? And, most importantly, <strong>where do we even start improving performance</strong> and how do we establish a performance culture long-term?</p>

<p>Back in the day, performance was often a mere <em>afterthought</em>. Often deferred till the very end of the project, it would boil down to minification, concatenation, asset optimization and potentially a few fine adjustments on the server’s <code>config</code> file. Looking back now, things seem to have changed quite significantly.</p>

<p>Performance isn’t just a technical concern: it matters, and when baking it into the workflow, design decisions have to be informed by their performance implications. <strong>Performance has to be measured, monitored and refined continually</strong>, and the growing complexity of the web poses new challenges that make it hard to keep track of metrics, because metrics will vary significantly depending on the device, browser, protocol, network type and latency (CDNs, ISPs, caches, proxies, firewalls, load balancers and servers all play a role in performance).</p>

<p>So, if we created an overview of all the things we have to keep in mind when improving performance &mdash; from the very start of the process until the final release of the website &mdash; what would that list look like? Below you’ll find a (hopefully unbiased and objective) <strong>front-end performance checklist for 2019</strong> &mdash; an updated overview of the issues you might need to consider to ensure that your response times are fast, user interaction is smooth and your sites don’t drain user’s bandwidth.</p>

### Table Of Contents

<ul>
  <li><a href="#getting-ready-planning-and-metrics">Getting Ready: Planning And Metrics</a></li>
  <li><a href="#setting-realistic-goals">Setting Realistic Goals</a></li>
  <li><a href="#defining-the-environment">Defining The Environment</a></li>
  <li><a href="#assets-optimizations">Assets Optimizations</a></li>
  <li><a href="#build-optimizations">Build Optimizations</a></li>
  <li><a href="#delivery-optimizations">Delivery Optimizations</a></li>
  <li><a href="#http2">HTTP/2</a></li>
  <li><a href="#testing-and-monitoring">Testing And Monitoring</a></li>
  <li><a href="#quick-wins">Quick Wins</a></li>
  <li><a href="#download-the-checklist">Download The Checklist (PDF, Apple Pages, MS Word)</a></li>
  <li><a href="#off-we-go">Off We Go!</a></li>
</ul>

<p>(You can also just <a href="https://www.dropbox.com/s/21vof23jlwf0swc/performance-checklist-1.2.pdf?dl=0">download the checklist PDF</a> (166 KB) or <a href="https://www.dropbox.com/s/xyf5qjnp1ii5okm/performance-checklist-1.2.pages?dl=0">download editable Apple Pages file</a> (275 KB) or <a href="https://www.dropbox.com/s/76b3yzexqdwsg65/performance-checklist-1.2.docx?dl=0">the .docx file</a> (151 KB). Happy optimizing, everyone!)</p>

<style>
  ol.start {
      counter-reset: perfcounter;
  }
  ol.start > li:before, ol.continue > li:before {
      content: counters(perfcounter, '.', decimal-leading-zero);
      counter-increment: perfcounter;
  }

@media all and (min-width: 1024px) {
  ol.start > li, ol.continue > li {
      list-style: none;
      margin-bottom: 1.5em;
      margin-top: 2em;
  }
  ol.start > li:first-child, ol.continue > li:first-child {
      margin-top: 1em;
  }
  ol.start > li:before, ol.continue > li:before {
      margin-left: -1.1em;
      margin-right: 2.4%;
      font-family: "Mija", Arial, sans-serif;
      display: inline-block;
      line-height: 1.1em;
      text-align: center;
      background-color: #E53B2C;
      color: #fff;
      padding: .65em .5em .5em .5em;
      border-radius: 11px;
    }
  ol.start p, ol.continue p {
      font-size: inherit;
  }
}
</style>

{{% feature-panel %}}

## Getting Ready: Planning And Metrics

<p>Micro-optimizations are great for keeping performance on track, but it’s critical to have clearly defined targets in mind &mdash; <em>measurable</em> goals that would influence any decisions made throughout the process. There are a couple of different models, and the ones discussed below are quite opinionated &mdash; just make sure to set your own priorities early on.</p>

<ol class="start">
<li><strong>Establish a performance culture.</strong><br />In many organizations, front-end developers know exactly what common underlying problems are and what loading patterns should be used to fix them. However, as long as there is no established endorsement of the performance culture, each decision will turn into a battlefield of departments, breaking up the organization into silos. You need a business stakeholder buy-in, and to get it, you need to establish a case study on how speed benefits metrics and Key Performance Indicators (<em>KPIs</em>) they care about.

<p>Without a strong alignment between dev/design and business/marketing teams, performance isn’t going to sustain long-term. Study common complaints coming into customer service and see how improving performance can help relieve some of these common problems.</p>

<p>Run performance experiments and measure outcomes &mdash; both on mobile and on desktop. It will help you build up a company-tailored case study with real data. Furthermore, using data from case studies and experiments published on <a href="https://wpostats.com/">WPO Stats</a> will help increase sensitivity for business about why performance matters, and what impact it has on user experience and business metrics. Stating that performance matters alone isn’t enough though &mdash; you also need to establish some measurable and trackable goals and observe them.</p>

<p>How to get there? In her talk on <a href="https://vimeo.com/album/4970467/video/254947097">Building Performance for the Long Term</a>, Allison McKnight shares a comprehensive case-study of how she helped establish a performance culture at Etsy (<a href="https://speakerdeck.com/aemcknig/building-performance-for-the-long-term">slides</a>).</p></li>
</ol>

{{< rimg breakout="true" href="https://bradfrost.com/blog/post/performance-budget-builder/" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7191d628-f0a1-490c-afca-c8abcdfd4823/brad-perf-budget-builder.png" sizes="100vw" caption="<a href='https://bradfrost.com/blog/post/performance-budget-builder/'>Performance budget builder</a> by Brad Frost and Jonathan Fielding’s <a href='https://www.performancebudget.io/'>Performance Budget Calculator</a> can help you set up your performance budget and visualize it. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7191d628-f0a1-490c-afca-c8abcdfd4823/brad-perf-budget-builder.png'>Large preview</a>)" alt="Brad Frost and Jonathan Fielding’s Performance Budget Calculator" >}}

<ol class="continue">
<li><strong>Goal: Be at least 20% faster than your fastest competitor.</strong><br />According to <a href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule">psychological research</a>, if you want users to feel that your website is faster than your competitor’s website, you need to be <em>at least</em> 20% faster. Study your main competitors, collect metrics on how they perform on mobile and desktop and set thresholds that would help you outpace them. To get accurate results and goals though, first study your analytics to see what your users are on. You can then mimic the 90th percentile’s experience for testing.

<p>To get a good first impression of how your competitors perform, you can <a href="https://web.dev/fast/chrome-ux-report">use Chrome UX Report</a> (<em>CrUX</em>, a ready-made RUM data set, <a href="https://vimeo.com/254834890">video introduction</a> by Ilya Grigorik), <a href="https://www.thinkwithgoogle.com/feature/mobile/">Speed Scorecard</a> (also provides a revenue impact estimator),  <a href="https://ruxt.dexecure.com/compare">Real User Experience Test Comparison</a> or <a href="https://www.sitespeed.io/">SiteSpeed CI</a> (based on synthetic testing).</p>

<p><strong>Note</strong>: If you use <a href="https://developers.google.com/speed/pagespeed/insights/">Page Speed Insights</a> (no, it isn’t deprecated), you can get CrUX performance data for specific pages instead of just the aggregates. This data can be much more useful for setting performance targets for assets like “landing page” or “product listing”. And if you are using CI to test the budgets, you need to make sure your tested environment matches CrUX if you used CrUX for setting the target (<em>thanks Patrick Meenan!</em>).</p>

<p>Collect data, set up a <a href="https://danielmall.com/articles/how-to-make-a-performance-budget/">spreadsheet</a>, shave off 20%, and set up your goals (<em>performance budgets</em>) this way. Now you have something measurable to test against. If you’re keeping the budget in mind and trying to ship down just the minimal script to get a quick time-to-interactive, then you’re on a reasonable path.</p>

<p>Need resources to get started?</p>

<ul>
<li>Addy Osmani has written a very detailed write-up on <a href="https://medium.com/@addyosmani/start-performance-budgeting-dabde04cf6a3">how to start performance budgeting</a>, how to quantify the impact of new features and where to start when you are over budget.</li>
<li>Lara Hogan’s <a href="https://designingforperformance.com/weighing-aesthetics-and-performance/#approach-new-designs-with-a-performance-budget">guide on how to approach designs with a performance budget</a> can provide helpful pointers to designers.</li>
<li>Jonathan Fielding’s <a href="https://www.performancebudget.io/">Performance Budget Calculator</a>, Brad Frost’s <a href="https://codepen.io/bradfrost/full/EPQVBp/">Performance Budget Builder</a> and <a href="https://browserdiet.com/calories/">Browser Calories</a> can aid in creating budgets (thanks to <a href="https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3">Karolina Szczur</a> for the heads up).</li>
<li>Also, make both performance budget and current performance <em>visible</em> by setting up dashboards with graphs reporting build sizes. There are many tools allowing you to achieve that: <a href="https://www.peterhedenskog.com/blog/2015/04/open-source-performance-dashboard/">SiteSpeed.io dashboard</a> (open source), <a href="https://speedcurve.com/">SpeedCurve</a> and <a href="https://calibreapp.com/">Calibre</a> are just a few of them, and you can find more tools on <a href="https://perf.rocks/tools/">perf.rocks</a>.</li>
</ul>

<p>Once you have a budget in place, incorporate them into your build process <a href="https://web.dev/fast/incorporate-performance-budgets-into-your-build-tools">with Webpack Performance Hints and Bundlesize</a>, <a href="https://web.dev/fast/using-lighthouse-ci-to-set-a-performance-budget">Lightouse CI</a>, <a href="https://github.com/paulirish/pwmetrics">PWMetrics</a> or <a href="https://www.sitespeed.io/">Sitespeed CI</a> to enforce budgets on pull requests and provide a score history in PR comments. If you need something custom, you can use <a href="https://github.com/trulia/webpagetest-charts-api">webpagetest-charts-api</a>, an API of endpoints to build charts from WebPagetest results.</p>

<p>For instance, just like <a href="https://medium.com/@Pinterest_Engineering/a-one-year-pwa-retrospective-f4a2f4129e05">Pinterest</a>, you could create a custom <em>eslint</em> rule that disallows importing from files and directories that are known to be dependency-heavy and would bloat the bundle. Set up a listing of “safe” packages that can be shared across the entire team. </p>

<p>Beyond performance budgets, think about critical customer tasks that are most beneficial to your business. Set and discuss acceptable <strong>time thresholds for critical actions</strong> and establish "UX ready" user timing marks that the entire organization has agreed on. In many cases, user journeys will touch on the work of many different departments, so alignment in terms of acceptable timings will help support or prevent performance discussions down the road. Make sure that additional costs of added resources and features are visible and understood.</p>

<p>Also, as Patrick Meenan suggested, it’s worth to <strong>plan out a loading sequence and trade-offs</strong> during the design process. If you prioritize early on which parts are more critical, and define the order in which they should appear, you will also know what can be delayed. Ideally, that order will also reflect the sequence of your CSS and JavaScript imports, so handling them during the build process will be easier. Also, consider what the visual experience should be in "in-between"-states, while the page is being loaded (e.g. when web fonts aren’t loaded yet).</p>

<p><em>Planning, planning, planning.</em> It might be tempting to get into quick "low-hanging-fruits"-optimizations early on &mdash; and eventually it might be a good strategy for quick wins &mdash; but it will be very hard to keep performance a priority without planning and setting realistic, company-tailored performance goals.</p></li>
</ol>

{{< vimeo id="249524245" caption="The difference between First Paint, First Contentful Paint, First Meaningful Paint, Visual Complete and Time To Interactive. <a href='https://docs.google.com/presentation/d/1D4foHkE0VQdhcA5_hiesl8JhEGeTDRrQR4gipfJ8z7Y/present?slide=id.g21f3ab9dd6_0_33'>Large view</a>. Credit: <a href='https://docs.google.com/presentation/d/1D4foHkE0VQdhcA5_hiesl8JhEGeTDRrQR4gipfJ8z7Y/present?slide=id.g21f3ab9dd6_0_33'>@denar90</a>" >}}

<ol class="continue">
<li><strong>Choose the right metrics.</strong><br /><a href="https://speedcurve.com/blog/rendering-metrics/">Not all metrics are equally important</a>. Study what metrics matter most to your application: usually it will be related to how fast you can start render <em>most important pixels of your product</em> and how quickly you can provide input responsiveness for these rendered pixels. This knowledge will give you the best optimization target for ongoing efforts.

<p>One way or another, rather than focusing on full page loading time (via <em>onLoad</em> and <em>DOMContentLoaded</em> timings, for example), prioritize page loading as perceived by your customers. That means focusing on a slightly different set of metrics. In fact, choosing the right metric is a process without obvious winners.</p>

<p>Based on Tim Kadlec’s research and Marcos Iglesias’ notes in <a href="https://docs.google.com/presentation/d/e/2PACX-1vTk8geAszRTDisSIplT02CacJybNtrr6kIYUCjW3-Y_7U9kYSjn_6TbabEQDnk9Ao8DX9IttL-RD_p7/pub?start=false&loop=false&delayms=10000&slide=id.g3ccc19d32d_0_98">his talk</a>, traditional metrics could be grouped into a few sets. Usually, we’ll need all of them to get a complete picture of performance, and in your particular case some of them might be more important than others.</p>

<ul>
  <li><em>Quantity-based metrics</em> measure the number of requests, weight and a performance score. Good for raising alarms and monitoring changes over time, not so good for understanding user experience.</li>
  <li><em>Milestone metrics</em> use states in the lifetime of the loading process, e.g. <em>Time To First Byte</em> and <em>Time To Interactive</em>. Good for describing the user experience and monitoring, not so good for knowing what happens between the milestones.</li>
  <li><em>Rendering metrics</em> provide an estimate of how fast content renders (e.g. <em>Start Render</em>  time, <em>Speed Index</em>). Good for measuring and tweaking rendering performance, but not so good for measuring when <em>important</em> content appears and can be interacted with.</li>
  <li><em>Custom metrics</em> measure a particular, custom event for the user, e.g. Twitter’s <a href="https://blog.alexmaccaw.com/time-to-first-tweet">Time To First Tweet</a> and Pinterest’s <a href="https://medium.com/@Pinterest_Engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7">PinnerWaitTime</a>. Good for describing the user experience precisely, not so good for scaling the metrics and comparing with competitors.</li>
</ul>

<p>To complete the picture, we’d usually look out for useful metrics among all of these groups. Usually, the most specific and relevant ones are:</p>

<ul>
  <li><a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint">First Meaningful Paint</a> <em>(FMP)</em><br />Provides the timing when primary content appears on the page, providing an insight into how quickly the server outputs <em>any</em> data. Long FMP usually indicates JavaScript blocking the main thread, but could be related to back-end/server issues as well.</li>
  <li><a href="https://calibreapp.com/blog/time-to-interactive/">Time to Interactive</a> <em>(TTI)</em><br />The point at which layout has stabilized, key webfonts are visible, and the main thread is available enough to handle user input &mdash; basically the time mark when a user can interact with the UI. The key metrics for understanding how much <em>wait</em> a user has to experience to use the site without a lag.</li>
  <li><a href="https://developers.google.com/web/updates/2018/05/first-input-delay">First Input Delay</a> <em>(FID)</em>, or <em>Input responsiveness</em><br />The time from when a user first interacts with your site to the time when the browser is actually able to respond to that interaction. Complements TTI very well as it describes the missing part of the picture: what happens when a user actually interacts with the site. Intended as a RUM metric only. There is a <a href="https://github.com/GoogleChromeLabs/first-input-delay">JavaScript library</a> for measuring FID in the browser.</li>
  <li><a href="https://dev.to/borisschapira/web-performance-fundamentals-what-is-the-speed-index-2m5i">Speed Index</a><br />Measures how quickly the page contents are visually populated; the lower the score, the better. The Speed Index score is computed based on the speed of visual progress, but it’s merely a computed value. It’s also sensitive to the viewport size, so you need to define a range of testing configurations that match your target audience (<em>thanks, <a href="https://twitter.com/borisschapira">Boris</a>!</em>).</li>
  <li>CPU time spent<br />A metric that indicates how busy is the main thread with the processing of the payload. It shows how often and how long the main thread is blocked, working on painting, rendering, scripting and loading. High CPU time is a clear indicator of a <em>janky</em> experience, i.e. when the user experiences a noticeable lag between their action and a response. With WebPageTest, you can <a href="https://deanhume.com/ten-things-you-didnt-know-about-webpagetest-org/">select "Capture Dev Tools Timeline" on the "Chrome" tab</a> to expose the breakdown of the main thread as it runs on any device using WebPageTest.</li>
  <li><a href="https://calendar.perfplanet.com/2017/measuring-adweight/">Ad Weight Impact</a><br />If your site depends on the revenue generated by advertising, it’s useful to track the weight of ad related code. Paddy Ganti’s <a href="https://calendar.perfplanet.com/2017/measuring-adweight/">script</a> constructs two URLs (one normal and one blocking the ads), prompts the generation of a video comparison via WebPageTest and reports a delta.</li>
  <li>Deviation metrics<br />As <a href="https://phabricator.wikimedia.org/phame/live/7/post/117/performance_testing_in_a_controlled_lab_environment_-_the_metrics/">noted by Wikipedia engineers</a>, data of how much variance exists in your results could inform you how reliable your instruments are, and how much attention you should pay to deviations and outlers. Large variance is an indicator of adjustments needed in the setup. It also helps understand if certain pages are more difficult to measure reliably, e.g. due to third-party scripts causing significant variation. It might also be a good idea to track browser version to understand bumps in performance when a new browser version is rolled out.</li>
  <li><a href="https://speedcurve.com/blog/user-timing-and-custom-metrics/">Custom metrics</a><br />Custom metrics are defined by your business needs and customer experience. It requires you to identify <em>important</em> pixels, <em>critical</em> scripts, <em>necessary</em> CSS and <em>relevant</em> assets and measure how quickly they get delivered to the user. For that one, you can monitor <a href="https://speedcurve.com/blog/web-performance-monitoring-hero-times/">Hero Rendering Times</a>, or use <a href="https://css-tricks.com/breaking-performance-api/">Performance API</a>, marking particular timestaps for events that are important for your business. Also, you can <a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/custom-metrics">collect custom metrics with WebPagetest</a> by executing arbitrary JavaScript at the end of a test.</li>
</ul>

<p>Steve Souders has a <a href="https://speedcurve.com/blog/rendering-metrics/">detailed explanation of each metric</a>. It’s important to notice that while Time-To-Interactive is measured by running automated audits in the so-called <em>lab environment</em>, First Input Delay represents the <em>actual</em> user experience, with <em>actual</em> users experiencing a noticeable lag. In general, it’s probably a good idea to always measure and track both of them.</p>

<p>Depending on the context of your application, preferred metrics might differ: e.g. for Netflix TV UI, <a href="https://medium.com/netflix-techblog/crafting-a-high-performance-tv-user-interface-using-react-3350e5a6ad3b">key input responsiveness, memory usage and TTI</a> are more critical, and for Wikipedia, <a href="https://phabricator.wikimedia.org/phame/live/7/post/117/performance_testing_in_a_controlled_lab_environment_-_the_metrics/">first/last visual changes and CPU time spent metrics</a> are more important.</p>

<p><strong>Note</strong>: both FID and TTI do not account for scrolling behavior; scrolling can happen independently since it’s off-main-thread, so for many content consumption sites these metrics might be much less important (<em>thanks, Patrick!</em>).</p></li>
</ol>

{{< rimg breakout="true" href="https://twitter.com/__treo/status/1068163152783835136" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d80f91c-9807-4565-b616-a4735fcd4949/network-requests-first-input-delay.png" sizes="100vw" caption="User-centric performance metrics provide a better insight into the actual user experience. <a href='https://developers.google.com/web/updates/2018/05/first-input-delay'>First Input Delay</a> (FID) is a new metric that tries to achieve just that. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d80f91c-9807-4565-b616-a4735fcd4949/network-requests-first-input-delay.png'>Large preview</a>)" alt="" >}}

<ol class="continue">
<li><strong>Gather data on a device representative of your audience.</strong><br />To gather accurate data, we need to thoroughly choose devices to test on. It’s a good option to <a href="https://twitter.com/katiehempenius/statuses/1067969800205422593">choose a Moto G4</a>, a mid-range Samsung device, a good middle-of-the-road device like a Nexus 5X and a slow device like Alcatel 1X, perhaps in an <a href="https://www.smashingmagazine.com/2016/11/worlds-best-open-device-labs/">open device lab</a>. For testing on slower thermal-throttled devices, you could also get a Nexus 2, which costs just around $100.</p>

<p>If you don’t have a device at hand, emulate mobile experience on desktop by testing on a throttled network (e.g. 150ms RTT, 1.5 Mbps down, 0.7 Mbps up) with a throttled CPU (5× slowdown). Eventually switch over to regular 3G, 4G and Wi-Fi. To make the performance impact more visible, you could even introduce <a href="https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world">2G Tuesdays</a> or set up a <a href="https://twitter.com/thommaskelly/status/938127039403610112">throttled 3G network in your office</a> for faster testing.</p>

<p>Keep in mind that on a mobile device, you should be expecting a 4×–5× slowdown compared to desktop machines. Mobile devices have different GPUs, CPU, different memory, different battery characteristics. While download times are critical for low-end networks, parse times are critical for phones with slow CPUs. In fact, parse times on mobile <a href="https://github.com/GoogleChromeLabs/discovery/issues/1">are 36% higher than on desktop</a>. So always <a href="https://www.webpagetest.org/easy">test on an average device</a> &mdash; a device that is most representative of your audience.</p></li>

<figure><a href="https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world"><img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png" sizes="32vw" alt="Introducing the slowest day of the week">  </a><figcaption>Introducing the slowest day of the week. Facebook has introduced <a href="https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world">2G Tuesdays</a> to increase visibility and sensitivity of slow connections. (</a><a href="https://www.businessinsider.com/facebook-2g-tuesdays-to-slow-employee-internet-speeds-down-2015-10?IR=T">Image source</a>)
  </figcaption>
</figure>

<p>Luckily, there are many great options that help you automate the collection of data and measure how your website performs over time according to these metrics. Keep in mind that a good performance picture covers a set of performance metrics, <a href="https://developers.google.com/web/fundamentals/performance/speed-tools/">lab data and field data</a>:</p>

<ul>
  <li><strong>Synthetic testing tools</strong> collect <em>lab data</em> in a reproducible environment with predefined device and network settings (e.g. <em>Lighthouse</em>, <em>WebPageTest</em>) and</li>
  <li><strong>Real User Monitoring</strong> (<em>RUM</em>) tools evaluate user interactions continuously and collect <em>field data</em> (e.g. <em>SpeedCurve</em>, <em>New Relic</em> &mdash; both tools provide synthetic testing, too).</li>
</ul>

<p>The former is particularly useful during <em>development</em> as it will help you identify, isolate and fix performance issues while working on the product. The latter is useful for long-term <em>maintenance</em> as it will help you understand your performance bottlenecks as they are happening live &mdash; when users actually access the site.</p>

<p>By tapping into built-in RUM APIs such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API">Navigation Timing</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API">Resource Timing</a>, <a href="https://css-tricks.com/paint-timing-api/">Paint Timing</a>, <a href="https://w3c.github.io/longtasks/">Long Tasks</a>, etc., synthetic testing tools and RUM together provide a complete picture of performance in your application. You could use <a href="https://github.com/paulirish/pwmetrics">PWMetrics</a>, <a href="https://calibreapp.com">Calibre</a>, <a href="https://speedcurve.com/">SpeedCurve</a>, <a href="https://www.soasta.com/performance-monitoring/">mPulse</a> and <a href="https://github.com/yahoo/boomerang">Boomerang</a>, <a href="https://www.sitespeed.io/">Sitespeed.io</a>, which all are great options for performance monitoring. Furthermore, with <a href="https://www.smashingmagazine.com/2018/10/performance-server-timing/">Server Timing header</a>, you could even
monitor back-end and front-end performance all in one place.</p>

<p><strong>Note</strong>: It’s always a safer bet to choose <a href="https://calendar.perfplanet.com/2016/testing-with-realistic-networking-conditions/">network-level throttlers</a>, external to the browser, as, for example, DevTools has issues interacting with HTTP/2 push, due to the way it’s implemented (thanks, Yoav, Patrick!). For Mac OS, we can use <a href="https://nshipster.com/network-link-conditioner/">Network Link Conditioner</a>, for Windows <a href="https://github.com/WPO-Foundation/win-shaper/releases">Windows Traffic Shaper</a>, for Linux <a href="https://wiki.linuxfoundation.org/networking/netem">netem</a>, and for FreeBSD <a href="https://info.iet.unipi.it/~luigi/dummynet/">dummynet</a>.</p>
</li>
</ol>

{{< rimg breakout="true" href="https://developers.google.com/web/tools/lighthouse/" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a85a91a7-fb37-4596-8658-a40c1900a0d6/lighthouse-screenshot.png" sizes="100vw" caption="<a href='https://developers.google.com/web/tools/lighthouse/'>Lighthouse</a>, a performance auditing tool integrated into DevTools. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a85a91a7-fb37-4596-8658-a40c1900a0d6/lighthouse-screenshot.png'>Large preview</a>)" alt="Lighthouse" >}}

<ol class="continue">
<li><strong>Set up "clean" and "customer" profiles for testing.</strong><br />While running tests in passive monitoring tools, it’s a common strategy to turn off anti-virus and background CPU tasks, remove background bandwidth transfers and test with a clean user profile without browser extensions to avoid skewed results (<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiple_profiles">Firefox</a>, <a href="https://support.google.com/chrome/answer/2364824?hl=en&co=GENIE.Platform=Desktop">Chrome</a>).

<p>However, it’s also a good idea to study which extensions your customers are using frequently, and test with a dedicated <em>"customer" profile</em> as well. In fact, some extensions might have a <a href="https://twitter.com/denar90_/statuses/1065712688037277696">profound performance impact</a> on your application, and if your users use them a lot, you might want to account for it up front. "Clean" profile results alone are overly optimistic and can be crushed in real-life scenarios.</p></li>

<li><strong>Share the checklist with your colleagues.</strong><br />Make sure that the checklist is familiar to every member of your team to avoid misunderstandings down the line. Every decision has performance implications, and the project would hugely benefit from front-end developers properly communicating performance values to the whole team, so that everybody would feel responsible for it, not just front-end developers. Map design decisions against performance budget and the priorities defined in the checklist.</p></li>
</ol>

## Setting Realistic Goals

<ol class="continue">
<li><strong>100-millisecond response time, 60 fps.</strong><br />For an interaction to feel smooth, the interface has 100ms to respond to user’s input. Any longer than that, and the user perceives the app as laggy. The <a href="https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/">RAIL, a user-centered performance model</a> gives you healthy targets: To allow for &lt;100 milliseconds response, the page must yield control back to main thread at latest after every &lt;50 milliseconds. <a href="https://developers.google.com/web/tools/lighthouse/audits/estimated-input-latency">Estimated Input Latency</a> tells us if we are hitting that threshold, and ideally, it should be below 50ms. For high-pressure points like animation, it’s best to do nothing else where you can and the absolute minimum where you can't.</p>

<figure class="article__image break-out"><a href="https://developers.google.com/web/fundamentals/performance/rail">
<img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png" sizes="100vw" alt="RAIL"></a>
  <figcaption>
    <a href="https://developers.google.com/web/fundamentals/performance/rail">RAIL</a>, a user-centric performance model.
  </figcaption>
</figure>

<p>Also, each frame of animation should be completed in less than 16 milliseconds, thereby achieving 60 frames per second (1 second &divide; 60 = 16.6 milliseconds) &mdash; preferably under 10 milliseconds. Because the browser needs time to paint the new frame to the screen, your code should finish executing before hitting the 16.6 milliseconds mark. We’re starting having conversations about 120fps (e.g. iPad’s new screens run at 120Hz) and Surma has covered some <a href="https://dassur.ma/things/120fps/">rendering performance solutions for 120fps</a>, but that’s probably not a target we’re looking at <em>just yet</em>.</p>

<p>Be pessimistic in performance expectations, but <a href="https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/">be optimistic in interface design</a> and <a href="https://philipwalton.com/articles/idle-until-urgent/">use idle time wisely</a>. Obviously, these targets apply to runtime performance, rather than loading performance.</p></li>

<li><strong>Speed Index &lt; 1250, TTI &lt; 5s on 3G, Critical file size budget < 170KB (gzipped).</strong><br />Although it might be very difficult to achieve, a good ultimate goal would be First Meaningful Paint under 1 second and a <a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index">Speed Index</a> value under 1250. Considering the baseline being a $200 Android phone (e.g. Moto G4) on a slow 3G network, emulated at 400ms RTT and 400kbps transfer speed, aim for <a href="https://www.youtube.com/watch?v=_srJ7eHS3IM&feature=youtu.be&t=6m21s">Time to Interactive under 5s</a>, and for repeat visits, aim for under 2s (achievable only with a service worker),</p>

<p>Notice that, when speaking about interactivity metrics, it’s a good idea to <a href="https://calendar.perfplanet.com/2017/time-to-interactive-measuring-more-of-the-user-experience/">distinguish between First CPU Idle and Time To Interactive</a> to avoid misunderstandings down the line. The former is the earliest point after the main content has rendered (where there is at least a 5-second window where the page is responsive). The latter is the point where the page can be expected to always be responsive to input (<em>thanks, Philip Walton!</em>).</p>

<p>We have two major constraints that effectively shape a <em>reasonable</em> target for speedy delivery of the content on the web. On the one hand, we have <strong>network delivery constraints</strong> due to <a href="https://hpbn.co/building-blocks-of-tcp/#slow-start">TCP Slow Start</a>. The first 14KB of the HTML is the >most critical payload chunk &mdash; and the only part of the budget that can be delivered in the first roundtrip (which is all you get in 1 sec at 400ms RTT due to mobile wake-up times).</p>

<p>On the other hand, we have <strong>hardware constraints</strong> on memory and CPU due to JavaScript parsing times (we’ll talk about them in detail later). To achieve the goals stated in the first paragraph, we have to consider the critical file size budget for JavaScript. Opinions vary on what that budget should be (and it heavily depends on the nature of your project), but a budget of 170KB JavaScript gzipped already would take up to 1s to parse and compile on an average phone. Assuming that 170KB expands to 3× that size when decompressed (0.7MB), that already could be the death knell of a "decent" user experience on a Moto G4 or Nexus 2.</p>

<p>Of course, your data might show that your customers are not on these devices, but perhaps they simply don’t show up in your analytics because your service is inaccessible to them due to slow performance. In fact, Google’s Alex Russels recommends to <a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/">aim for 130&ndash;170KB gzipped</a> as a reasonable upper boundary, and exceeding this budget should be an informed and deliberate decision. In real-life world, most products aren’t even close: an average bundle size today is around <a href="https://beta.httparchive.org/reports/state-of-javascript#bytesJs">400KB</a>, which is up 35% compared to late 2015. On a middle-class mobile device, that accounts for 30-35 seconds for <em>Time-To-Interactive</em>.</p>

<p>We could also go beyond the bundle size budget though. For example, we could set performance budgets based on the activities of the browser’s main thread, i.e. paint time before start render, or <a href="https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/">track down front-end CPU hogs</a>. Tools such as <a href="https://calibreapp.com/">Calibre</a>, <a href="https://speedcurve.com/">SpeedCurve</a> and <a href="https://github.com/siddharthkp/bundlesize">Bundlesize</a> can help you keep your budgets in check, and can be integrated into your build process.</p>
<p>Also, a performance budget probably shouldn’t be a fixed value. Depending on the network connection, <a href="https://twitter.com/katiehempenius/status/1075478356311924737">performance budgets should adapt</a>, but payload on slower connection is much more "expensive", regardless of how they’re used.</p></li>
</ol>

<figure class="article__image break-out"><a href="https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices">
<img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png" sizes="100vw" alt="From 'Fast By Default: Modern Loading Best Practices' by Addy Osmani"></a>
  <figcaption>
    <a href="https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices">From Fast By Default: Modern loading best practices</a> by Addy Osmani (Slide 19)
  </figcaption>
</figure>

{{< rimg breakout="true" href="https://twitter.com/katiehempenius/status/1075478356311924737" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/949e5601-04e7-48ee-91a5-10bd7af19a0f/perf-budgets-network-connection.jpg" sizes="100vw" caption="Performance budgets should adapt depending on the network conditions for an average mobile device. (Image source: <a href='https://twitter.com/katiehempenius/status/1075478356311924737'>Katie Hempenius</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/949e5601-04e7-48ee-91a5-10bd7af19a0f/perf-budgets-network-connection.jpg'>Large preview</a>)" alt="" >}}

## Defining The Environment

<ol class="continue">
<li><strong>Choose and set up your build tools.</strong><br /><a href="https://24ways.org/2017/all-that-glisters/">Don’t pay too much attention to what’s supposedly cool</a> <a href="https://2018.stateofjs.com/">these days</a>. Stick to your environment for building, be it Grunt, Gulp, Webpack, Parcel, or a combination of tools. As long as you are getting results you need and you have no issues maintaining your build process, you’re doing just fine.</p>

<p>Among the build tools, Webpack seems to be the most established one, with literally hundreds of plugins available to optimize the size of your builds. Getting started with Webpack can be tough though. So if you want to get started, there are some great resources out there:</p>

<ul>
<li><a href="https://webpack.js.org/concepts/">Webpack documentation</a> &mdash; obviously &mdash; is a good starting point, and so are <a href="https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9">Webpack &mdash; The Confusing Bits</a> by Raja Rao and <a href="https://nystudio107.com/blog/an-annotated-webpack-4-config-for-frontend-web-development">An Annotated Webpack Config</a> by Andrew Welch.</li>
<li>Sean Learkin has a free course on <a href="https://webpack.academy/p/the-core-concepts">Webpack: The Core Concepts</a> and Jeffrey Way has released a fantastic free course on <a href="https://laracasts.com/series/webpack-for-everyone">Webpack for everyone</a>. Both of them are great introductions for diving into Webpack.</li>
<li><a href="https://frontendmasters.com/courses/webpack-fundamentals/">Webpack Fundamentals</a> is a very comprehensive 4h course with Sean Larkin, released by FrontendMasters.</li>
<li>If you are slightly more advanced, Rowan Oulton has published a <a href="https://slack.engineering/keep-webpack-fast-a-field-guide-for-better-build-performance-f56a5995e8f1">Field Guide for Better Build Performance with Webpack</a> and Benedikt Rötsch’s made a tremendous research on <a href="https://www.contentful.com/blog/2017/10/27/put-your-webpack-bundle-on-a-diet-part-3/">putting Webpack bundle on a diet</a>.</li>
<li><a href="https://github.com/webpack/webpack/tree/master/examples">Webpack examples</a> has hundreds of ready-to-use Webpack configurations, categorized by topic and purpose. Bonus: there is also a <a href="https://webpack.jakoblind.no/">Webpack config configurator</a> that generates a basic configuration file.</li>
<li><a href="https://github.com/webpack-contrib/awesome-webpack">awesome-webpack</a> is a curated list of useful Webpack resources, libraries and tools, including articles, videos, courses, books and examples for Angular, React and framework-agnostic projects.</li>
</ul>
</li>

<li><strong>Use progressive enhancement as a default.</strong><br />Keeping <a hreF="https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/">progressive enhancement</a> as the guiding principle of your front-end architecture and deployment is a safe bet. Design and build the core experience first, and then enhance the experience with advanced features for capable browsers, creating <a href="https://resilientwebdesign.com/">resilient</a> experiences. If your website runs fast on a slow machine with a poor screen in a poor browser on a sub-optimal network, then it will only run faster on a fast machine with a good browser on a decent network.</p></li>

<!--
<p>If you need a practical implementation of the strategy on mid-scale and large-scale projects, Scott Jehl’s <a href="https://www.filamentgroup.com/lab/modernizing-delivery.html">Modernizing our Progressive Enhancement Delivery</a> article is a good place to start.</p>
-->

<li><strong>Choose a strong performance baseline.</strong><br />With so many unknowns impacting loading &mdash; the network, thermal throttling, cache eviction, third-party scripts, parser blocking patterns, disk I/O, IPC latency, installed extensions, antivirus software and firewalls, background CPU tasks, hardware and memory constraints, differences in L2/L3 caching, RTTS &mdash; <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">JavaScript has the heaviest cost of the experience</a>, next to web fonts blocking rendering by default and images often consuming too much memory. With the performance bottlenecks <a href="https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/">moving away from the server to the client</a>, as developers, we have to consider all of these unknowns in much more detail.</p>

<p>With a 170KB budget that already contains the critical-path HTML/CSS/JavaScript, router, state management, utilities, framework and the application logic, we have to thoroughly <a href="https://www.twitter.com/kristoferbaxter/status/908144931125858304">examine network transfer cost, the parse/compile time and the runtime cost</a> of the framework of our choice.</p>

<p>As <a href="https://twitter.com/sebmarkbage/status/829733454119989248">noted</a> by Seb Markbåge, a good way to measure start-up costs for frameworks is to first render a view, then delete it and then render again as it can tell you how the framework scales. The first render tends to warm up a bunch of lazily compiled code, which a larger tree can benefit from when it scales. The second render is basically an emulation of how code reuse on a page affects the performance characteristics as the page grows in complexity.</p></li>
</ol>

<figure class="article__image"><a href="https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices"><img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/39c247a9-223f-4a6c-ae3d-db54a696ffcb/tti-budget-opt.png 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/39c247a9-223f-4a6c-ae3d-db54a696ffcb/tti-budget-opt.png 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/39c247a9-223f-4a6c-ae3d-db54a696ffcb/tti-budget-opt.png 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/39c247a9-223f-4a6c-ae3d-db54a696ffcb/tti-budget-opt.png 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/39c247a9-223f-4a6c-ae3d-db54a696ffcb/tti-budget-opt.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/39c247a9-223f-4a6c-ae3d-db54a696ffcb/tti-budget-opt.png" sizes="100vw" alt="'Fast By Default: Modern Loading Best Practices' by Addy Osmani"></a>
  <figcaption>
    From <a href="https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices">Fast By Default: Modern Loading Best Practices</a> by Addy Osmani (Slides 18, 19).
  </figcaption>

</figure>

<ol class="continue">
<li><strong>Evaluate each framework and each dependency.</strong><br />Now, <a href="https://twitter.com/jaffathecake/status/923805333268639744">not every project needs a framework</a> and <a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">not every page of a single-page-application needs to load a framework</a>. In Netflix’s case, "removing React, several libraries and the corresponding app code from the client-side reduced the total amount of JavaScript by over 200KB, causing <a href="https://news.ycombinator.com/item?id=15567657">an over-50% reduction in Netflix’s Time-to-Interactivity</a> for the logged-out homepage." The team then utilized the time spent by users on the landing page to prefetch React for subsequent pages that users were likely to land on (<a href="https://jakearchibald.com/2017/netflix-and-react/">read on for details</a>).

<p>It might sound obvious but worth stating: some projects can also benefit <a href="https://twitter.com/jaffathecake/status/925320026411950080">benefit from removing an existing framework</a> altogether. Once a framework is chosen, you’ll be staying with it for at least a few years, so if you need to use one, make sure your choice <a href="https://www.youtube.com/watch?v=6I_GwgoGm1w">is informed</a> and <a href="https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk">well considered</a>.</p>

<p>Inian Parameshwaran <a href="https://youtu.be/wVY3-acLIoI?t=699">has measured performance footprint of top 50 frameworks</a> (against <a href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint"><em>First Contentful Paint</em></a> &mdash; the time from navigation to the time when the browser renders the first bit of content from the DOM). Inian discovered that, out there in the wild, Vue and Preact are the fastest across the board &mdash; both on desktop and mobile, followed by React (<a href="https://drive.google.com/file/d/1CoCQP7qyvkSQ4VG9L_PTWD5AF9wF28XT/view">slides</a>). You could examine your framework candidates and the proposed architecture, and study how most solutions out there perform, e.g. with server-side rendering or client-side rendering, on average.</p>

<p>Baseline performance cost matters. According to a <a href="https://blog.uncommon.is/the-baseline-costs-of-javascript-frameworks-f768e2865d4a">study by Ankur Sethi</a>, "your React application will never load faster than about 1.1 seconds on an average phone in India, no matter how much you optimize it. Your Angular app will always take at least 2.7 seconds to boot up. The users of your Vue app will need to wait at least 1 second before they can start using it." You might not be targeting India as your primary market anyway, but users accessing your site with suboptimal network conditions will have a comparable experience. In exchange, your team gains maintainability and developer efficiency, of course. But this consideration needs to be deliberate.</p>

<p>You could go as far as evaluating a framework (or any JavaScript library) on Sacha Greif’s <a href="https://medium.freecodecamp.org/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library-3908c4ed3f49">12-point scale scoring system</a> by exploring features, accessibility, stability, performance, package ecosystem, community, learning curve, documentation, tooling, track record, team, compatibility, security for example. But on a tough schedule, it’s a good idea to consider <em>at least</em> the total cost on size + initial parse times before choosing an option; lightweight options such as <a href="https://github.com/developit/preact">Preact</a>, <a href="https://github.com/infernojs/inferno">Inferno</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://svelte.technology/">Svelte</a> or <a href="https://github.com/Polymer/polymer">Polymer</a> can get the job done just fine. The size of your baseline will define the constraints for your application’s code.</p>

<p>A good starting point is to choose a good default stack for your application. <a href="https://gatsbyjs.org/">Gatsby.js</a> (React), <a href="https://github.com/developit/preact-cli">Preact CLI</a>, and <a href="https://github.com/Polymer/pwa-starter-kit">PWA Starter Kit</a> provide reasonable defaults for fast loading out of the box on average mobile hardware.</p></li>
</ol>

{{< rimg breakout="true" href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53363a80-48ae-4f91-aed0-69d292e6d7a2/2018-js-processing-times.png" sizes="100vw" caption="(Image credit: <a href='https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4'>Addy Osmani</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53363a80-48ae-4f91-aed0-69d292e6d7a2/2018-js-processing-times.png'>Large preview</a>)" alt="JavaScript processing times in 2018 by Addy Osmani" >}}

<ol class="continue">
<li><strong>Consider using PRPL pattern and app shell architecture.</strong><br />Different frameworks will have different effects on performance and will require different strategies of optimization, so you have to clearly understand all of the nuts and bolts of the framework you’ll be relying on. When building a web app, look into the <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL pattern</a> and <a href="https://developers.google.com/web/updates/2015/11/app-shell">application shell architecture</a>. The idea is quite straightforward: Push the minimal code needed to get interactive for the initial route to render quickly, then use service worker for caching and pre-caching resources and then lazy-load routes that you need, asynchronously.</li>
</ol>

<figure class="article__image break-out"><a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/"><img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png" sizes="100vw" alt="PRPL Pattern in the application shell architecture"></a>
  <figcaption>
    <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL</a> stands for Pushing critical resource, Rendering initial route, Pre-caching remaining routes and Lazy-loading remaining routes on demand.
  </figcaption>
</figure>

<figure class="article__image"><a href="https://developers.google.com/web/updates/2015/11/app-shell"><img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg" sizes="100vw" alt="Application shell architecture"></a>
  <figcaption>
    An <a href="https://developers.google.com/web/updates/2015/11/app-shell">application shell</a> is the minimal HTML, CSS, and JavaScript powering a user interface.
  </figcaption>
</figure>

<ol class="continue">
<li><strong>Have you optimized the performance of your APIs?</strong><br />APIs are communication channels for an application to expose data to internal and third-party applications via so-called <em>endpoints</em>. When <a href="https://www.smashingmagazine.com/2012/10/designing-javascript-apis-usability/">designing and building an API</a>, we need a reasonable protocol to enable the communication between the server and third-party requests. <a href="https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/">Representational State Transfer</a> (<a href="https://web.archive.org/web/20130116005443/https://tomayko.com/writings/rest-to-my-wife"><em>REST</em></a>) is a well-established, logical choice: it defines a set of constraints that developers follow to make content accessible in a performant, reliable and scalable fashion. Web services that conform to the REST constraints, are called <em>RESTful web services</em>.

<p>As with good ol' HTTP requests, when data is retrieved from an API, any delay in server response will propagate to the end user, hence delaying rendering. When a resource wants to retrieve some data from an API, it will need to request the data from the corresponding endpoint. A component that renders data from several resources, such as an article with comments and author photos in each comment, may need several roundtrips to the server to fetch all the data before it can be rendered. Furthermore, the amount of data returned through REST is often more than what is needed to render that component.</p>

<p>If many resources require data from an API, the API might become a performance bottleneck. <a href="https://graphql.org/">GraphQL</a> provides a performant solution to these issues. Per se, GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data. Unlike REST, GraphQL can retrieve all data in a single request, and the response will be exactly what is required, without <em>over</em> or <em>under</em>-fetching data as it typically happens with REST.<p>

<p>In addition, because GraphQL is using schema (metadata that tells how the data is structured), it can already organize data into the preferred structure, so, for example, <a href="https://hackernoon.com/how-graphql-replaces-redux-3fff8289221d">with GraphQL, we could remove JavaScript code used for dealing with state management</a>, producing a cleaner application code that runs faster on the client.</p>

<p>If you want to get started with GraphQL, Eric Baer published two fantastic articles on yours truly Smashing Magazine: <a href="https://www.smashingmagazine.com/2018/01/graphql-primer-new-api-part-1/">A GraphQL Primer: Why We Need A New Kind Of API</a> and <a href="https://www.smashingmagazine.com/2018/01/graphql-primer-new-api-part-2/">A GraphQL Primer: The Evolution Of API Design</a> (<em>thanks for the hint, Leonardo!</em>).</p></li>
</ol>

{{< rimg breakout="true" href="https://hackernoon.com/how-graphql-replaces-redux-3fff8289221d" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5fda8d85-1151-4d0b-b2f6-da354ebae345/redux-rest-apollo-graphql.png" sizes="100vw" caption="A difference between REST and GraphQL, illustrated via a conversation between Redux + REST on the left, an Apollo + GraphQL on the right. (Image source: <a href='https://hackernoon.com/how-graphql-replaces-redux-3fff8289221d'>Hacker Noon</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5fda8d85-1151-4d0b-b2f6-da354ebae345/redux-rest-apollo-graphql.png'>Large preview</a>)" alt="Hacker Noon" >}}

<ol class="continue">
<li><strong>Will you be using AMP or Instant Articles?</strong><br />Depending on the priorities and strategy of your organization, you might want to consider using Google’s <a href="https://www.ampproject.org/">AMP</a> or Facebook’s <a href="https://instantarticles.fb.com/">Instant Articles</a> or Apple’s <a href="https://www.apple.com/news/">Apple News</a>. You can achieve good performance without them, but AMP <em>does</em> provide a solid performance framework with a free content delivery network (CDN), while Instant Articles will boost your visibility and performance on Facebook.</p>

<p>The seemingly obvious benefit of these technologies for users is <em>guaranteed performance</em>, so at times they might even prefer AMP-/Apple News/Instant Pages-links over "regular" and potentially bloated pages. For content-heavy websites that are dealing with a lot of third-party content, these options could potentially help speed up render times dramatically.</p>

<p><a href="https://timkadlec.com/remembers/2018-03-19-how-fast-is-amp-really/">Unless they don't.</a> According to Tim Kadlec, for example, "AMP documents tend to be faster than their counterparts, but they don’t necessarily mean a page is performant. AMP is not what makes the biggest difference from a performance perspective."</p>

<p>A benefit for the website owner is obvious: discoverability of these formats on their respective platforms and <a href="https://ethanmarcotte.com/wrote/ampersand/">increased visibility in search engines</a>. You could build <a href="https://www.smashingmagazine.com/2016/12/progressive-web-amps/">progressive web AMPs</a>, too, by reusing AMPs as a data source for your PWA. Downside? Obviously, a presence in a walled garden places developers in a position to produce and maintain a separate version of their content, and in case of Instant Articles and Apple News <a href="https://www.w3.org/blog/TAG/2017/07/27/distributed-and-syndicated-content-whats-wrong-with-this-picture/">without actual URLs</a> <em>(thanks Addy, Jeremy!)</em>.</p></li>

<li><strong>Choose your CDN wisely.</strong><br />Depending on how much dynamic data you have, you might be able to "outsource" some part of the content to a <a href="https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/">static site generator</a>, pushing it to a CDN and serving a static version from it, thus avoiding database requests. You could even choose a <a href="https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/">static-hosting platform</a> based on a CDN, enriching your pages with interactive components as enhancements (<a href="https://jamstack.org/">JAMStack</a>). In fact, some of those generators (like <a href="https://www.gatsbyjs.org/blog/2017-09-13-why-is-gatsby-so-fast/">Gatsby</a> on top of React) are actually <a href="https://tomdale.net/2017/09/compilers-are-the-new-frameworks/">website compilers</a> with many automated optimizations provided out of the box. As compilers add optimizations over time, the compiled output gets smaller and faster over time.</p>

<p>Notice that CDNs can serve (and offload) dynamic content as well. So, restricting your CDN to static assets is not necessary. Double-check whether your CDN performs compression and conversion (e.g. image optimization in terms of formats, compression and resizing at the edge), <a href="https://www.filamentgroup.com/lab/servers-workers.html">support for servers workers</a>, edge-side includes, which assemble static and dynamic parts of pages at the CDN’s edge (i.e. the server closest to the user), and other tasks.</p>

<p>Note: based on research by Patrick Meenan and Andy Davies, HTTP/2 is <a href="https://github.com/andydavies/http2-prioritization-issues#cdns--cloud-hosting-services">effectively broken on many CDNs</a>, so we shouldn’t be too optimistic about the performance boost there.</li>
</ol>

{{% feature-panel %}}

## Assets Optimizations

<ol class="continue">
<li><strong>Use Brotli or Zopfli for plain text compression.</strong><br />In 2015, Google <a href="https://opensource.googleblog.com/2015/09/introducing-brotli-new-compression.html">introduced</a> <a href="https://github.com/google/brotli">Brotli</a>, a new open-source lossless data format, which is now <a href="https://caniuse.com/#search=brotli">supported in all modern browsers</a>. In practice, Brotli appears to be <a href="https://paulcalvano.com/index.php/2018/07/25/brotli-compression-how-much-will-it-reduce-your-content/">much</a> <a href="https://quixdb.github.io/squash-benchmark/#results-table">more effective</a> than Gzip and Deflate. It might be (very) slow to compress, depending on the settings, but slower compression will ultimately lead to higher compression rates. Still, it decompresses fast. You can also <a href="https://tools.paulcalvano.com/compression.php">estimate Brotli compression savings for your site</a>.

<p>Browsers will accept it only if the user is visiting a website over HTTPS though. What’s the catch? Brotli still doesn’t come preinstalled on some servers today, and it’s not straightforward to set up without self-compiling Nginx. Still, <a href="https://www.tinywp.in/nginx-brotli/">it’s not that difficult</a>, and its support is coming, e.g. it’s available <a href="https://httpd.apache.org/docs/trunk/mod/mod_brotli.html">since Apache 2.4.26</a>. Brotli is widely supported, and many CDNs support it (<a href="https://community.akamai.com/community/web-performance/blog/2017/08/18/brotli-support-enablement-on-akamai">Akamai</a>, <a href="https://medium.com/@felice.geracitano/brotli-compression-delivered-from-aws-7be5b467c2e1">AWS</a>, <a href="https://www.keycdn.com/blog/keycdn-brotli-support">KeyCDN</a>, <a href="https://docs.fastly.com/guides/detailed-product-descriptions/performance-optimization-package">Fastly</a>, <a href="https://support.cloudflare.com/hc/en-us/articles/200168396-What-will-Cloudflare-compress-">Cloudlare</a>, <a href="https://www.cdn77.com/brotli">CDN77</a>) and you can <a href="https://calendar.perfplanet.com/2016/enabling-brotli-even-on-cdns-that-dont-support-it-yet/">enable Brotli even on CDNs that don’t support it</a> yet (with a service worker).</p>

<p>At the highest level of compression, Brotli is so slow that any potential gains in file size could be nullified by the amount of time it takes for the server to begin sending the response as it waits to dynamically compress the asset. With static compression, however, <a href="https://css-tricks.com/brotli-static-compression/">higher compression settings are preferred</a>.</p>

<p>Alternatively, you could look into using <a href="https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/">Zopfli’s compression algorithm</a>, which encodes data to Deflate, Gzip and Zlib formats. Any regular Gzip-compressed resource would benefit from Zopfli’s improved Deflate encoding because the files will be 3 to 8% smaller than Zlib’s maximum compression. The catch is that files will take around 80 times longer to compress. That’s why it’s a good idea to use Zopfli on resources that don’t change much, files that are designed to be compressed once and downloaded many times.</p>

<p>If you can bypass the cost of dynamically compressing static assets, it’s worth the effort. Both Brotli and Zopfli can be used for any plaintext payload &mdash; HTML, CSS, SVG, JavaScript, and so on.</p>

<p>The strategy? <a href="https://css-tricks.com/brotli-static-compression/">Pre-compress static assets with Brotli+Gzip</a> at the highest level and compress (dynamic) HTML on the fly with Brotli at level 1–4. Make sure that the server handles content negotiation for Brotli or gzip properly. If you can’t install/maintain Brotli on the server, use Zopfli.</p></li>

<li><strong>Use responsive images and WebP.</strong><br />As far as possible, use <a href="https://www.smashingmagazine.com/2014/05/responsive-images-done-right-guide-picture-srcset/">responsive images</a> with <code>srcset</code>, <code>sizes</code> and the <code>&lt;picture&gt;</code> element. While you’re at it, you could also make use of the <a href="https://www.smashingmagazine.com/2015/10/webp-images-and-performance/">WebP format</a> (supported in Chrome, Opera, Firefox 65, Edge 18) by serving WebP images with the <code>&lt;picture&gt;</code> element and a JPEG fallback (see Andreas Bovens' <a href="https://dev.opera.com/articles/responsive-images/#different-image-types-use-case">code snippet</a>) or by using content negotiation (using <code>Accept</code> headers). Ire Aderinokun has a very detailed <a href="https://bitsofco.de/why-and-how-to-use-webp-images-today/">tutorial on converting images to WebP</a>, too.</p>

<p>Sketch natively supports WebP, and WebP images can be exported from Photoshop using a <a href="https://telegraphics.com.au/sw/product/WebPFormat#webpformat">WebP plugin for Photoshop</a>. <a href="https://developers.google.com/speed/webp/docs/using">Other options are available</a>, too. If you’re using WordPress or Joomla, there are extensions to help you easily implement support for WebP, such as <a href="https://wordpress.org/plugins/optimus/">Optimus</a> and <a href="https://wordpress.org/plugins/cache-enabler/">Cache Enabler</a> for WordPress and <a href="https://extensions.joomla.org/extension/webp/">Joomla’s own supported extension</a> (via <a href="https://css-tricks.com/comparing-novel-vs-tried-true-image-formats/">Cody Arsenault</a>).</p>

<p>It’s important to note that while WebP image file sizes <a href="https://www.ctrl.blog/entry/webp-vs-guetzli-zopfli">compared to equivalent Guetzli and Zopfli</a>, the format <a href="https://youtu.be/jTXhYj2aCDU?t=630">doesn’t support progressive rendering like JPEG</a>, which is why users might see an actual image faster with a good ol' JPEG although WebP images might get faster through the network. With JPEG, we can serve a "decent" user experience with the half or even quarter of the data and load the rest later, rather than have a half-empty image as it is in the case of WebP. Your decision will depend on what you are after: with WebP, you’ll reduce the payload, and with JPEG you’ll improve perceived performance.</p>

<p>On Smashing Magazine, we use the postfix <code>-opt</code> for image names &mdash; for example, <code>brotli-compression-opt.png</code>; whenever an image contains that postfix, everybody on the team knows that the image has already been optimized. And — <em>shameless plug!</em> — Jeremy Wagner even <a href="https://www.smashingmagazine.com/ebooks/the-webp-manual/">published a Smashing book on WebP</a>.</p></li>
</ol>

<figure class="article__image break-out"><a href="https://www.responsivebreakpoints.com/"><img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db62c469-bbfc-4959-839d-590abb41b64e/responsive-breakpoints-opt.png 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db62c469-bbfc-4959-839d-590abb41b64e/responsive-breakpoints-opt.png 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db62c469-bbfc-4959-839d-590abb41b64e/responsive-breakpoints-opt.png 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db62c469-bbfc-4959-839d-590abb41b64e/responsive-breakpoints-opt.png 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db62c469-bbfc-4959-839d-590abb41b64e/responsive-breakpoints-opt.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db62c469-bbfc-4959-839d-590abb41b64e/responsive-breakpoints-opt.png" sizes="100vw" alt="Responsive Image Breakpoints Generator"></a>
  <figcaption>
    The <a href="https://www.responsivebreakpoints.com/">Responsive Image Breakpoints Generator</a> automates images and markup generation.
  </figcaption></figure>

<ol class="continue">
<li><strong>Are images properly optimized?</strong><br />When you’re working on a landing page on which it’s critical that a particular image loads blazingly fast, make sure that JPEGs are progressive and compressed with <a href="https://github.com/mozilla/mozjpeg">mozJPEG</a> (which improves the start rendering time by manipulating scan levels) or <a href="https://github.com/google/guetzli">Guetzli</a>, Google’s new open-source encoder focusing on perceptual performance, and utilizing learnings from Zopfli and WebP. <a href="https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3">The only downside</a>: slow processing times (a minute of CPU per megapixel). For PNG, we can use <a href="https://css-ig.net/pingo">Pingo</a>, and for SVG, we can use <a href="https://www.npmjs.com/package/svgo">SVGO</a> or <a href="https://jakearchibald.github.io/svgomg/">SVGOMG</a>. And if you need to quickly preview and copy or download all the SVG assets from a website, <a href="https://chrome.google.com/webstore/detail/svg-grabber-get-all-the-s/ndakggdliegnegeclmfgodmgemdokdmg">svg-grabber</a> can do that for you, too.

<p>Every single image optimization article would state it, but keeping vector assets clean and tight is always worth reminding. Make sure to clean up unused assets, remove unnecessary metadata and reduces the amount of path points in artwork (and thus SVG code). (<em>Thanks, Jeremy!</em>)</p>

<p>There are more advanced options though. You could:</p>
<ul>
<li>Use <a href="https://squoosh.app/">Squoosh</a> to compress, resize and manipulate images at the optimal compression levels (lossy or lossless),</li>
<li>Use the <a href="https://www.responsivebreakpoints.com/">Responsive Image Breakpoints Generator</a> or a service such as <a href="https://cloudinary.com/documentation/api_and_access_identifiers">Cloudinary</a> or <a href="https://www.imgix.com/">Imgix</a> to automate image optimization. Also, in many cases, using <code>srcset</code> and <code>sizes</code> alone will reap significant benefits.</li>
<li>To check the efficiency of your responsive markup, you can use <a href="https://github.com/filamentgroup/imaging-heap">imaging-heap</a>, a command line tool that measure the efficiency across viewport sizes and device pixel ratios.</li>
<li>Lazy load images and iframes with <a href="https://github.com/aFarkas/lazysizes">lazysizes</a>, a library that detects any visibility changes triggered through user interaction (or IntersectionObserver which we’ll explore later).</li>
<li>Watch out for images that are loaded by default, but might never be displayed &mdash; e.g. in carousels, accordions and image galleries.</li>
<li>Consider <a href="https://www.filamentgroup.com/lab/sizes-swap/">Swapping Images with the Sizes Attribute</a> by specifying different image display dimensions depending on media queries, e.g. to manipulate <code>sizes</code> to swap sources in a magnifier component.</li>
<li>Review <a href="https://csswizardry.com/2018/06/image-inconsistencies-how-and-when-browsers-download-images/">image download inconsistencies</a> to prevent unexpected downloads for foreground and background images.</li>
<li>To optimize storage interally, you could use Dropbox’s new <a href="https://github.com/dropbox/lepton">Lepton format</a> for losslessly compressing JPEGs by an average of 22%.</li>
<li>Watch out for the <a href="https://drafts.csswg.org/css-sizing-4/#ratios"><code>aspect-ratio</code> property in CSS</a> and <a href="https://github.com/ojanvafai/intrinsicsize-attribute"><code>intrinsicsize</code> attribute</a> which will allow us to set aspect ratios and dimensions for images, so browser can reserve a pre-defined layout slot early to <a href="https://24ways.org/2018/jank-free-image-loads/">avoid layout jumps</a> during the page load.</li>
<li>If you feel adventurous, you could chop and rearrange HTTP/2 streams using <a href="https://youtu.be/jTXhYj2aCDU?t=854">Edge workers</a>, basically a real-time filter living on the CDN, to send images faster through the network. Edge workers use JavaScript streams that use chunks which you can control (basically they are JavaScript that runs on the CDN edge that can modify the streaming responses), so you can control the delivery of images. With service worker it’s too late as you can’t control what’s on the wire, but it does work with Edge workers. So you can use them on top of static JPEGs saved progressively for a particular landing page.</li>
</ul>

{{< rimg href="https://pbs.twimg.com/media/DY1XZ28VwAAwjd8.jpg" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8422076c-6eea-4b35-a98c-b15445cb2dff/viewport-percentage-match.jpg" sizes="100vw" caption="A sample output by <a href='https://github.com/filamentgroup/imaging-heap'>imaging-heap</a>, a command line tool that measure the efficiency across viewport sizes and device pixel ratios. (<a href='https://pbs.twimg.com/media/DY1XZ28VwAAwjd8.jpg'>Image source</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8422076c-6eea-4b35-a98c-b15445cb2dff/viewport-percentage-match.jpg'>Large preview</a>)" alt="" >}}

<p>The future of responsive images might change dramatically with the adoption of <a href="https://cloudfour.com/thinks/responsive-images-201-client-hints/">client hints</a>. Client hints are HTTP request header fields, e.g. <code>DPR</code>, <code>Viewport-Width</code>, <code>Width</code>, <code>Save-Data</code>, <code>Accept</code> (to specify image format preferences) and others. They are supposed to inform the server about the specifics of user’s browser, screen, connection etc. As a result, the server can decide how to fill in the layout with appropriately sized images, and serve only these images in desired formats. With client hints, we move the resource selection from HTML markup and into the request-response negotiation between the client and server.</p>

<p>As Ilya Grigorik <a href="https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints">noted</a>, client hints complete the picture &mdash; they aren’t an alternative to responsive images. "The <code>&lt;picture&gt;</code> element provides the necessary art-direction control in the HTML markup. Client hints provide annotations on resulting image requests that enable resource selection automation. Service Worker provides full request and response management capabilities on the client." A service worker could, for example, append new client hints headers values to the request, rewrite the URL and point the image request to a CDN, adapt response based on connectivity and user preferences, etc. It holds true not only for image assets but for pretty much all other requests as well.</p>

<p>For clients that support client hints, one could measure <a href="https://twitter.com/igrigorik/status/1032657105998700544">42% byte savings on images</a> and 1MB+ fewer bytes for 70th+ percentile. On Smashing Magazine, we could measure <a href="https://www.smashingmagazine.com/2016/01/leaner-responsive-images-client-hints/">19-32% improvement</a>, too. Unfortunately, client hints still have to <a href="https://caniuse.com/#search=client-hints">gain some browser support</a>. Under consideration in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=935216">Firefox</a>. However, if you supply both the normal responsive images markup and the <code>&lt;meta&gt;</code> tag for Client Hints, then the browser will evaluate the responsive images markup and request the appropriate image source using the Client Hints HTTP headers.</p>

<p>Not good enough? Well, you can also improve perceived performance for images with the <a href="https://csswizardry.com/2016/10/improving-perceived-performance-with-multiple-background-images/">multiple</a> <a href="https://jmperezperez.com/medium-image-progressive-loading-placeholder/">background</a> <a href="https://manu.ninja/dominant-colors-for-lazy-loading-images#tiny-thumbnails">images</a> <a href="https://css-tricks.com/the-blur-up-technique-for-loading-background-images/">technique</a>. Keep in mind that <a href="https://css-tricks.com/contrast-swap-technique-improved-image-performance-css-filters/">playing with contrast</a> and blurring out unnecessary details (or removing colors) can reduce file size as well. Ah, you need to enlarge a small photo without losing quality? Consider using <a href="https://letsenhance.io">Letsenhance.io</a>.</p>

<p>These optimizations so far cover just the basics. Addy Osmani has published a <a href="https://images.guide/">very detailed guide on Essential Image Optimization</a> that goes very deep into details of image compression and color management. For example, you could blur out unnecessary parts of the image (by applying a Gaussian blur filter to them) to reduce the file size, and eventually you might even start removing colors or turn the picture into black and white to reduce the size even further. For background images, exporting photos from Photoshop with 0 to 10% quality can be absolutely acceptable as well. Ah, and <a href="https://calendar.perfplanet.com/2018/dont-use-jpeg-xr-on-the-web/">don’t use JPEG-XR on the web</a> &mdash; "the processing of decoding JPEG-XRs software-side on the CPU nullifies and even outweighs the potentially positive impact of byte size savings, especially in the context of SPAs".</p>
</li>
<li><strong>Are videos properly optimized?</strong><br />We covered images so far, but we’ve avoided a conversation about good ol' GIFs. Frankly, instead of loading heavy animated GIFs which impact both rendering performance and bandwidth, it’s a good idea to switch either to animated WebP (with GIF being a fallback) or replace them with <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/">looping HTML5 videos</a> altogether. Yes, the browser performance <a href="https://calendar.perfplanet.com/2017/animated-gif-without-the-gif/#-but-we-already-have-video-tags">is slow with <code>&lt;video&gt;</code></a>, and, unlike with images, browsers do not preload <code>&lt;video&gt;</code> content, but they tend to be lighter and smaller than GIFs. Not an option? Well, at least we can add lossy compression to GIFs with <a href="https://kornel.ski/lossygif">Lossy GIF</a>, <a href="https://github.com/kohler/gifsicle">gifsicle</a> or <a href="https://github.com/pornel/giflossy">giflossy</a>.</p>

<p>Early tests show that inline videos within <code>img</code> tags <a href="https://calendar.perfplanet.com/2017/animated-gif-without-the-gif/">display 20× faster and decode 7× faster</a> than the GIF equivalent, in addition to being a fraction in file size. Although the support for <code>&lt;img src=".mp4"&gt;</code> has <a href="https://developer.apple.com/safari/technology-preview/release-notes/">landed in Safari Technology Preview</a>, we are far from it being adopted widely as it’s <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=791658#c36">not coming to Blink any time soon</a>.</p>

{{< rimg breakout="true" href="" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c987b182-0a0e-40e5-8f8d-dd81feb991f5/replace-animated-gifs.jpg" sizes="100vw" caption="Addy Osmani <a href='https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/'>recommends</a> to replace animated GIFs with looping inline videos. The file size difference is noticeable (80% savings). (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c987b182-0a0e-40e5-8f8d-dd81feb991f5/replace-animated-gifs.jpg'>Large preview</a>)" alt="" >}}

<p>In the land of good news though, video formats have been advancing massively over the years. For a long time, we had hoped that WebM would become the format to rule them all, and WebP (which is basically one still image inside of the WebM video container) will become a replacement for dated image formats. But despite WebP and WebM <a href="https://caniuse.com/webp">gaining</a> <a href="https://caniuse.com/#feat=webm">support</a> these days, the breakthrough didn’t happen.</p>

<p>In 2018, the Alliance of Open Media has released a new promising video format called <em>AV1</em>. AV1 has compression similar to H.265 codec (the evolution of H.264) but unlike the latter, AV1 is free. The H.265 license pricing pushed browser vendors to adopting a comparably performant AV1 instead: <strong>AV1 (just like H.265) compress twice as good as WebP</strong>.</p>

{{< rimg href="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/AV1_logo_2018.svg/2560px-AV1_logo_2018.svg.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b5a4354f-4a9b-420d-8979-bd7abb87aebc/av1-logo-2018-full.png" sizes="100vw" caption="AV1 has good chances of becoming the ultimate standard for video on the web. (Image credit: <a href='https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/AV1_logo_2018.svg/2560px-AV1_logo_2018.svg.png'>Wikimedia.org</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b5a4354f-4a9b-420d-8979-bd7abb87aebc/av1-logo-2018-full.png'>Large preview</a>)" alt="AV1 Logo 2018" >}}

<p>In fact, Apple currently uses HEIF format and HEVC (H.265), and all the photos and videos on the latest iOS are saved in these formats, not JPEG. While <a href="https://caniuse.com/#search=heif">HEIF</a> and <a href="https://caniuse.com/#search=hevc">HEVC (H.265)</a> aren’t properly exposed to the web (yet?), AV1 is &mdash; and <a href="https://caniuse.com/#feat=av1">it’s gaining browser support</a>. So adding the <code>AV1</code> source in your <code>&lt;video&gt;</code> tag is reasonable, as all browser vendors seem to be on board.</p>

<p>For now, the most widely used and supported encoding is H.264, served by MP4 files, so before serving the file, make sure that your MP4s are processed with a <a href="https://medium.com/@borisschapira/optimize-your-mp4-video-for-better-performance-dareboost-blog-fb2f3f3dce77">multipass-encoding</a>, blurred with the <a href="https://yalantis.com/blog/experiments-with-ffmpeg-filters-and-frei0r-plugin-effects/">frei0r iirblur effect</a> (if applicable) and <a href="https://www.adobe.com/devnet/video/articles/mp4_movie_atom.html">moov atom metadata</a> is moved to the head of the file, while your server <a href="https://medium.com/@borisschapira/optimize-your-mp4-video-for-better-performance-dareboost-blog-fb2f3f3dce77">accepts byte serving</a>. Boris Schapira provides <a href="https://medium.com/@borisschapira/optimize-your-mp4-video-for-better-performance-dareboost-blog-fb2f3f3dce77">exact instructions for FFmpeg</a> to optimize videos to the maximum. Of course, providing WebM format as an alternative would help, too.</p>

<p>Video playback performance is a story on its own, and if you’d like to dive into it in details, take a look at Doug Sillar’s series on <a href="https://www.smashingmagazine.com/2018/10/video-playback-on-the-web-part-1/">The Current State of Video</a> and <a href="https://www.smashingmagazine.com/2018/10/video-playback-on-the-web-part-2/">Video Delivery Best Practices</a> that include details on video delivery metrics, video preloading, compression and streaming.</p>
</li>
</ol>

{{< rimg breakout="true" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/eb634666-55ab-4db3-aa40-4b146a859041/font-loading-strategies-opt.png" sizes="100vw" caption="Zach Leatherman’s <a href='https://www.zachleat.com/web/comprehensive-webfonts/'>Comprehensive Guide to Font-Loading Strategies</a> provides a dozen options for better web font delivery." alt="Zach Leatherman’s Comprehensive Guide to Font-Loading Strategies" >}}

<ol class="continue">
<li><strong>Are web fonts optimized?</strong><br />The first question that’s worth asking if you can get away with <a href="https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/">using UI system fonts</a> in the first place. If it’s not the case, chances are high that the web fonts you are serving include glyphs and extra features and weights that aren’t being used. You can ask your type foundry to subset web fonts or if you are using open-source fonts, subset them on your own with <a href="https://www.afasterweb.com/2018/03/09/subsetting-fonts-with-glyphhanger/">Glyphhanger</a> or <a href="https://www.fontsquirrel.com/tools/webfont-generator">Fontsquirrel</a>. You can even automate your entire workflow with Peter Müller’s <a href="https://github.com/Munter/subfont#readme">subfont</a>, a command line tool that statically analyses your page in order to generate the most optimal web font subsets, and then inject them into your page.

<p><a href="https://caniuse.com/#search=woff2">WOFF2 support</a> is great, and you can use WOFF as fallback for browsers that don’t support it &mdash; after all, legacy browsers would probably be served well enough with system fonts. There are <em>many, many, many</em> options for web font loading, and you can choose one of the strategies from Zach Leatherman’s "<a href="https://www.zachleat.com/web/comprehensive-webfonts/">Comprehensive Guide to Font-Loading Strategies</a>," (code snippets also available as <a href="https://github.com/zachleat/web-font-loading-recipes">Web font loading recipes</a>).</p>

<p>Probably the better options to consider today are <a href="https://www.zachleat.com/web/comprehensive-webfonts/#critical-foft-preload">Critical FOFT with <code>preload</code></a> and <a href="https://www.zachleat.com/web/the-compromise/">"The Compromise" method</a>. Both of them use a two-stage render for delivering web fonts in steps &mdash; first a small supersubset required to render the page fast and accurately with the web font, and then load the rest of the family async. The difference is that "The Compromise" technique loads polyfill asynchronously only if <a href="https://www.igvita.com/2014/01/31/optimizing-web-font-rendering-performance/#font-load-events">font load events</a> are not supported, so you don’t need to load the polyfill by default. Need a quick win? Zach Leatherman has a <a href="https://www.zachleat.com/web/23-minutes/">quick 23-min tutorial and case study</a> to get your fonts in order.</p>

<p>In general, it’s a good idea to use the <code>preload</code> resource hint to preload fonts, but in your markup include the hints <em>after</em> the link to critical CSS and JavaScript. Otherwise, font loading will cost you in the first render time. Still, it might be a good idea to <a href="https://youtu.be/FbguhX3n3Uc?t=1637">be selective</a> and choose files that matter most, e.g. the ones that are critical for rendering or that would help you avoiding visible and disruptive text reflows. In general, Zach advises to <strong>preload one or two fonts of each family</strong> &mdash; it also makes sense to delay some font loading if they are less-critical.</p>

<p>Nobody likes waiting for the content to be displayed. With the <a href="https://font-display.glitch.me/"><code>font-display</code> CSS descriptor</a>, we can control the font loading behavior and enable content to be readable <em>immediately</em> (<code>font-display: optional</code>) or <em>almost immediately</em> (<code>font-display: swap</code>). However, if you want to <a href="https://www.zachleat.com/web/font-display-reflow/">avoid text reflows</a>, we still need to use the Font Loading API, specifically to <strong>group repaints</strong>, or when you are using third party hosts. Unless you can use <a href="https://blog.cloudflare.com/fast-google-fonts-with-cloudflare-workers/">Google Fonts with Cloudflare Workers</a>, of course. Talking about Google Fonts: consider using <a href="https://google-webfonts-helper.herokuapp.com/fonts">google-webfonts-helper</a>, a hassle-free way to self-host Google Fonts. <a href="https://speakerdeck.com/addyosmani/web-performance-made-easy?slide=55">Always self-host your fonts</a> for maximum control if you can.</p>

<p>In general, if you use <code>font-display: optional</code>, it <a href="https://www.zachleat.com/web/preload-font-display-optional/">might not be a good idea</a> to also use <code>preload</code> as it it’ll trigger that web font request early (causing network congestion if you have other critical path resources that need to be fetched). Use <code>preconnect</code> for faster cross-origin font requests, but be cautious with <code>preload</code> as preloading fonts from a different origin will incur network contention. All of these techniques are covered in Zach’s <a href="https://github.com/zachleat/web-font-loading-recipes">Web font loading recipes</a>.</p>

<p>Also, it might be a good idea to opt out of web fonts (or at least second stage render) if the user has enabled <a href="https://webkit.org/blog/7551/responsive-design-for-motion/">Reduce Motion</a> in accessibility preferences or has opted in for Data Saver Mode (see <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/save-data/"><code>Save-Data</code> header</a>). Or when the user happens to have slow connectivity (via <a href="https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API">Network Information API</a>).</p>

<p>To measure the web font loading performance, consider the <a href="https://noti.st/zachleat/KNaZEg/the-five-whys-of-web-font-loading-performance#s5IYiho"><em>All Text Visible</em></a> metric (the moment when all fonts have loaded and all content is displayed in web fonts), as well as <a href="https://noti.st/zachleat/KNaZEg/the-five-whys-of-web-font-loading-performance#sJw0KSc"><em>Web Font Reflow Count</em></a> after first render. Obviously, the lower both metrics are, the better the performance is. It’s important to notice that <a href="https://alistapart.com/blog/post/variable-fonts-for-responsive-design">variable</a> <a href="https://www.smashingmagazine.com/2017/09/new-font-technologies-improve-web/">fonts</a> might require a <a href="https://youtu.be/FbguhX3n3Uc?t=2161">significant performance consideration</a>. They give designers a much broader design space for typographic choices, but it comes at the cost of a single serial request opposed to a number of individual file requests. That single request might be slow blocking the entire typographic appearance on the page. On the good side though, with a variable font in place, we’ll get exactly one reflow by default, so no JavaScript will be required to group repaints.</p>

<p>Now, what would make a bulletproof web font loading strategy? Subset fonts and prepare them for the 2-stage-render, declare them with a <code>font-display</code> descriptor, use Font Loading API to group repaints and store fonts in a persistent service worker’s cache. You could fall back to Bram Stein’s <a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a> if necessary. And if you’re interested in measuring the performance of font loading, Andreas Marschke explores <a href="https://www.andreas-marschke.name/posts/2017/12/29/Fonts-API-UserTiming-Boomerang.html">performance tracking with Font API and UserTiming API</a>.</p>

<p>Finally, don’t forget to include <a href="https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/august/how-to-subset-fonts-with-unicode-range/"><code>unicode-range</code></a> to break down a large font into smaller language-specific fonts, and use Monica Dinculescu’s <a href="https://meowni.ca/font-style-matcher/">font-style-matcher</a> to minimize a jarring shift in layout, due to sizing discrepancies between the fallback and the web fonts.</p></li>
</ol>

{{% feature-panel %}}

## Build Optimizations

<ol class="continue">
<li><strong>Set your priorities straight.</strong><br />It’s a good idea to know what you are dealing with first. Run an inventory of all of your assets (JavaScript, images, fonts, third-party scripts and "expensive" modules on the page, such as carousels, complex infographics and multimedia content), and break them down in groups.

<p>Set up a spreadsheet. Define the basic <em>core</em> experience for legacy browsers (i.e. fully accessible core content), the <em>enhanced</em> experience for capable browsers (i.e. the enriched, full experience) and the <em>extras</em> (assets that aren’t absolutely required and can be lazy-loaded, such as web fonts, unnecessary styles, carousel scripts, video players, social media buttons, large images). A while back, we published an article on "<a href="https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/">Improving Smashing Magazine’s Performance</a>," which describes this approach in detail.</p>

<p>When optimizing for performance we need to reflect our priorities. Load the <em>core experience</em> immediately, then <em>enhancements</em>, and then the <em>extras</em>.</p></li>

<li><strong>Revisit the good ol' "cutting-the-mustard" technique.</strong><br />These days we can still use the <a href="https://www.filamentgroup.com/lab/modernizing-delivery.html">cutting-the-mustard technique</a> to send the core experience to legacy browsers and an enhanced experience to modern browsers. An <a href="https://snugug.com/musings/modern-cutting-the-mustard/">updated variant of the technique</a> would use ES2015+ <code>&lt;script type="module"&gt;</code>. Modern browsers would interpret the script as a JavaScript module and run it as expected, while legacy browsers wouldn’t recognize the attribute and ignore it because it’s unknown HTML syntax.

<p>These days we need to keep in mind that feature detection alone isn’t enough to make an informed decision about the payload to ship to that browser. On its own, <em>cutting-the-mustard</em> deduces device capability from browser version, which is no longer something we can do today.</p>

<p>For example, cheap Android phones in developing countries mostly run Chrome and will cut the mustard despite their limited memory and CPU capabilities. Eventually, using the <a href="https://github.com/w3c/device-memory">Device Memory Client Hints Header</a>, we’ll be able to target low-end devices more reliably. At the moment of writing, the header is supported only in Blink (it goes for <a href="https://caniuse.com/#search=client%20hints">client hints</a> in general). Since Device Memory also has a JavaScript API which is <a href="https://developers.google.com/web/updates/2017/12/device-memory">already available in Chrome</a>, one option could be to feature detect based on the API, and fall back to "cutting the mustard" technique only if it’s not supported (<em>thanks, Yoav!</em>).</p></li>

<li><strong>Parsing JavaScript is expensive, so keep it small.</strong><br />When dealing with single-page applications, we need some time to initialize the app before we can render the page. Your setting will require your custom solution, but you could watch out for modules and techniques to speed up the initial rendering time. For example, <a href="https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad">here’s how to debug React performance</a> and <a href="https://logrocket-blog.ghost.io/death-by-a-thousand-cuts-a-checklist-for-eliminating-common-react-performance-issues/">eliminate common React performance issues</a>, and <a href="https://www.youtube.com/watch?v=p9vT0W31ym8">here’s how to improve performance in Angular</a>. In general, most performance issues come from the initial parsing time to bootstrap the app.

<p><a href="https://youtu.be/_srJ7eHS3IM?t=9m33s">JavaScript has a cost</a>, but it’s rarely the file size alone that drains on performance. Parsing and executing times vary significantly depending on the hardware of a device. On an average phone (Moto G4), a parsing time alone for 1MB of (uncompressed) JavaScript will be around 1.3–1.4s, with 15–20% of all time on mobile spent on parsing. With compiling in play, just prep work on JavaScript takes 4s on average, with around 11s before First Meaningful Paint on mobile. Reason: <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201">parse and execution times can easily be 2–5x times higher</a> on low-end mobile devices.</p>

<p>To guarantee high performance, as developers, we need to find ways to write and deploy less JavaScript. That’s why it pays off to examine every single JavaScript dependency in detail.</p>

<p>There are many tools to help you make an informed decision about the impact of your dependencies and viable alternatives:</p>

<ul>
<li><a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a></li>
<li><a href="https://github.com/danvk/source-map-explorer">Source Map Explorer</a></li>
<li><a href="https://github.com/samccone/bundle-buddy">Bundle Buddy</a></li>
<li><a href="https://bundlephobia.com/">Bundlephobia</a></li>
<li><a href="https://github.com/GoogleChromeLabs/size-plugin">Webpack size-plugin</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost">Import Cost for Visual Code</a></li>
</ul>

<p>An interesting way of avoiding parsing costs is to use <a href="https://emberjs.com/blog/2017/10/10/glimmer-progress-report.html#toc_binary-templates">binary templates</a> that Ember has introduced in 2017. With them, Ember replaces JavaScript parsing with JSON parsing, which is presumably faster. (<em>Thanks, Leonardo, Yoav!</em>)</p>

<p><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201#7557">Measure JavaScript parse and compile times</a>. We can use synthetic testing tools and browser traces to track parse times, and browser implementors are talking about <a href="https://github.com/w3c/resource-timing/issues/133">exposing RUM-based processing times in the future</a>. Alternatively, consider using Etsy’s <a href="https://github.com/danielmendel/DeviceTiming">DeviceTiming</a>, a little tool allowing you to instruct your JavaScript to measure parse and execution time on any device or browser.</p>

<p>Bottom line: while size matters, it isn’t everything. Parse and compiling times <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201">don’t necessarily increase linearly</a> when the script size increases.</p></li>

<li><strong>Are you using tree-shaking, scope hoisting and code-splitting?</strong><br /><a href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking/">Tree-shaking</a> is a way to clean up your build process by only including code that is actually used in production and eliminate unused imports <a href="https://www.2ality.com/2015/12/webpack-tree-shaking.html">in Webpack</a>. With Webpack and Rollup, we also have <a href="https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f">scope hoisting</a> that allows both tools to detect where <code>import</code> chaining can be flattened and converted into one inlined function without compromising the code. With Webpack, we can also use <a href="https://react-etc.net/entry/json-tree-shaking-lands-in-webpack-4-0">JSON Tree Shaking</a> as well.

<p>Also, you might want to consider learning how to <a href="https://csswizardry.com/2011/09/writing-efficient-css-selectors/">write efficient CSS selectors</a> as well as how to <a href="https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/">avoid bloat and expensive styles</a>. Feeling like going beyond that? You can also use Webpack to shorten the class names and use scope isolation
to <a href="https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b">rename CSS class names dynamically</a> at the compilation time.</p>

<p><a href="https://webpack.js.org/guides/code-splitting/">Code-splitting</a> is another Webpack feature that splits your code base into "chunks" that are loaded on demand. Not all of the JavaScript has to be downloaded, parsed and compiled right away. Once you define split points in your code, Webpack can take care of the dependencies and outputted files. It enables you to keep the initial download small and to request code on demand when requested by the application. Alexander Kondrov has a <a href="https://hackernoon.com/lessons-learned-code-splitting-with-webpack-and-react-f012a989113">fantastic introduction to code-splitting with Webpack and React</a>.</p>

<p>Consider using <a href="https://github.com/GoogleChromeLabs/preload-webpack-plugin">preload-webpack-plugin</a> that takes routes you code-split and then prompts browser to preload them using <code>&lt;link rel="preload"&gt;</code> or <code>&lt;link rel="prefetch"&gt;</code>. <a href="https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules">Webpack inline directives</a> also give some control over <code>preload</code>/<code>prefetch</code></p>

<p>Where to define split points? By tracking which chunks of CSS/JavaScript are used, and which aren’t used. Umar Hansa <a href="https://vimeo.com/235431630#t=11m37s">explains</a> how you can use Code Coverage from Devtools to achieve it.</p>

<p>If you aren’t using Webpack, note that <a href="https://rollupjs.org/">Rollup</a> shows significantly better results than Browserify exports. While we’re at it, you might want to check out <a href="https://github.com/ampproject/rollup-plugin-closure-compiler">rollup-plugin-closure-compiler</a> and <a href="https://github.com/nolanlawson/rollupify">Rollupify</a>, which converts ECMAScript 2015 modules into one big CommonJS module &mdash; because small modules can have a <a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/">surprisingly high performance cost</a> depending on your choice of bundler and module system.</p>
</li>
<li><strong>Can you offload JavaScript into a Web Worker?</strong><br />To reduce the negative impact to Time-to-Interactive, it might be a good idea to look into offloading heavy JavaScript into a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a> or caching via a Service Worker.

<p>As the code base keeps growing, the UI performance bottlenecks will show up, slowing down the user’s experience. That’s <a href="https://medium.com/google-developer-experts/running-fetch-in-a-web-worker-700dc33ac854">because DOM operations are running alongside your JavaScript</a> on the main thread. With <a href="https://flaviocopes.com/web-workers/">web workers</a>, we can move these expensive operations to a background process that’s running on a different thread. Typical use cases for web workers are <a href="https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a">prefetching data and Progressive Web Apps</a> to load and store some data in advance so that you can use it later when needed. And you could use <a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a> to streamline the communication between the main page and the worker. Still some work to do, but we are getting there.</p>

<p><a href="https://github.com/developit/workerize">Workerize</a> allows you to move a module into a Web Worker, automatically reflecting exported functions as asynchronous proxies. And if you’re using Webpack, you could use <a href="https://github.com/developit/workerize-loader">workerize-loader</a>. Alternatively, you could use <a href="https://github.com/GoogleChromeLabs/worker-plugin">worker-plugin</a> as well.</p>

<p>Note that Web Workers don’t have access to the DOM because the DOM is not "thread-safe", and the code that they execute needs to be contained in a separate file.</p></li>

<li><strong>Can you offload JavaScript into WebAssembly?</strong><br />We could potentialy also convert JavaScript into <a href="https://webassembly.org/">WebAssembly</a>, a binary instruction format, designed as a portable target for compilation of high-level languages like C/C++/Rust. Its <a href="https://caniuse.com/#feat=wasm">browser support is remarkable</a>, and it has recently become viable as <a href="https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/">function calls between JavaSript and WASM are getting faster</a>, at least in Firefox.

<p>In real-world scenarios, <a href="https://medium.com/samsung-internet-dev/performance-testing-web-assembly-vs-javascript-e07506fd5875">JavaScript seems to perform better than WebAssembly</a> on smaller array sizes and WebAssembly performs better than JavaScript on larger array sizes. For most web apps, JavaScript is a better fit, and WebAssembly is best used for computationally intensive web apps, such as web games. However, it might be worth investigating if a switch to WebAssembly would result in noticeable performance improvements.</p>

<p>If you’d like to learn more about WebAssembly:</p>

<ul>
<li>Lin Clark has written a <a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">thorough series to WebAssembly</a> and Milica Mihajlija provides a <a href="https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71">general overview</a> of how to run native code in the browser, why would you do that, and what it all means for JavaScript and the future of web development.</li>
<li>Google Codelabs provides an <a href="https://codelabs.developers.google.com/codelabs/web-assembly-intro/index.html">Introduction to WebAssembly</a>, a 60 min course in which you’ll learn how to take native code—in C and compile it to WebAssembly, and then call it directly from JavaScript.</li>
<li>Alex Danilo has <a href="https://www.youtube.com/watch?v=6v4E6oksar0">explained WebAssembly and how it works</a> at his Google I/O 2017 talk. Also, Benedek Gagyi <a href="https://www.youtube.com/watch?v=l2DHjRmgAF8">shared a practical case study on WebAssembly</a>, specifically how the team uses it as output format for their C++ codebase to iOS, Android and the website.</li>
</ul>
</li>
</ol>

{{< rimg breakout="true" href="https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bbb2ea83-7674-47d8-9cad-89a2de009915/how-webassembly-works.png" sizes="100vw" caption="Milica Mihajlija provides a general overview of <a href='https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71'>how WebAssembly works and why it’s useful</a>. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bbb2ea83-7674-47d8-9cad-89a2de009915/how-webassembly-works.png'>Large preview</a>)" alt="A general overview of how WebAssembly works and why it’s useful." >}}

<ol class="continue">
<li><strong>Are you using an ahead-of-time compiler?</strong><br />Use an <a href="https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/">ahead-of-time compiler</a> to <a href="https://www.smashingmagazine.com/2016/03/server-side-rendering-react-node-express/">offload some of the client-side rendering</a> to the <a href="https://redux.js.org/docs/recipes/ServerRendering.html">server</a> and, hence, output usable results quickly. Finally, consider using <a href="https://github.com/nolanlawson/optimize-js">Optimize.js</a> for faster initial loading by wrapping eagerly invoked functions (it <a href="https://twitter.com/tverwaes/status/809788255243739136">might not be necessary</a> any longer, though).</li>
</ol>

{{< rimg src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/31237c37-d7db-4faa-9849-51657e122331/babel-preset-opt.png" sizes="100vw" caption="From <a href='https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices'>Fast By Default: Modern Loading Best Practices</a> by the one-and-only Addy Osmani. Slide 76." alt="'Fast By Default: Modern Loading Best Practices' by Addy Osmani" >}}

<ol class="continue">
<li><strong>Serve legacy code only to legacy browsers.</strong><br />With ES2015 being <a href="https://kangax.github.io/compat-table/es6/">remarkably well supported in modern browsers</a>, we can <a href="https://2ality.com/2017/02/babel-preset-env.html">use <code>babel-preset-env</code></a> to only transpile ES2015+ features unsupported by the modern browsers you are targeting. Then <a href="https://gist.github.com/newyankeecodeshop/79f3e1348a09583faf62ed55b58d09d9">set up two builds</a>, one in ES6 and one in ES5. As mentioned above, JavaScript modules are now <a href="https://caniuse.com/#feat=es6-module">supported in all major browsers</a>, so use <a href="https://developers.google.com/web/fundamentals/primers/modules">use <code>script type="module"</code></a> to let browsers with ES module support load the file, while older browsers could load legacy builds with <code>script nomodule</code>. And we can automate the entire process with <a href="https://github.com/philipwalton/webpack-esnext-boilerplate">Webpack ESNext Boilerplate</a>.

<p>Note that these days we can write module-based JavaScript that runs natively in the browser, without transpilers or bundlers. <a href="https://developers.google.com/web/updates/2017/12/modulepreload"><code>&lt;link rel="modulepreload"&gt;</code> header</a> provides a way to initiate early (and high-priority) loading of module scripts. Basically, it’s a nifty way to help in maximizing bandwidth usage, by telling the browser about what it needs to fetch so that it’s not stuck with anything to do during those long roundtrips. Also, Jake Archibald has published a detailed article with <a href="https://jakearchibald.com/2017/es-modules-in-browsers/">gotchas and things t keep in mind with ES Modules</a> that’s worth reading.</p>

<p>For lodash, <a href="https://github.com/lodash/babel-plugin-lodash">use <code>babel-plugin-lodash</code></a> that will load only modules that you are using in your source. Your dependencies might also depend on other versions of Lodash, so <a href="https://www.contentful.com/blog/2017/10/27/put-your-webpack-bundle-on-a-diet-part-3/">transform generic lodash <code>requires</code> to cherry-picked ones</a> to avoid code duplication. This might save you quite a bit of JavaScript payload.</p>

<p>Shubham Kanodia has written a <a href="https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/">detailed low-maintenance guide on smart bundling</a>: to shipping legacy code to only legacy browsers in production with the code snippet you could use right away.</p>
</li>
</ol>

{{< rimg breakout="true" href="https://jakearchibald.com/2017/es-modules-in-browsers/" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d46ddc8b-4bd7-4627-b738-baf62807b26f/inline-scripts-deferred.png" sizes="100vw" caption="Jake Archibald has published a detailed article with <a href='https://jakearchibald.com/2017/es-modules-in-browsers/'>gotchas and things to keep in mind with ES Modules</a>, e.g. inline scripts are deferred until blocking external scripts and inline scripts are executed. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d46ddc8b-4bd7-4627-b738-baf62807b26f/inline-scripts-deferred.png'>Large preview</a>)" alt="As explained in Jake Archibald’s article, inline scripts are deferred until blocking external scripts and inline scripts are executed." >}}

<ol class="continue">
<li><strong>Are you using differential serving for JavaScript?</strong><br />We want to send just the necessary JavaScript through the network, yet it means being slightly more focused and granular about the delivery of those assets. A while back Philip Walton introduced the idea of <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/">differential serving</a>. The idea is to compile and serve two separate JavaScript bundles: the “regular” build, the one with Babel-transforms and polyfills and serve them only to legacy browsers that actually need them, and another bundle (same functionality) that has no transforms or polyfills.

<p>As a result, we help reduce blocking of the main thread by reducing the amount of scripts the browser needs to process. Jeremy Wagner has published a <a href="https://calendar.perfplanet.com/2018/doing-differential-serving-in-2019/">comprehensive article on differential serving</a> and how to set it up in your build pipeline in 2019, from setting up Babel, to what tweaks you’ll need to make in Webpack, as well as the benefits of doing all this work.</p></li>

<li><strong>Identify and rewrite legacy code with incremental decoupling</strong>.<br />Long-living projects have a tendency to gather dust and dated code. Revisit your dependencies and assess how much time would be required to refactor or rewrite legacy code that has been causing trouble lately. Of course, it’s always a big undertaking, but once you know the impact of the legacy code, you could start with <a href="https://githubengineering.com/removing-jquery-from-github-frontend/">incremental decoupling</a>.

<p>First, set up metrics that tracks if the ratio of legacy code calls is staying constant or going down, not up. Publicly discourage the team from using the library and make sure that your CI <a href="https://github.com/dgraham/eslint-plugin-jquery">alerts</a> developers if it’s used in pull requests. <a href="https://githubengineering.com/removing-jquery-from-github-frontend/#polyfills">polyfills</a> could help transition from legacy code to rewritten codebase that uses standard browser features.</p></li>

<li><strong>Identify and remove unused CSS/JS</strong>.<br /><a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage">CSS and JavaScript code coverage</a> in Chrome allows you to learn which code has been executed/applied and which hasn't. You can start recording the coverage, perform actions on a page, and then explore the code coverage results. Once you’ve detected unused code, <a href="https://twitter.com/TheLarkInn/status/1012429019063578624">find those modules and lazy load with <code>import()</code></a> (see the entire thread). Then repeat the coverage profile and validate that it’s now shipping less code on initial load.</p>

<p>You can use <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> to <a href="https://twitter.com/matijagrcic/statuses/1060863620568043520">programmatically collect code coverage</a> and Canary already allows you to <a href="https://twitter.com/tkadlec/status/1073330247758684163">export code coverage results</a>, too. As Andy Davies noted, you might want to collect code coverage for <a href="https://twitter.com/AndyDavies/status/1073339071106297856">both modern and legacy browsers</a> though. There are many <a href="https://github.com/GoogleChromeLabs/puppeteer-examples">other use-cases for Puppeteer</a>, such as, for example, <a href="https://meowni.ca/posts/2017-puppeteer-tests/">automatic visual diffing</a> or <a href="https://blog.cowchimp.com/monitoring-unused-css-by-unleashing-the-devtools-protocol/">monitoring unused CSS with every build</a>.</p>

<p>Furthermore, <a href="https://github.com/FullHuman/purgecss">purgecss</a>, <a href="https://github.com/giakki/uncss">UnCSS</a> and <a href="https://github.com/geuis/helium-css">Helium</a> can help you remove unused styles from CSS. And if you aren’t certain if a suspicious piece of code is used somewhere, you can follow <a href="https://csswizardry.com/2018/01/finding-dead-css/">Harry Roberts' advice</a>: create a 1&times;1px transparent GIF for a particular class and drop it into a <code>dead/</code> directory, e.g. <code>/assets/img/dead/comments.gif</code>. After that, you set that specific image as a background on the corresponding selector in your CSS, sit back and wait for a few months if the file is going to appear in your logs. If there are no entries, nobody had that legacy component rendered on their screen: you can probably go ahead and delete it all.</p>

<p>For the <em>I-feel-adventurous</em>-department, you could even automate gathering on unused CSS through a set of pages by <a href="https://blog.cowchimp.com/monitoring-unused-css-by-unleashing-the-devtools-protocol/">monitoring DevTools using DevTools</a>.</p></li>

<li><strong>Trim the size of your JavaScript bundles.</strong><br />As Addy Osmani <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">noted</a>, there’s a high chance you’re shipping full JavaScript libraries when you only need a fraction, along with dated polyfills for browsers that don’t need them, or just duplicate code. To avoid the overhead, consider using <a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations">webpack-libs-optimizations</a> that removes unused methods and polyfills during the build process.

<p>Add bundle auditing into your regular workflow as well. There might be some lightweight alternatives to heavy libraries you’ve added years ago, e.g. Moment.js could be replaced with <a href="https://github.com/date-fns/date-fns">date-fns</a> or <a href="https://moment.github.io/luxon/">Luxon</a>. Benedikt Rötsch’s research <a href="https://www.contentful.com/blog/2017/10/27/put-your-webpack-bundle-on-a-diet-part-3/">showed</a> that a switch from Moment.js to date-fns could shave around 300ms for First paint on 3G and a low-end mobile phone.</p>

<p>That’s where tools like <a href="https://bundlephobia.com/">Bundlephobia</a> could help find the cost of adding a npm package to your bundle. You can even <a href="https://github.com/AymenLoukil/Google-lighthouse-custom-audit">integrate these costs with a Lighthouse Custom Audit</a>. This goes for frameworks, too. By removing or trimming the <a href="https://speakerdeck.com/addyosmani/web-performance-made-easy?slide=22">Vue MDC Adapter</a> (Material Components for Vue), styles drop from 194KB to 10KB.</p>

<p>Feeling adventurous? You could look into <a href="https://gist.github.com/gaearon/d85dccba72b809f56a9553972e5c33c4">Prepack</a>. It compiles JavaScript to equivalent JavaScript code, but unlike Babel or Uglify, it lets you write normal JavaScript code, and outputs equivalent JavaScript code that runs faster.</p>

<p>Alternatively to shipping the entire framework, you could even trim your framework and compile it into a raw JavaScript bundle that does not require additional code. <a href="https://svelte.technology/">Svelte does it</a>, and so does <a href="https://github.com/sokra/rawact">Rawact Babel plugin</a> which transpiles React.js components to native DOM operations at build-time. Why? Well, as maintainers explain, "react-dom includes code for every possible component/HTMLElement that can be rendered, including code for incremental rendering, scheduling, event handling, etc. But there are applications which do not need all these features (at initial page load). For such applications, it might make sense to use native DOM operations to build the interactive user interface."</p></li>
</ol>

{{< rimg breakout="true" href="https://cdn-images-1.medium.com/max/2000/1*fdX-6h2HnZ_Mo4fBHflh2w.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e30c7d5b-ef8b-46ba-b0fc-b1d5a31cefff/webpack-comparison.png" sizes="100vw" caption="In <a href='https://www.contentful.com/blog/2017/10/27/put-your-webpack-bundle-on-a-diet-part-3/'>his article</a>, Benedikt Rötsch’s showed that a switch from Moment.js to date-fns could shave around 300ms for First paint on 3G and a low-end mobile phone. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e30c7d5b-ef8b-46ba-b0fc-b1d5a31cefff/webpack-comparison.png'>Large preview</a>)" alt="Webpack comparison" >}}

<ol class="continue">
<li><strong>Are you using predictive prefetching for JavaScript chunks?</strong><br />We could use heuristics to decide when to preload JavaScript chunks. <a href="https://github.com/guess-js/guess">Guess.js</a> is a set of tools and libraries that use Google Analytics data to determine which page a user is mostly likely to visit next from a given page. Based on user navigation patterns collected from Google Analytics or other sources, Guess.js builds a machine-learning model to predict and prefetch JavaScript that will be required in each subsequent page.

<p>Hence, every interactive element is receiving a probability score for engagement, and based on that score, a client-side script decides to prefetch a resource ahead of time. You can integrate the technique to your <a href="https://github.com/mgechev/guess-next">Next.js application</a>, <a href="https://blog.mgechev.com/2018/03/18/machine-learning-data-driven-bundling-webpack-javascript-markov-chain-angular-react/">Angular and React</a>, and there is a <a href="https://github.com/guess-js/guess/tree/master/packages/guess-webpack">Webpack plugin</a> which automates the setup process as well.</p>

<p>Obviously, you might be prompting the browser to consume unneeded data and prefetch undesirable pages, so it’s a good idea to be quite conservative in the number of prefetched requests. A good use case would be prefetching validation scripts required in the checkout, or speculative prefetch when a critical call-to-action comes into the viewport.</p>

<p>Need something less sophisticated? <a href="https://github.com/GoogleChromeLabs/quicklink">Quicklink</a> is a small library that automatically prefetches links in the viewport during idle time in attempt to make next-page navigations load faster. However, it’s also data-considerate, so it doesn’t prefetch on 2G or if <code>Data-Saver</code> is on.</p>
</li>

<li><strong>Take advantage of optimizations for your target JavaScript engine.</strong><br />Study what JavaScript engines dominate in your user base, then explore ways of optimizing for them. For example, when optimizing for V8 which is used in Blink-browsers, Node.js runtime and Electron, make use of <a href="https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html">script streaming</a> for monolithic scripts. It allows <code>async</code> or <code>defer scripts</code> to be parsed on a separate background thread once downloading begins, hence in some cases improving page loading times by up to 10%. Practically, <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201#3498">use <code>&lt;script defer&gt;</code></a> in the <code>&lt;head&gt;</code>, so that the <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201#3498">browsers can discover the resource</a> early and then parse it on the background thread.

<p><strong>Caveat</strong>: <em>Opera Mini <a href="https://caniuse.com/#search=defer">doesn’t support script deferment</a>, so if you are developing for India or Africa,</em> <code>defer</code> <em>will be ignored, resulting in blocking rendering until the script has been evaluated (thanks Jeremy!)</em>.</p>
</li>
</ol>

<figure class="article__image break-out"><a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/">
<img loading="lazy" decoding="async" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ab06acd3-833a-4634-abf9-fc8d91939250/fmp-and-tti-opt.jpeg 400w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ab06acd3-833a-4634-abf9-fc8d91939250/fmp-and-tti-opt.jpeg 800w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ab06acd3-833a-4634-abf9-fc8d91939250/fmp-and-tti-opt.jpeg 1200w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ab06acd3-833a-4634-abf9-fc8d91939250/fmp-and-tti-opt.jpeg 1600w,
          https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ab06acd3-833a-4634-abf9-fc8d91939250/fmp-and-tti-opt.jpeg 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ab06acd3-833a-4634-abf9-fc8d91939250/fmp-and-tti-opt.jpeg" sizes="100vw" alt="Progressive booting"></a>
  <figcaption>
    <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/">Progressive booting</a> means using server-side rendering to get a quick first meaningful paint, but also include some minimal JavaScript to keep the time-to-interactive close to the first meaningful paint.
  </figcaption>

</figure>

<ol class="continue">
<li><strong>Client-side rendering or server-side rendering?</strong><br />In both scenarios, our goal should be to set up <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/">progressive booting</a>: Use server-side rendering to get a quick first meaningful paint, but also include some minimal necessary JavaScript to keep the time-to-interactive close to the first meaningful paint. If JavaScript is coming too late after the First Meaningful Paint, the browser might <a href="https://davidea.st/articles/measuring-server-side-rendering-performance-is-tricky">lock up the main thread</a> while parsing, compiling and executing late-discovered JavaScript, hence handcuffing the <a href="https://philipwalton.com/articles/why-web-developers-need-to-care-about-interactivity/">interactivity of site or application</a>.

<p>To avoid it, always break up the execution of functions into separate, asynchronous tasks, and where possible use <code>requestIdleCallback</code>. Consider lazy loading parts of the UI using WebPack’s <a href="https://developers.google.com/web/updates/2017/11/dynamic-import">dynamic <code>import()</code> support</a>, avoiding the load, parse, and compile cost until the users really need them (<em>thanks Addy!</em>).</p>

<p>In its essence, Time to Interactive (TTI) tells us the time between navigation and interactivity. The metric is defined by looking at the first five-second window after the initial content is rendered, in which no JavaScript tasks take longer than 50ms. If a task over 50ms occurs, the search for a five-second window starts over. As a result, the browser will first assume that it reached Interactive, just to switch to Frozen, just to eventually switch back to Interactive.</p>

<p>Once we reached Interactive, we can then &mdash; either on demand or as time allows &mdash; boot non-essential parts of the app. Unfortunately, as <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting">Paul Lewis noticed</a>, frameworks typically have no concept of priority that can be surfaced to developers, and hence progressive booting is difficult to implement with most libraries and frameworks. If you have the time and resources, use this strategy to ultimately boost performance.</p>

<p>So, client-side or server-side? If there is no visible benefit to the user, <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">client-side rendering might not be really necessary</a> &mdash; actually, server-side-rendered HTML could be faster. Perhaps you could even <a href="https://jamstack.org/">pre-render some of your content with static site generators</a> and push them straight to the CDNs, with some JavaScript on top.</p>

<p>Limit the use of client-side frameworks to pages that absolutely require them. Server-rendering and client-rendering are a disaster if done poorly. Consider <a href="https://github.com/GoogleChromeLabs/prerender-loader">pre-rendering at build time</a> and <a href="https://github.com/GoogleChromeLabs/critters">CSS inlining on the fly</a> to produce production-ready static files. Addy Osmani has given a <a href="https://www.youtube.com/watch?v=63I-mEuSvGA">fantastic talk on the Cost of JavaScript</a> that might be worth watching.</p></li>

<li><strong>Constrain the impact of third-party scripts.</strong><br />With all performance optimizations in place, often we can’t control third-party scripts coming from business requirements. Third-party-scripts metrics aren’t influenced by end-user experience, so too often one single script ends up calling a long tail of obnoxious third-party scripts, hence ruining a dedicated performance effort. To contain and mitigate performance penalties that these scripts bring along, it’s not enough to just load them asynchronously (<a href="https://www.twnsnd.com/posts/performant_third_party_scripts.html">probably via defer</a>) and accelerate them via resource hints such as <code>dns-prefetch</code> or <code>preconnect</code>.

<p>As Yoav Weiss explained in his <a href="https://conffab.com/video/taking-back-control-over-third-party-content/">must-watch talk on third-party scripts</a>, in many cases these scripts download resources that are dynamic. The resources change between page loads, so we don’t necessarily know which hosts the resources will be downloaded from and what resources they would be.</p>

<p>What options do we have then? Consider <strong>using service workers by racing the resource download with a timeout</strong> and if the resource hasn’t responded within a certain timeout, return an empty response to tell the browser to carry on with parsing of the page. You can also log or block third-party requests that aren’t successful or don’t fulfill certain criteria. If you can, <a href="https://medium.com/caspertechteam/we-shaved-1-7-seconds-off-casper-com-by-self-hosting-optimizely-2704bcbff8ec">load the 3rd-party-script from your own server</a> rather than from the vendor’s server.</p>

{{< rimg breakout="true" href="https://medium.com/caspertechteam/we-shaved-1-7-seconds-off-casper-com-by-self-hosting-optimizely-2704bcbff8ec" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cf570272-840e-4cf8-92de-76808a12422c/casper-case-study-optimizely.png" sizes="100vw" caption="Casper.com published a detailed case study on how they managed to shave 1.7 seconds off the site by self-hosting Optimizely. It might be worth it. (<a href='https://medium.com/caspertechteam/we-shaved-1-7-seconds-off-casper-com-by-self-hosting-optimizely-2704bcbff8ec'>Image source</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cf570272-840e-4cf8-92de-76808a12422c/casper-case-study-optimizely.png'>Large preview</a>)" alt="Casper.com published a detailed case study on how they managed to shave 1.7 seconds off the site by self-hosting Optimizely. It might be worth it." >}}

<p>Another option is to establish a <strong>Content Security Policy (CSP)</strong> to restrict the impact of third-party scripts, e.g. disallowing the download of audio or video. The best option is to embed scripts via <code>&lt;iframe&gt;</code> so that the scripts are running in the context of the iframe and hence don’t have access to the DOM of the page, and can’t run arbitrary code on your domain. Iframes can be further constrained using the <code>sandbox</code> attribute, so you can disable any functionality that iframe may do, e.g. prevent scripts from running, prevent alerts, form submission, plugins, access to the top navigation, and so on.</p>

<p>For example, it’s probably going to be necessary to allow scripts to run with <code>&lt;iframe sandbox="allow-scripts"&gt;</code>. Each of the limitations can be lifted via various <code>allow</code> values on the <code>sandbox</code> attribute (<a href="https://caniuse.com/#search=sandbox">supported almost everywhere</a>), so constrain them to the bare minimum of what they should be allowed to do.</p>

<p>Consider using Intersection Observer; that would enable ads to be iframed while still dispatching events or getting the information that they need from the DOM (e.g. ad visibility). Watch out for new policies such as <a href="https://www.smashingmagazine.com/2018/12/feature-policy/">Feature policy</a>, resource size limits and CPU/Bandwidth priority to limit harmful web features and scripts that would slow down the browser, e.g. synchronous scripts, synchronous XHR requests, document.write and outdated implementations.</p>

<p>To <a href="https://csswizardry.com/2017/07/performance-and-resilience-stress-testing-third-parties/">stress-test third parties</a>, examine bottom-up summaries in Performance profile page in DevTools, test what happens if a request is blocked or it has timed out &mdash; for the latter, you can use WebPageTest’s Blackhole server <code>blackhole.webpagetest.org </code> that you can point specific domains to in your <code>hosts</code> file. Preferably <a href="https://www.twnsnd.com/posts/performant_third_party_scripts.html">self-host and use a single hostname</a>, but also <a href="https://www.soasta.com/blog/10-pro-tips-for-managing-the-performance-of-your-third-party-scripts/">generate a request map</a> that exposes fourth-party calls and detect when the scripts change. You can use Harry Roberts' <a href="https://csswizardry.com/2018/05/identifying-auditing-discussing-third-parties/">approach for auditing third parties</a> and produce spreadsheets like <a href="https://docs.google.com/spreadsheets/d/1uTcRSoJAkXfIm2yfG5hvCSzvSZD9fAwXNQMVK3HdPMI/edit#gid=0">this one</a>. Harry also explains the auditing workflow in his <a href="https://www.youtube.com/watch?v=bmIUYBNKja4">talk on third-party performance and auditing</a>.</p></li>
</ol>

{{< rimg src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1e12dad-ea64-430e-b3db-b67fb76029d8/block-request-url-image-opt.png" sizes="100vw" caption="Image credit: <a href='https://csswizardry.com/2017/07/performance-and-resilience-stress-testing-third-parties/#request-blocking'>Harry Roberts</a>" alt="request blocking" >}}

<ol class="continue">
<li><strong>Set HTTP cache headers properly.</strong><br />Double-check that <code>expires</code>, <code>max-age</code>, <code>cache-control</code>, and other HTTP cache headers have been set properly. In general, resources should be cacheable either for a <a href="https://jakearchibald.com/2016/caching-best-practices/">very short time (if they are likely to change) or indefinitely (if they are static)</a> &mdash; you can just change their version in the URL when needed. Disable the <code>Last-Modified</code> header as any asset with it will result in a conditional request with an <code>If-Modified-Since</code>-header even if the resource is in cache. Same with <code>Etag</code>.

<p>Use <code>Cache-control: immutable</code>, designed for fingerprinted static resources, to avoid revalidation (as of December 2018, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">supported in Firefox, Edge and Safari</a>; in Firefox only on <code>https://</code> transactions). In fact "across all of the pages in the HTTP Archive, 2% of requests and 30% of sites appear to <a href="https://discuss.httparchive.org/t/cache-control-immutable-a-year-later/1195">include at least 1 immutable response</a>. Additionally, most of the sites that are using it have the directive set on assets that have a long freshness lifetime."</p>

<p>Remember the <a href="https://www.fastly.com/blog/stale-while-revalidate-stale-if-error-available-today">stale-while-revalidate</a>? As you probably know, we specify the caching time with the <code>Cache-Control</code> response header, e.g. <code>Cache-Control: max-age=604800</code>. After 604800 seconds have passed, the cache will re-fetch the requested content, causing the page to load slower. This slowdown can be avoided by using <code>stale-while-revalidate</code>; it basically defines an extra window of time during which a cache can use a stale asset as long as it revalidates it async in the background. Thus, it "hides" latency (both in the network and on the server) from clients.</p>

<p>In October 2018, Chrome published an <a href="https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/rspPrQHfFkI/discussion">intent to ship</a> handling of <code>stale-while-revalidate</code> in HTTP Cache-Control header, so as a result, it should improve subsequent page load latencies as stale assets are no longer in the critical path. Result: <a href="https://twitter.com/RyanTownsend/status/1072443651844911104">zero RTT for repeat views</a>.</p>

<p>You can use <a href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers">Heroku’s primer on HTTP caching headers</a>, Jake Archibald’s "<a href="https://jakearchibald.com/2016/caching-best-practices/">Caching Best Practices</a>" and Ilya Grigorik’s <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en">HTTP caching primer</a> as guides. Also, be wary of the <a href="https://www.smashingmagazine.com/2017/11/understanding-vary-header/">vary header</a>, especially <a href="https://www.fastly.com/blog/getting-most-out-vary-fastly">in relation to CDNs</a>, and watch out for the <a href="https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-key-latest.html">Key header</a> which helps avoiding an additional round trip for validation whenever a new request differs slightly (but not significantly) from prior requests (<em>thanks, Guy!</em>).</p>

<p>Also, double-check that you aren’t sending <a href="https://www.fastly.com/blog/headers-we-dont-want">unnecessary headers</a> (e.g. <code>x-powered-by</code>, <code>pragma</code>, <code>x-ua-compatible</code>, <code>expires</code> and others) and that you include <a href="https://www.fastly.com/blog/headers-we-want">useful security and performance headers</a> (such as <code>Content-Security-Policy</code>, <code>X-XSS-Protection</code>, <code>X-Content-Type-Options</code> and others). Finally, keep in mind the <a href="https://medium.com/@ankur_anand/the-terrible-performance-cost-of-cors-api-on-the-single-page-application-spa-6fcf71e50147">performance cost of CORS requests</a> in single-page applications.</p>
</li>
</ol>

{{% feature-panel %}}

## Delivery Optimizations

<ol class="continue">
<li><strong>Do you load all JavaScript libraries asynchronously?</strong><br />When the user requests a page, the browser fetches the HTML and constructs the DOM, then fetches the CSS and constructs the CSSOM, and then generates a rendering tree by matching the DOM and CSSOM. If any JavaScript needs to be resolved, the browser won’t start rendering the page until it’s resolved, thus delaying rendering. As developers, we have to explicitly tell the browser not to wait and to start rendering the page. The way to do this for scripts is with the <code>defer</code> and <code>async</code> attributes in HTML.

<p>In practice, it turns out we should <a href="https://calendar.perfplanet.com/2016/prefer-defer-over-async/">prefer <code>defer</code> to</a> <code>async</code></a> (at a <a href="https://github.com/h5bp/lazyweb-requests/issues/42">cost to users of Internet Explorer</a> up to and including version 9, because you’re likely to break scripts for them). According to <a href="https://youtu.be/RwSlubTBnew?t=1034">Steve Souders</a>, once <code>async</code> scripts arrive, they are executed immediately. If that happens very fast, for example when the script is in cache aleady, it can actually block HTML parser. With <code>defer</code>, browser doesn’t execute scripts until HTML is parsed. So, unless you need JavaScript to execute before start render, it’s better to use <code>defer</code>.</p>

<p>Also, as mentioned above, limit the impact of third-party libraries and scripts, especially with social sharing buttons and <code>&lt;iframe&gt;</code> embeds (such as maps). <a href="https://github.com/ai/size-limit">Size Limit</a> helps you <a href="https://evilmartians.com/chronicles/size-limit-make-the-web-lighter">prevent JavaScript libraries bloat</a>: If you accidentally add a large dependency, the tool will inform you and throw an error. You can use <a href="https://www.savjee.be/2015/01/Creating-static-social-share-buttons/">static social sharing buttons</a> (such as by <a href="https://simplesharingbuttons.com">SSBG</a>) and <a href="https://developers.google.com/maps/documentation/static-maps/intro">static links to interactive maps</a> instead.</p>

<p>You might want to <a href="https://calendar.perfplanet.com/2018/a-csp-compliant-non-blocking-script-loader/">revise your non-blocking script loader for CSP compliance</a>.</p></li>

<li><strong>Lazy load expensive components with IntersectionObserver.</strong><br />In general, it’s a good idea to lazy-load all expensive components, such as heavy JavaScript, videos, iframes, widgets, and potentially images. The most performant way to do so is by using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer API</a> that provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document’s viewport. Basically, you need to create a new <code>IntersectionObserver</code> object, which receives a callback function and a set of options. Then we add a target to observe.

<p>The callback function executes when the target becomes visible or invisible, so when it intercepts the viewport, you can start taking some actions before the element becomes visible. In fact, we have a granular control over when the observer’s callback should be invoked, with <code>rootMargin</code> (margin around the root) and <code>threshold</code> (a single number or an array of numbers which indicate at what percentage of the target’s visibility we are aiming).</p>

<p>Alejandro Garcia Anglada has published a <a href="https://medium.com/@aganglada/intersection-observer-in-action-efc118062366">handy tutorial</a> on how to actually implement it, Rahul Nanwani wrote a detailed post on <a href="https://css-tricks.com/the-complete-guide-to-lazy-loading-images/">lazy-loading foreground and background images</a>, and Google Fundamentals provide a <a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/">detailed tutorial on lazy loading images and video with Intersection Observer</a> as well. Remember art-directed storytelling long reads with moving and sticky objects? You can implement <a href="https://github.com/russellgoldenberg/scrollama">performant scrollytelling with Intersection Observer</a>, too.</p>

<p>Also, watch out for the <a href="https://css-tricks.com/a-native-lazy-load-for-the-web-platform/"><code>lazyload</code> attribute</a> that will allow us to specify which images and <code>iframe</code>s should be lazy loaded, natively. <a href="https://www.chromestatus.com/feature/5641405942726656">Feature policy: LazyLoad</a> will provide a mechanism that allows us to force opting in or out of LazyLoad functionality on a per-domain basis (similar to how <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policies</a> work). Bonus: once shipped, <a href="https://twitter.com/csswizardry/status/1050717710525509633">priority hints</a> will allow us to specify importance on scripts and preloads in the header as well (currently in Chrome Canary).</p></li>

<li><strong>Load images progressively.</strong><br />You could even take lazy loading to the next level by adding <a href="https://calendar.perfplanet.com/2017/progressive-image-loading-using-intersection-observer-and-sqip/">progressive image loading</a> to your pages. Similarly to Facebook, Pinterest and Medium, you could load low quality or even blurry images first, and then as the page continues to load, replace them with the full quality versions by using the <a href="https://www.guypo.com/introducing-lqip-low-quality-image-placeholders">LQIP (Low Quality Image Placeholders) technique</a> proposed by Guy Podjarny.</p>

<p>Opinions differ if these techniques improve user experience or not, but it definitely improves time to first meaningful paint. We can even automate it by using <a href="https://github.com/technopagan/sqip">SQIP</a> that creates a low quality version of an image as an SVG placeholder, or <a href="https://calendar.perfplanet.com/2018/gradient-image-placeholders/">Gradient Image Placeholders</a> with CSS linear gradients. These placeholders could be embedded within HTML as they naturally compress well with text compression methods. In his article, Dean Hume <a href="https://calendar.perfplanet.com/2017/progressive-image-loading-using-intersection-observer-and-sqip/">has described</a> how this technique can be implemented using Intersection Observer.</p>

<p>Browser support? <a href="https://caniuse.com/#feat=intersectionobserver">Decent</a>, with Chrome, Firefox, Edge and Samsung Internet being on board. WebKit status is currently <a href="https://webkit.org/status/#specification-intersection-observer">supported in preview</a>. Fallback? If the browser doesn’t support intersection observer, we can still <a href="https://medium.com/@aganglada/intersection-observer-in-action-efc118062366">lazy load</a> a <a href="https://github.com/jeremenichelli/intersection-observer-polyfill">polyfill</a> or load the images immediately. And there is even a <a href="https://github.com/ApoorvSaxena/lozad.js">library</a> for it.</p>

<p>Want to go fancier? You could <a href="https://jmperezperez.com/svg-placeholders/">trace your images</a> and use primitive shapes and edges to create a lightweight SVG placeholder, load it first, and then transition from the placeholder vector image to the (loaded) bitmap image.</p></li>

{{< rimg breakout="true" href="https://jmperezperez.com/svg-placeholders/" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f7f56052-6abb-4d18-a5aa-8d84102d812e/jmperez-composition-primitive-full.jpg" sizes="100vw" caption="SVG lazy loading technique by <a href='https://jmperezperez.com/svg-placeholders/'>José M. Pérez</a>. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f7f56052-6abb-4d18-a5aa-8d84102d812e/jmperez-composition-primitive-full.jpg'>Large preview</a>)" alt="SVG lazy loading technique by José M. Pérez" >}}

<li><strong>Do you send critical CSS?</strong><br />To ensure that browsers start rendering your page as quickly as possible, it’s become a <a href="https://www.smashingmagazine.com/2015/08/understanding-critical-css/">common practice</a> to collect all of the CSS required to start rendering the first visible portion of the page (known as "critical CSS" or "above-the-fold CSS") and add it inline in the <code>&lt;head&gt;</code> of the page, thus reducing roundtrips. Due to the limited size of packages exchanged during the slow start phase, your budget for critical CSS is around 14 KB.

<p>If you go beyond that, the browser will need additional roundtrips to fetch more styles. <a href="https://github.com/filamentgroup/criticalCSS">CriticalCSS</a> and <a href="https://github.com/addyosmani/critical">Critical</a> enable you to do just that. You might need to do it for every template you’re using. If possible, consider using the <a href="https://www.filamentgroup.com/lab/modernizing-delivery.html">conditional inlining approach</a> used by the Filament Group, or <a href="https://www.smashingmagazine.com/2018/11/pitfalls-automatically-inlined-code/">convert inline code to static assets on the fly</a>.</p>

<p>With HTTP/2, critical CSS could be stored in a separate CSS file and delivered via a <a href="https://www.filamentgroup.com/lab/modernizing-delivery.html">server push</a> without bloating the HTML. The catch is that server pushing is <a href="https://twitter.com/jaffathecake/status/867699157150117888">troublesome</a> with many gotchas and race conditions across browsers. It isn’t supported consistently and has some caching issues (see slide 114 onwards of <a href="https://www.slideshare.net/Fastly/http2-what-no-one-is-telling-you">Hooman Beheshti’s presentation</a>). The effect could, in fact, <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">be negative</a> and bloat the network buffers, preventing genuine frames in the document from being delivered. Also, it appears that server pushing is much <a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit">more effective on warm connections</a> due to the TCP slow start.</p>

<p>Even with HTTP/1, putting critical CSS in a separate file on the root domain <a href="https://www.jonathanklein.net/2014/02/revisiting-cookieless-domain.html">has benefits</a>, sometimes even more than inlining due to caching. Chrome speculatively opens a second HTTP connection to the root domain when requesting the page, which removes the need for a TCP connection to fetch this CSS (<em>thanks, Philip!</em>)</p>

<p>A few gotchas to keep in mind: unlike <code>preload</code> that can trigger preload from any domain, you can only push resources from your own domain or domains you are authoritative for. It can be initiated as soon as the server gets the very first request from the client. Server pushed resources land in the Push cache and are removed when the connection is terminated. However, since an HTTP/2 connection can be re-used across multiple tabs, pushed resources can be claimed by requests from other tabs as well (<em>thanks, Inian!</em>).</p>

<p>At the moment, there is no simple way for the server to know if pushed resources are already in <a href="https://blog.yoav.ws/tale-of-four-caches/">one of the user’s caches</a>, so resources will keep being pushed with every user’s visit. You may then need to create a <a href="https://css-tricks.com/cache-aware-server-push/">cache-aware HTTP/2 server push mechanism</a>. If fetched, you could try to get them from a cache based on the index of what’s already in the cache, avoiding secondary server pushes altogether.</p>

<p>Keep in mind, though, that <a href="https://calendar.perfplanet.com/2016/cache-digests-http2-server-push/">the new <code>cache-digest</code> specification</a> negates the need to manually build such "cache-aware" servers, basically declaring a new frame type in HTTP/2 to communicate what’s already in the cache for that hostname. As such, it could be particularly useful for CDNs as well.</p>

<p>For dynamic content, when a server needs some time to generate a response, the browser isn’t able to make any requests since it’s not aware of any sub-resources that the page might reference. For that case, we can warm up the connection and increase the TCP congestion window size, so that future requests can be completed faster. Also, all inlined assets are usually good candidates for server pushing. In fact, Inian Parameshwaran <a href="https://dexecure.com/blog/http2-push-vs-http-preload/">did remarkable research comparing HTTP/2 Push vs. HTTP Preload</a>, and it’s a fantastic read with all the details you might need. Server Push or Not Server Push? Colin Bendell’s <a href="https://shouldipush.com/">Should I Push?</a> might point you in the right direction.</p>

<p>Bottom line: As Sam Saccone <a href="https://medium.com/@samccone/performance-futures-bundling-281543d9a0d5">noted</a>, <code>preload</code> is good for moving the start download time of an asset closer to the initial request, while Server Push is good for cutting out a full RTT (<a href="https://blog.yoav.ws/being_pushy/">or more</a>, depending on your server think time) &mdash; if you have a service worker to prevent unnecessary pushing, that is.</p></li>

<li><strong>Experiment with regrouping your CSS rules.</strong><br />We’ve got used to critical CSS, but there are a few optimizations that could go beyond that. Harry Roberts conducted a <a href="https://csswizardry.com/2018/11/css-and-network-performance/">remarkable research</a> with quite surprising results. For example, it might be a good idea to split the main CSS file out into its individual media queries. That way, the browser will retrieve critical CSS with high priority, and everything else with low priority &mdash; completely off the critical path.</p>

<p>Also, avoid placing <code>&lt;link rel="stylesheet" /&gt;</code> before <code>async</code> snippets. If scripts don’t depend on stylesheets, consider placing blocking scripts above blocking  styles. If they do, split that JavaScript in two and load it either side of your CSS.</p>

<p>Scott Jehl solved another interesting problem by <a href="https://www.filamentgroup.com/lab/inlining-cache.html">caching an inlined CSS file with a service worker</a>, a common problem familiar if you’re using critical CSS. Basically, we add an ID attribute onto the <code>style</code> element so that it’s easy to find it using JavaScript, then a small piece of JavaScript finds that CSS and uses the Cache API to store it in a local browser cache (with a content type of <code>text/css</code>) for use on subsequent pages. To avoid inlining on subsequent pages and instead reference the cached assets externally, we then set a cookie on the first visit to a site. <em>Voilà!</em></p></li>

</ol>

<figure class="video-container break-out"><iframe loading="lazy" src="https://www.youtube.com/embed/Cjo9iq8k-bc" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen autoplay></iframe><figcaption>Do we <a href="https://jakearchibald.com/2016/streams-ftw/">stream reponses</a>? With streaming, HTML rendered during the initial navigation request can take full advantage of the browser’s streaming HTML parser.</figcaption></figure>

<ol class="continue">
<li><strong>Do you stream responses?</strong><br />Often forgotten and neglected, <a href="https://streams.spec.whatwg.org/">streams</a> provide an interface for reading or writing asynchronous chunks of data, only a subset of which might be available in memory at any given time. Basically, they allow the page that made the original request to start working with the response as soon as the first chunk of data is available, and use parsers that are optimized for streaming to progressively display the content.

<p>We could create one stream from multiple sources. For example, instead of serving an empty UI shell and letting JavaScript populate it, you can let the service worker construct a stream where the shell comes from a cache, but the body comes from the network. As Jeff Posnick <a href="https://developers.google.com/web/updates/2016/06/sw-readablestreams">noted</a>, if your web app is powered by a CMS that server-renders HTML by stitching together partial templates, that model translates directly into using streaming responses, with the templating logic replicated in the service worker instead of your server. Jake Archibald’s <a href="https://jakearchibald.com/2016/streams-ftw/">The Year of Web Streams</a> article highlights how exactly you could build it. Performance boost is <a href="https://www.youtube.com/watch?v=Cjo9iq8k-bc">quite noticeable</a>.</p>

<p>One important advantage of streaming the entire HTML response is that HTML rendered during the initial navigation request can take full advantage of the browser’s streaming HTML parser. Chunks of HTML that are inserted into a document after the page has loaded (as is common with content populated via JavaScript) can’t take advantage of this optimization.</p>

<p>Browser support? <a href="https://caniuse.com/#search=streams">Getting there</a> with Chrome 52+, Firefox 57+ (behind flag), Safari and Edge supporting the API and Service Workers being <a href="https://caniuse.com/#search=serviceworker">supported in all modern browsers</a>.</p></li>

<li><strong>Consider making your components connection-aware.</strong><br/>Data can be <a href="https://whatdoesmysitecost.com/">expensive</a> and with growing payload, we need to respect users who choose to opt into data savings while accessing our sites or apps. The <a href="https://developers.google.com/web/updates/2016/02/save-data">Save-Data client hint request header</a> allows us to customize the application and the payload to cost- and performance-constrained users. In fact, you could <a href="https://css-tricks.com/help-users-save-data/">rewrite requests for high DPI images to low DPI images</a>, remove web fonts, fancy parallax effects, preview thumbnails and infinite scroll, turn off video autoplay, server pushes, reduce the number of displayed items and downgrade image quality, or even change how you <a href="https://dev.to/addyosmani/adaptive-serving-using-javascript-and-the-network-information-api-331p">deliver markup</a>. Tim Vereecke has published a very detailed article on <a href="https://calendar.perfplanet.com/2018/data-shaver-strategies/">data-s(h)aver strategies</a> featuring many options for data saving.

<p>The header is currently supported only in Chromium, on the Android version of Chrome or via the Data Saver extension on a desktop device. Finally, you can also use the <a href="https://googlechrome.github.io/samples/network-information/">Network Information API</a> to deliver <a href="https://justmarkup.com/log/2017/11/network-based-image-loading/">low/high resolution images</a> and videos based on the network type</a>. Network Information API and specifically <code>navigator.connection.effectiveType</code> (Chrome 62+) use <code>RTT</code>, <code>downlink</code>, <code>effectiveType</code> values (and a few <a href="https://wicg.github.io/netinfo/">others</a>) to provide a representation of the connection and the data that users can handle.</p>

<p>In this context, Max Stoiber speaks of <a href="https://mxb.at/blog/connection-aware-components/">connection-aware components</a>. For example, with React, we could write a component that renders different elements for different connection types. As Max suggested, a <code>&lt;Media /&gt;</code> component in a news article might output:</p>

<ul>
  <li><code>Offline</code>: a placeholder with <code>alt</code> text,</li>
  <li><code>2G</code> / <code>save-data</code> mode: a low-resolution image,</li>
  <li><code>3G</code> on non-Retina screen: a mid-resolution image,</li>
  <li><code>3G</code> on Retina screens: high-res Retina image,</li>
  <li><code>4G</code>: an HD video.</li>
</ul>

<p>Dean Hume provides a <a href="https://deanhume.com/dynamic-resources-using-the-network-information-api-and-service-workers/">practical implementation of a similar logic</a> using a service worker. For a video, we could display a video poster by default, and then display the "Play" icon as well as the video player shell, meta-data of the video etc. on better connections. As a fallback for non-supporting browsers, we could <a href="https://benrobertson.io/front-end/lazy-load-connection-speed">listen to <code>canplaythrough</code> event</a> and use <code>Promise.race()</code> to timeout the source loading if the <code>canplaythrough</code> event doesn’t fire within 2 seconds.</p></li>

<li><strong>Consider making your components device memory-aware.</strong><br />Network connection gives us only one perspective at the context of the user though. Going further, you could also dynamically <a href="https://calendar.perfplanet.com/2018/dynamic-resources-browser-network-device-memory/">adjust resources based on available device memory</a>, with the <a href="https://developers.google.com/web/updates/2017/12/device-memory">Device Memory API</a> (Chrome 63+). <code>navigator.deviceMemory</code> returns how much RAM the device has in gigabytes, rounded down to the nearest power of two. The API also features a Client Hints Header, <code>Device-Memory</code>, that reports the same value.</p>
</li>
</ol>

{{< rimg breakout="true" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/34f6f27f-88a9-425a-910e-39100034def3/devtools-priority-segixq.gif" sizes="100vw" caption="The 'Priority' column in DevTools. Image credit: Ben Schwarz, <a href='https://css-tricks.com/the-critical-request/'>The Critical Request</a>" alt="The priority column in DevTools" >}}

<ol class="continue">
<li><strong>Warm up the connection to speed up delivery.</strong><br />Use <a href="https://w3c.github.io/resource-hints">resource hints</a> to save time on <a href="https://caniuse.com/#search=dns-prefetch"><code>dns-prefetch</code></a> (which performs a DNS lookup in the background), <a href="https://www.caniuse.com/#search=preconnect"><code>preconnect</code></a> (which asks the browser to start the connection handshake (DNS, TCP, TLS) in the background), <a href="https://caniuse.com/#search=prefetch"><code>prefetch</code></a> (which asks the browser to request a resource) and <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/"><code>preload</code></a> (which prefetches resources without executing them, among other things).

<p>Most of the time these days, we’ll be using at least <code>preconnect</code> and <code>dns-prefetch</code>, and we’ll be cautious with using <code>prefetch</code> and <code>preload</code>; the former should only be used if you are confident about what assets the user will need next (for example, in a purchasing funnel).

<p>Note that even with <code>preconnect</code> and <code>dns-prefetch</code>, the browser has a limit on the number of hosts it will look up/connect to in parallel, so it’s a safe bet to order them based on priority (<em>thanks Philip!</em>).</p>

<p>In fact, using resource hints is probably the easiest way to boost performance, and <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">it works well indeed</a>. When to use what? As Addy Osmani <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">has explained</a>, we should preload resources that we have high-confidence will be used in the current page. Prefetch resources likely to be used for future navigations across multiple navigation boundaries, e.g. Webpack bundles needed for pages the user hasn’t visited yet.</p>

<p>Addy’s article on <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">"Loading Priorities in Chrome"</a> shows how <em>exactly</em> Chrome interprets resource hints, so once you’ve decided which assets are critical for rendering, you can assign high priority to them. To see how your requests are prioritized, you can enable a "priority" column in the Chrome DevTools network request table (as well as Safari Technology Preview).</p>

<p>For example, since fonts usually are important assets on a page, it’s always a good idea to <a href="https://css-tricks.com/the-critical-request/#article-header-id-2">request the browser to download fonts with</a> <a href="https://css-tricks.com/the-critical-request/#article-header-id-2"><code>preload</code></a>. You could also <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/#dynamic-loading-without-execution">load JavaScript dynamically</a>, effectively lazy-loading execution. Also, since <code>&lt;link rel="preload"&gt;</code> accepts a <code>media</code> attribute, you could choose to <a href="https://css-tricks.com/the-critical-request/#article-header-id-3">selectively prioritize resources</a> based on <code>@media</code> query rules.</p>

<p>A few <a href="https://dexecure.com/blog/http2-push-vs-http-preload/">gotchas to keep in mind</a>: <code>preload</code> is good for <a href="https://www.youtube.com/watch?v=RWLzUnESylc">moving the start download time of an asset</a> closer to the initial request, but preloaded assets land in the memory cache which is tied to the page making the request. <code>preload</code> plays well with the HTTP cache: a network request is never sent if the item is already there in the HTTP cache.</p>

<p>Hence, it’s useful for late-discovered resources, a hero image loaded via background-image, inlining critical CSS (or JavaScript) and pre-loading the rest of the CSS (or JavaScript). Also, a <code>preload</code> tag can initiate a preload only after the browser has received the HTML from the server and the lookahead parser has found the <code>preload</code> tag.</p>

<p>Preloading via the HTTP header is a bit faster since we don’t to wait for the browser to parse the HTML to start the request. <a href="https://www.fastly.com/blog/faster-websites-early-priority-hints">Early Hints</a> will help even further, enabling preload to kick in even before the response headers for the HTML are sent and <a href="https://github.com/WICG/priority-hints">Priority Hints</a> (<a href="https://www.chromestatus.com/feature/5273474901737472">coming soon</a>) will help us indicate loading priorities for scripts.</p>

<p>Beware: if you’re using <code>preload</code>, <code>as</code> <strong>must</strong> be defined or <a href="https://twitter.com/yoavweiss/status/873077451143774209">nothing loads</a>, plus <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">preloaded fonts without the</a> <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf"><code>crossorigin</code></a> <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">attribute will double fetch</a>.</p>
</li>

<li><strong>Use service workers for caching and network fallbacks.</strong><br />No performance optimization over a network can be faster than a locally stored cache on a user’s machine. If your website is running over HTTPS, use the "<a href="https://github.com/lyzadanger/pragmatist-service-worker">Pragmatist’s Guide to Service Workers</a>" to cache static assets in a service worker cache and store offline fallbacks (or even offline pages) and retrieve them from the user’s machine, rather than going to the network. Also, check Jake’s <a href="https://jakearchibald.com/2014/offline-cookbook/">Offline Cookbook</a> and the free Udacity course "<a href="https://www.udacity.com/course/offline-web-applications--ud899">Offline Web Applications</a>."

<p>Browser support? As stated above, it’s <a href="https://caniuse.com/#search=serviceworker">widely supported</a> (Chrome, Firefox, Safari TP, Samsung Internet, Edge 17+) and the fallback is the network anyway. Does it help boost performance? <a href="https://developers.google.com/web/showcase/2016/service-worker-perf">Oh yes, it does</a>. And it’s getting better, e.g. with Background Fetch allowing background uploads/downloads from a service worker. <a href="https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/z5WX-2RMulo/JQqeF3XZAgAJ">Shipped in Chrome 71</a>.</p>

<p>There are a number of use cases for a service worker. For example, you could <a href="https://una.im/save-offline/#%F0%9F%92%81">implement "Save for offline" feature</a>, <a href="https://bitsofco.de/handling-broken-images-with-service-worker/">handle broken images</a>, introduce <a href="https://www.loxodrome.io/post/tab-state-service-workers/">messaging between tabs</a> or <a href="https://medium.com/dev-channel/service-worker-caching-strategies-based-on-request-types-57411dd7652c">provide different caching strategies based on request types</a>. In general, a common reliable strategy is to store the app shell in the service worker’s cache along with a few critical pages, such as offline page, frontpage and anything else that might be important in your case.</p>

<p>There are a few gotchas to keep in mind though. With a service worker in place, we need to <a href="https://philna.sh/blog/2018/10/23/service-workers-beware-safaris-range-request/">beware range requests in Safari</a> (if you are using Workbox for a service worker it has a <a href="https://developers.google.com/web/tools/workbox/modules/workbox-range-requests">range request module</a>). If you ever stumbled upon <code>DOMException: Quota exceeded.</code> error in the browser console, then look into Gerardo’s article <a href="https://cloudfour.com/thinks/when-7-kb-equals-7-mb/">When 7KB equals 7MB</a>.</p>

<p>As Gerardo writes, “If you are building a progressive web app and are experiencing bloated cache storage when your service worker caches static assets served from CDNs, make sure the <a href="https://cloudfour.com/thinks/when-7-kb-equals-7-mb/#opaque-responses">proper CORS response header exists</a> for cross-origin resources, you <a href="https://cloudfour.com/thinks/when-7-kb-equals-7-mb/#should-opaque-responses-be-cached-at-all">do not cache opaque responses</a> with your service worker unintentionally, you <a href="https://cloudfour.com/thinks/when-7-kb-equals-7-mb/#opt-in-to-cors-mode">opt-in cross-origin image assets into CORS mode</a> by adding the <code>crossorigin</code> attribute to the <code>&lt;img&gt;</code> tag.”</p>

<p>A good starting point for using service workers would be <a href="https://developers.google.com/web/tools/workbox/">Workbox</a>, a set of service worker libraries built specifically for building progressive web apps.</p></li>
<li><strong>Are you using service workers on the CDN/Edge, e.g. for A/B testing?</strong><br />At this point, we are quite used to running service workers on the client, but with <a href="https://blog.cloudflare.com/introducing-cloudflare-workers/">CDNs implementing them on the server</a>, we could use them to tweak performance on the edge as well.</p>

<p>For example, in A/B tests, when HTML needs to vary its content for different users, we could <a href="https://www.filamentgroup.com/lab/servers-workers.html">use Service Workers on the CDN servers</a> to handle the logic. We could also <a href="https://twitter.com/patmeenan/status/1065567680298663937">stream HTML rewriting</a> to speed up sites that use Google Fonts.</p></li>

<li><strong>Optimize rendering performance.</strong><br />Isolate expensive components with <a href="https://caniuse.com/#search=contain">CSS containment</a> &mdash; for example, to limit the scope of the browser’s styles, of layout and paint work for off-canvas navigation, or of third-party widgets. Make sure that there is no lag when scrolling the page or when an element is animated, and that you’re consistently hitting 60 frames per second. If that’s not possible, then at least making the frames per second consistent is preferable to a mixed range of 60 to 15. Use CSS’ <a href="https://caniuse.com/#feat=will-change"><code>will-change</code></a> to inform the browser of which elements and properties will change.

<p>Also, measure <a href="https://aerotwist.com/blog/my-performance-audit-workflow/#runtime-performance">runtime rendering performance</a> (for example, <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/">in DevTools</a>). To get started, check Paul Lewis’ free <a href="https://www.udacity.com/course/browser-rendering-optimization--ud860">Udacity course on browser-rendering optimization</a> and Georgy Marchuk’s article on <a href="https://css-tricks.com/browser-painting-and-considerations-for-web-performance/">Browser painting and considerations for web performance</a>.</p>

<p>If you want to dive deeper into the topic, Nolan Lawson has shared <a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/">tricks to accurately measure layout performance</a> in his article, and Jason Miller <a href="https://twitter.com/_developit/status/1081682550865752064">suggested alternative techniques, too</a>. We also have a lil' article by Sergey Chikuyonok on how to <a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">get GPU animation right</a>. Quick note: changes to GPU-composited layers are the <a href="https://blog.algolia.com/performant-web-animations/">least expensive</a>, so if you can get away by triggering only compositing via <code>opacity</code> and <code>transform</code>, you'll be on the right track. Anna Migas has provided a lot of practical advice in her talk on <a href="https://vimeo.com/302791098">Debugging UI Rendering Performance</a>, too.</p></li>

<li><strong>Have you optimized rendering experience?</strong><br />While the sequence of how components appear on the page, and the strategy of how we serve assets to the browser matter, we shouldn’t underestimate the role of <a href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/">perceived performance</a>, too. The concept deals with psychological aspects of waiting, basically keeping customers busy or engaged while something else is happening. That’s where <a href="https://www.smashingmagazine.com/2015/11/why-performance-matters-part-2-perception-management/">perception management</a>, <a href="https://www.smashingmagazine.com/2015/11/why-performance-matters-part-2-perception-management/#preemptive-start">preemptive start</a>, <a href="https://www.smashingmagazine.com/2015/11/why-performance-matters-part-2-perception-management/#early-completion">early completion</a> and <a href="https://www.smashingmagazine.com/2015/12/performance-matters-part-3-tolerance-management/">tolerance management</a> come into play.

<p>What does it all mean? While loading assets, we can try to always be one step ahead of the customer, so the experience feels swift while there is quite a lot happening in the background. To keep the customer engaged, we can test <a href="https://twitter.com/lukew/status/665288063195594752">skeleton screens</a> (<a href="https://twitter.com/razvancaliman/status/734088764960690176">implementation demo</a>) instead of loading indicators, add transitions/animations and basically <a href="https://blog.stephaniewalter.fr/en/cheating-ux-perceived-performance-and-user-experience/">cheat the UX</a> when there is nothing more to optimize. Beware though: skeleton screens should be tested before deploying as some <a href="https://www.viget.com/articles/a-bone-to-pick-with-skeleton-screens/">tests showed that skeleton screens can perform the worst</a> by all metrics.</p>
</li>
</ol>

## HTTP/2

<ol class="continue">
<li><strong>Migrate to HTTPS, then turn on HTTP/2.</strong><br />With Google <a href="https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html">moving towards a more secure web</a> and eventual treatment of all HTTP pages in Chrome as being "not secure," a switch to <a href="https://http2.github.io/faq/">HTTP/2 environment</a> is unavoidable. HTTP/2 is <a href="https://caniuse.com/#search=http2">supported very well</a>; it isn’t going anywhere; and, in most cases, you’re better off with it. Once running on HTTPS already, you can get a <a href="https://www.youtube.com/watch?v=RWLzUnESylc&amp;t=1s&amp;list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&amp;index=25">major performance boost</a> with service workers and server push (at least long term).

{{< rimg src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/30dd1821-9800-4f01-91a8-1375d4812144/http-pages-chrome-opt.png" sizes="100vw" caption="Eventually, Google plans to label all HTTP pages as non-secure, and change the HTTP security indicator to the red triangle that Chrome uses for broken HTTPS. (<a href='https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html'>Image source</a>)" alt="HTTP/2" >}}

<p>The most time-consuming task will be to <a href="https://https.cio.gov/faq/">migrate to HTTPS</a>, and depending on how large your HTTP/1.1 user base is (that is, users on legacy operating systems or with legacy browsers), you’ll have to send a different build for legacy browsers performance optimizations, which would require you to adapt to a <a href="https://rmurphey.com/blog/2015/11/25/building-for-http2">different build process</a>. Beware: Setting up both migration and a new build process might be tricky and time-consuming. For the rest of this article, I’ll assume that you’re either switching to or have already switched to HTTP/2.</p></li>

<li><strong>Properly deploy HTTP/2.</strong><br />Again, <a href="https://www.youtube.com/watch?v=yURLTwZ3ehk">serving assets over HTTP/2</a> requires a partial overhaul of how you’ve been serving assets so far. You’ll need to find a fine balance between packaging modules and loading many small modules in parallel. At the end of the day, still <a href="https://alistapart.com/article/the-best-request-is-no-request-revisited">the best request is no request</a>, however, the goal is to find a fine balance between quick first delivery of assets and caching.

<p>On the one hand, you might want to avoid concatenating assets altogether, instead breaking down your entire interface into many small modules, compressing them as a part of the build process, referencing them via the <a href="https://rmurphey.com/blog/2015/11/25/building-for-http2">"scout" approach</a> and loading them in parallel. A change in one file won’t require the entire style sheet or JavaScript to be re-downloaded. It also <a href="https://css-tricks.com/musings-on-http2-and-bundling/">minimizes parsing time</a> and keeps the payloads of individual pages low.</p>

<p>On the other hand, <a href="https://engineering.khanacademy.org/posts/js-packaging-http2.htm">packaging still matters</a>. First, <strong>compression will suffer</strong>. The compression of a large package will benefit from dictionary reuse, whereas small separate packages will not. There’s standard work to address that, but it’s far out for now. Secondly, browsers have <strong>not yet been optimized</strong> for such workflows. For example, Chrome will trigger <a href="https://www.chromium.org/developers/design-documents/inter-process-communication">inter-process communications</a> (IPCs) linear to the number of resources, so including hundreds of resources will have browser runtime costs.</p>

{{< rimg breakout="true" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24d7fcb0-40c3-4ada-abb3-22b8524f9b2d/progressive-css-loading-opt.png" sizes="100vw" caption="To achieve best results with HTTP/2, consider to <a href='https://jakearchibald.com/2016/link-in-body/'>load CSS progressively</a>, as suggested by Chrome’s Jake Archibald." alt="Progressive CSS loading" >}}

<p>Still, you can try to <a href="https://jakearchibald.com/2016/link-in-body/">load CSS progressively</a>. In fact, since Chrome 69, in-body CSS <a href="https://twitter.com/patmeenan/status/1037027969842208777">no longer blocks rendering for Chrome</a>. Obviously, by doing so, you are actively penalizing HTTP/1.1 users, so you might need to generate and serve different builds to different browsers as part of your deployment process, which is where things get slightly more complicated. You could get away with <a href="https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/">HTTP/2 connection coalescing</a>, which allows you to use domain sharding while benefiting from HTTP/2, but achieving this in practice is difficult, and in general, it’s not considered to be good practice.</p>

<p>What to do? Well, if you’re running over HTTP/2, sending around <strong>6–10 packages</strong> seems like a decent compromise (and isn’t too bad for legacy browsers). Experiment and measure to find the right balance for your website.</p></li>

<li><strong>Do your servers and CDNs support HTTP/2?</strong><br />Different servers and CDNs are probably going to support HTTP/2 differently. Use <a href="https://istlsfastyet.com">Is TLS Fast Yet?</a> to check your options, or quickly look up how your servers are performing and which features you can expect to be supported.

<p>Consult Pat Meenan’s incredible <a href="https://blog.cloudflare.com/http-2-prioritization-with-nginx/">research on HTTP/2 priorities</a> and <a href="https://github.com/pmeenan/http2priorities">test server support for HTTP/2 prioritization</a>. According to Pat, it’s recommended to enable BBR congestion control and set <code>tcp_notsent_lowat</code> to 16KB for HTTP/2 prioritization to work reliably on Linux 4.9 kernels and later (<em>thanks, Yoav!</em>). Andy Davies did a similar research for HTTP/2 prioritization across browsers, <a href="https://github.com/andydavies/http2-prioritization-issues#cdns--cloud-hosting-services">CDNs and Cloud Hosting Services</a>.</p></li>
</ol>

{{< rimg breakout="true" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c2102708-944d-46ed-93d9-fa28cd76f232/is-tls-fast-yet-01.png" sizes="100vw" caption="<a href='https://istlsfastyet.com'>Is TLS Fast Yet?</a> allows you to check your options for servers and CDNs when switching to HTTP/2. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c2102708-944d-46ed-93d9-fa28cd76f232/is-tls-fast-yet-01.png'>Large preview</a>)" alt="Is TLS Fast Yet?" >}}

<ol class="continue">
<li><strong>Is OCSP stapling enabled?</strong><br />By <a href="https://www.digicert.com/enabling-ocsp-stapling.htm">enabling OCSP stapling on your server</a>, you can speed up your TLS handshakes. The Online Certificate Status Protocol (OCSP) was created as an alternative to the Certificate Revocation List (CRL) protocol. Both protocols are used to check whether an SSL certificate has been revoked. However, the OCSP protocol does not require the browser to spend time downloading and then searching a list for certificate information, hence reducing the time required for a handshake.</li>

<li><strong>Have you adopted IPv6 yet?</strong><br />Because we’re <a href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion">running out of space with IPv4</a> and major mobile networks are adopting IPv6 rapidly (the US has <a href="https://www.google.com/intl/en/ipv6/statistics.html#tab=ipv6-adoption&amp;tab=ipv6-adoption">reached</a> a 50% IPv6 adoption threshold), it’s a good idea to <a href="https://www.paessler.com/blog/2016/04/08/monitoring-news/ask-the-expert-current-status-on-ipv6">update your DNS to IPv6</a> to stay bulletproof for the future. Just make sure that dual-stack support is provided across the network &mdash; it allows IPv6 and IPv4 to run simultaneously alongside each other. After all, IPv6 is not backwards-compatible. Also, <a href="https://www.cloudflare.com/ipv6/">studies show</a> that IPv6 made those websites 10 to 15% faster due to neighbor discovery (NDP) and route optimization.</li>

<li><strong>Is HPACK compression in use?</strong><br />If you’re using HTTP/2, double-check that your servers <a href="https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/">implement HPACK compression</a> for HTTP response headers to reduce unnecessary overhead. Because HTTP/2 servers are relatively new, they may not fully support the specification, with HPACK being an example. <a href="https://github.com/summerwind/h2spec">H2spec</a> is a great (if very technically detailed) tool to check that. HPACK’s compression algorithm is quite <a href="https://www.mnot.net/blog/2018/11/27/header_compression">impressive</a>, and <a href="https://www.keycdn.com/blog/http2-hpack-compression/">it works</a>.</li>

<li><strong>Make sure the security on your server is bulletproof.</strong><br />All browser implementations of HTTP/2 run over TLS, so you will probably want to avoid security warnings or some elements on your page not working. Double-check that your <a href="https://securityheaders.io/">security headers are set properly</a>, <a href="https://www.smashingmagazine.com/2016/01/eliminating-known-security-vulnerabilities-with-snyk/">eliminate known vulnerabilities</a>, and <a href="https://www.ssllabs.com/ssltest/">check your certificate</a>. Also, make sure that all external plugins and tracking scripts are loaded via HTTPS, that cross-site scripting isn’t possible and that both <a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet">HTTP Strict Transport Security headers</a> and <a href="https://content-security-policy.com/">Content Security Policy headers</a> are properly set.</li>
</ol>

## Testing And Monitoring

<ol class="continue">
<li><strong>Have you optimized your auditing workflow?</strong><br />It might not sound like a big deal, but having the right settings in place at your fingertips might save you quite a bit of time in testing. Consider using Tim Kadlec’s <a href="https://github.com/tkadlec/webpagetest-alfred-workflow">Alfred Workflow for WebPageTest</a> for submitting a test to the public instance of WebPageTest.

<p>You could also <a href="https://calendar.perfplanet.com/2014/driving-webpagetest-from-a-google-docs-spreadsheet/">drive WebPageTest from a Google Spreadsheet</a> and <a href="https://web.dev/fast/using-lighthouse-ci-to-set-a-performance-budget">incorporate accessibility, performance and SEO scores</a> into your Travis setup with Lighthouse CI or <a href="https://twitter.com/addyosmani/statuses/1017655423099289600">straight into Webpack</a>.</p>

<p>And if you need to debug something quickly but your build process seems to be remarkably slow, keep in mind that "<a href="https://slack.engineering/keep-webpack-fast-a-field-guide-for-better-build-performance-f56a5995e8f1">whitespace removal and symbol mangling accounts for 95% of the size reduction</a> in minified code for most JavaScript &mdash; not elaborate code transforms. You can simply disable compression to speed up Uglify builds by 3 to 4 times."</p></li>
</ol>

{{< rimg breakout="true" href="https://cdn-images-1.medium.com/max/1600/1*Y-1sdlIzFBRfEQPprzLnbA.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/705ed9b1-cd4d-4231-b808-ce8c2e72e070/review-required-checks-pr.png" sizes="100vw" caption="Integrating <a href='https://web.dev/fast/using-lighthouse-ci-to-set-a-performance-budget'>accessibility, performance and SEO scores</a> into your Travis setup with Lighthouse CI will highlight the performance impact of a new feature to all contributing developers. (<a href='https://cdn-images-1.medium.com/max/1600/1*Y-1sdlIzFBRfEQPprzLnbA.png'>Image source</a>) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/705ed9b1-cd4d-4231-b808-ce8c2e72e070/review-required-checks-pr.png'>Large preview</a>)" alt="pull request checks review required" >}}

<ol class="continue">
<li><strong>Have you tested in proxy browsers and legacy browsers?</strong><br />Testing in Chrome and Firefox is not enough. Look into how your website works in proxy browsers and legacy browsers. UC Browser and Opera Mini, for instance, have a <a href="https://gs.statcounter.com/#mobile_browser-as-monthly-201511-201611">significant market share in Asia</a> (up to 35% in Asia). <a href="https://www.webworldwide.io/">Measure average Internet speed</a> in your countries of interest to avoid big surprises down the road. Test with network throttling, and emulate a high-DPI device. <a href="https://www.browserstack.com">BrowserStack</a> is fantastic, but test on real devices as well.</li>
</ol>

<figure><a href="https://github.com/loadimpact/k6"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/96fa3207-4fff-4b7b-bfa0-c115062d826a/demo-unit-perf-tests.gif" /></a><figcaption><a href="https://github.com/loadimpact/k6">k6</a> allows you write unit tests-alike performance tests.</figcaption>
</figure>

<ol class="continue">
<li><strong>Have you tested the accessibility performance?</strong><br />When the browser starts to load a page, it builds a DOM, and if there is an assistive technology like a screen reader running, it also creates an accessibility tree. The screen reader then has to query the accessibility tree to retrieve the information and make it available to the user &mdash; sometimes by default, and sometimes on demand. And sometimes it takes time.

<p>When talking about fast Time to Interactive, usually we mean an indicator of how <em>soon</em> a user can interact with the page by clicking or tapping on links and buttons. The context is slightly different with screen readers. In that case, fast Time to Interactive means how much <em>time</em> passes by until the screen reader can announce navigation on a given page and a screen reader user can actually hit keyboard to interact.</p>
<p>Léonie Watson has given an <a href="https://www.youtube.com/watch?v=n1sXj9oAXFU">eye-opening talk on accessibility performance</a> and specifically the impact slow loading has on screen reader announcement delays. Screen readers are used to fast-paced announcements and quick navigation, and therefore might potentially be even less patient than sighted users.</p>
<p>Large pages and DOM manipulations with JavaScript will cause delays in screen reader announcements. A rather unexplored area that could use some attention and testing as screen readers are available on literally every platform (Jaws, NVDA, Voiceover, Narrator, Orca).</p></li>
<li><strong>Is continuous monitoring set up?</strong><br />Having a private instance of <a href="https://www.webpagetest.org/">WebPagetest</a> is always beneficial for quick and unlimited tests. However, a continuous monitoring tool &mdash; like <a href="https://www.sitespeed.io/">Sitespeed</a>, <a href="https://calibreapp.com/">Calibre</a> and <a href="https://speedcurve.com/">SpeedCurve</a> &mdash; with automatic alerts will give you a more detailed picture of your performance. Set your own user-timing marks to measure and monitor business-specific metrics. Also, consider adding <a href="https://calendar.perfplanet.com/2017/automating-web-performance-regression-alerts/">automated performance regression alerts</a> to monitor changes over time.</p>
<p>Look into using RUM-solutions to monitor changes in performance over time. For automated unit-test-alike load testing tools, you can use <a href="https://github.com/loadimpact/k6">k6</a> with its scripting API. Also, look into <a href="https://speedtracker.org">SpeedTracker</a>, <a href="https://github.com/GoogleChrome/lighthouse">Lighthouse</a> and <a href="https://calibreapp.com">Calibre</a>.</p></li>
</ol>

## Quick Wins

<p>This list is quite comprehensive, and completing all of the optimizations might take quite a while. So, if you had just 1 hour to get significant improvements, what would you do? Let’s boil it all down to <strong>12 low-hanging fruits</strong>. Obviously, before you start and once you finish, measure results, including start rendering time and Speed Index on a 3G and cable connection.</p>

<ol>
  <li>Measure the real world experience and set appropriate goals. A good goal to aim for is First Meaningful Paint &lt; 1 s, a Speed Index value &lt; 1250, Time to Interactive &lt; 5s on slow 3G, for repeat visits, TTI &lt; 2s. Optimize for start rendering time and time-to-interactive.</li>
  <li>Prepare critical CSS for your main templates, and include it in the <code>&lt;head&gt;</code> of the page. (Your budget is 14 KB). For CSS/JS, operate within a critical file size <a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/">budget of max. 170KB gzipped</a> (0.7MB decompressed).</li>
  <li>Trim, optimize, defer and lazy-load as many scripts as possible, check lightweight alternatives and limit the impact of third-party scripts.</li>
  <li>Serve legacy code only to legacy browsers with <code>&lt;script type="module"&gt;</code>.</li>
  <li>Experiment with regrouping your CSS rules and test in-body CSS.</li>
  <li>Add resource hints to speed up delivery with faster <code>dns-lookup</code>, <code>preconnect</code>, <code>prefetch</code> and <code>preload</code>.</li>
  <li>Subset web fonts and load them asynchronously, and utilize <code>font-display</code> in CSS for fast first rendering.</li>
  <li>Optimize images, and consider using WebP for critical pages (such as landing pages).</li>
  <li>Check that HTTP cache headers and security headers are set properly.</li>
  <li>Enable Brotli or Zopfli compression on the server. (If that’s not possible, don’t forget to enable Gzip compression.)</li>
  <li>If HTTP/2 is available, enable HPACK compression and start monitoring mixed-content warnings. Enable OCSP stapling.</li>
  <li>Cache assets such as fonts, styles, JavaScript and images in a service worker cache.</li>
</ol>

## Download The Checklist (PDF, Apple Pages)

<p>With this checklist in mind, you should be prepared for any kind of front-end performance project. Feel free to download the print-ready PDF of the checklist as well as an <strong>editable Apple Pages document</strong> to customize the checklist for your needs:</p>

<ul>
<li><a href="https://www.dropbox.com/s/21vof23jlwf0swc/performance-checklist-1.2.pdf?dl=0">Download the checklist PDF</a> (PDF, 166 KB)</li>
<li><a href="https://www.dropbox.com/s/xyf5qjnp1ii5okm/performance-checklist-1.2.pages?dl=0">Download the checklist in Apple Pages</a> (.pages, 275 KB)</li>
<li><a href="https://www.dropbox.com/s/76b3yzexqdwsg65/performance-checklist-1.2.docx?dl=0">Download the checklist in MS Word</a> (.docx, 151 KB)</li>
</ul>

<p>If you need alternatives, you can also check the <a href="https://github.com/drublic/checklist">front-end checklist by Dan Rublic</a>, the "<a href="https://jonyablonski.com/designers-wpo-checklist/">Designer’s Web Performance Checklist</a>" by Jon Yablonski and the <a href="https://github.com/thedaviddias/Front-End-Performance-Checklist">FrontendChecklist</a>.</p>

## Off We Go!

<p>Some of the optimizations might be beyond the scope of your work or budget or might just be overkill given the legacy code you have to deal with. That’s fine! Use this checklist as a general (and hopefully comprehensive) guide, and create your own list of issues that apply to your context. But most importantly, test and measure your own projects to identify issues before optimizing. Happy performance results in 2019, everyone!</p>

<hr />

<p><em>A huge thanks to Guy Podjarny, Yoav Weiss, Addy Osmani, Artem Denysov, Denys Mishunov, Ilya Pukhalski, Jeremy Wagner, Colin Bendell, Mark Zeman, Patrick Meenan, Leonardo Losoviz, Andy Davies, Rachel Andrew, Anselm Hannemann, Patrick Hamann, Andy Davies, Tim Kadlec, Rey Bango, Matthias Ott, Peter Bowyer, Phil Walton, Mariana Peralta, Philipp Tellis, Ryan Townsend, Ingrid Bergman, Mohamed Hussain S. H., Jacob Groß, Tim Swalling, Bob Visser, Kev Adamson, Adir Amsalem, Aleksey Kulikov and Rodney Rehm for reviewing this article, as well as our fantastic community which has shared techniques and lessons learned from its work in performance optimization for everybody to use. You are truly smashing!</em></p>

{{< signature "ra, il" >}}