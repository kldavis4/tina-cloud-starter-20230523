---
title: 'How To Build A Progressively Enhanced, Accessible, Filterable And Paginated List'
slug: accessible-filterable-paginated-list-11ty-alpinejs
author: manuelmatuzovic
image: >-
  https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/247c8c69-4797-4922-9c3b-75cfa3362051/accessible-filterable-paginated-list-11ty-alpinejs.jpg
date: 2022-04-04T10:00:00.000Z
summary: >-
   Ever wondered how to build a paginated list that works with and without JavaScript? In this article, Manuel explains how you can leverage the power of Progressive Enhancement and do just that with Eleventy and Alpine.js.
description: >-
  Ever wondered how to build a paginated list that works with and without JavaScript? In this article, Manuel explains how you can leverage the power of Progressive Enhancement and do just that with Eleventy and Alpine.js.
categories:
  - Tools
  - JavaScript
  - Accessibility
---

Most sites I build are static sites with HTML files generated by a static site generator or pages served on a server by a CMS like [Wordpress](https://wordpress.com/) or [CraftCMS](https://craftcms.com/). I use JavaScript only on top to enhance the user experience. I use it for things like disclosure widgets, accordions, fly-out navigations, or modals.

The requirements for most of these features are simple, so using a library or framework would be overkill. Recently, however, I found myself in a situation where writing a component from scratch in Vanilla JS without the help of a framework would’ve been too complicated and messy.

## Lightweight Frameworks

My task was to add multiple filters, sorting and pagination to an existing list of items. I didn’t want to use a JavaScript Framework like Vue or React, only because I needed help in some places on my site, and I didn’t want to change my stack. [I consulted Twitter](https://twitter.com/mmatuzo/status/1483739260092100609), and people suggested minimal frameworks like [lit](https://lit.dev/), [petite-vue](https://github.com/vuejs/petite-vue), [hyperscript](https://hyperscript.org/), [htmx](https://htmx.org/) or [Alpine.js](https://alpinejs.dev/). I went with Alpine because it sounded like it was exactly what I was looking for:

<blockquote>“Alpine is a rugged, minimal tool for composing behavior directly in your markup. Think of it like jQuery for the modern web. Plop in a script tag and get going.”</blockquote>

## Alpine.js

Alpine is a lightweight (&#126;7KB) collection of 15 attributes, 6 properties, and 2 methods. I won’t go into the basics of it (check out this [article about Alpine](https://css-tricks.com/alpine-js-the-javascript-framework-thats-used-like-jquery-written-like-vue-and-inspired-by-tailwindcss/) by [Hugo Di Francesco](https://codewithhugo.com/) or read the [Alpine docs](https://alpinejs.dev/start-here)), but let me quickly introduce you to Alpine:

<strong>Note:</strong> <em>You can skip this intro and go straight to the <a href="#static-paginated-list">main content of the article</a> if you’re already familiar with Alpine.js.</em>

Let’s say we want to turn a simple list with many items into a [disclosure widget](https://www.w3.org/TR/wai-aria-practices-1.2/#disclosure). You could use the native HTML elements: [details and summary](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details) for that, but for this exercise, I’ll use Alpine. 

By default, with JavaScript disabled, we show the list, but we want to hide it and allow users to open and close it by pressing a button if JavaScript is enabled:

<pre><code class="language-html">&lt;h2&gt;Beastie Boys Anthology&lt;/h2&gt;
&lt;p&gt;The Sounds of Science is the first anthology album by American rap rock group Beastie Boys composed of greatest hits, B-sides, and previously unreleased tracks.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Beastie Boys&lt;/li&gt;
  &lt;li&gt;Slow And Low&lt;/li&gt;
  &lt;li&gt;Shake Your Rump&lt;/li&gt;
  &lt;li&gt;Gratitude&lt;/li&gt;
  &lt;li&gt;Skills To Pay The Bills&lt;/li&gt;
  &lt;li&gt;Root Down&lt;/li&gt;
  &lt;li&gt;Believe Me&lt;/li&gt;
  …
&lt;/ol&gt;</code></pre>

First, we include Alpine using a `script` tag. Then we wrap the list in a `div` and use the `x-data` directive to pass data into the component. The `open` property inside the object we passed is available to all children of the `div`:

<pre><code class="language-html">&lt;div x-data="{ open: false }"&gt;
  &lt;ol&gt;
    &lt;li&gt;Beastie Boys&lt;/li&gt;
    &lt;li&gt;Slow And Low&lt;/li&gt;
    …
  &lt;/ol&gt;
&lt;/div&gt;

&lt;script src="https://unpkg.com/alpinejs@3.9.1/dist/cdn.min.js" integrity="sha384-mDHH3kdyMS0F6QcfHCxEgPMMjssTurzucc7Jct3g1GOfB4p7PxJuugPP1NOLvE7I" crossorigin="anonymous"&gt;&lt;/script&gt;</code></pre>

We can use the `open` property for the `x-show` directive, which determines whether or not an element is visible:

<pre><code class="language-html">&lt;div x-data="{ open: false }"&gt;
  &lt;ol x-show="open"&gt;
    &lt;li&gt;Beastie Boys&lt;/li&gt;
    &lt;li&gt;Slow And Low&lt;/li&gt;
    …
  &lt;/ol&gt;
&lt;/div&gt;</code></pre>

Since we set `open` to `false`, the list is hidden now. 

Next, we need a button that toggles the value of the `open` property. We can add events by using the `x-on:click` directive or the shorter @-Syntax `@click`:

<pre><code class="language-html">&lt;div x-data="{ open: false }"&gt;
  &lt;button @click="open = !open"&gt;Tracklist&lt;/button&gt;
  
  &lt;ol x-show="open"&gt;
    &lt;li&gt;Beastie Boys&lt;/li&gt;
    &lt;li&gt;Slow And Low&lt;/li&gt;
    …
  &lt;/ol&gt;
&lt;/div&gt;</code></pre>

Pressing the button, `open` now switches between `false` and `true` and `x-show` reactively watches these changes, showing and hiding the list accordingly.

While this works for keyboard and mouse users, it’s useless to screen reader users, as we need to communicate the state of our widget. We can do that by toggling the value of the `aria-expanded` attribute:

<pre><code class="language-html">&lt;button @click="open = !open" :aria-expanded="open"&gt;
  Tracklist
&lt;/button&gt;</code></pre>

We can also create a semantic connection between the button and the list using `aria-controls` for [screen readers that support the attribute](https://a11ysupport.io/tech/aria/aria-controls_attribute):

<pre><code class="language-html">&lt;button @click="open = ! open" :aria-expanded="open" aria-controls="tracklist"&gt;
  Tracklist
&lt;/button&gt;
&lt;ol x-show="open" id="tracklist"&gt;
  …
&lt;/ol&gt;</code></pre>

Here’s the final result:

{{< codepen height="480" theme_id="light" slug_hash="xxpdzNz" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Simple disclosure widget with Alpine.js](https://codepen.io/smashingmag/pen/xxpdzNz) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}} 

Pretty neat! You can enhance existing static content with JavaScript without having to write a single line of JS. Of course, you may need to write some JavaScript, especially if you’re working on more complex components.

<h3 id="static-paginated-list">A Static, Paginated List</h3>

Okay, now that we know the basics of Alpine.js, I’d say it’s time to build a more complex component.

<blockquote><strong>Note</strong>: You can <a href="https://sad-kare-e07051.netlify.app/index_js/">take a look at the final result</a> before we get started.</blockquote>

I want to build a paginated list of my vinyl records that works without JavaScript. We’ll use the static site generator [eleventy (or short “11ty”)](https://www.11ty.dev) for that and Alpine.js to enhance it by making the list filterable.

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d87b905e-1190-4a40-80d1-4947c3185aa7/1-accessible-filterable-paginated-list-11ty-alpinejs.jpg" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d87b905e-1190-4a40-80d1-4947c3185aa7/1-accessible-filterable-paginated-list-11ty-alpinejs.jpg" width="800" height="600" sizes="100vw" caption="Anyone else here also a fan of vinyl records? ;-) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d87b905e-1190-4a40-80d1-4947c3185aa7/1-accessible-filterable-paginated-list-11ty-alpinejs.jpg'>Large preview</a>)" alt="A picture with vinyls standing in a row" >}}

### Setup

Before we get started, let’s set up our site. We need:

- a project folder for our site,
- 11ty to generate HTML files,
- an input file for our HTML,
- a data file that contains the list of records.

On your command line, navigate to the folder where you want to save the project, create a folder, and `cd` into it:

<pre><code class="language-bash">cd Sites # or wherever you want to save the project
mkdir myrecordcollection # pick any name
cd myrecordcollection</code></pre>

Then create a `package.json` file and [install eleventy](https://www.11ty.dev/docs/getting-started/):

<pre><code class="language-bash">npm init -y
npm install @11ty/eleventy</code></pre>

Next, create an `index.njk` file (`.njk` means this is a Nunjucks file; more about that below) and a folder `_data` with a `records.json`:

<pre><code class="language-bash">touch index.njk
mkdir _data
touch _data/records.json</code></pre>

You don’t have to do all these steps on the command line. You can also create folders and files in any user interface. The final file and folder structure looks like this:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8e3c1fe3-0614-4b3f-9c1e-90d7f12dc607/5-accessible-filterable-paginated-list-11ty-alpinejs.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8e3c1fe3-0614-4b3f-9c1e-90d7f12dc607/5-accessible-filterable-paginated-list-11ty-alpinejs.png" width="800" height="361" sizes="100vw" caption="(<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8e3c1fe3-0614-4b3f-9c1e-90d7f12dc607/5-accessible-filterable-paginated-list-11ty-alpinejs.png'>Large preview</a>)" alt="A screenshot of the final file and the folder structure" >}}

### Adding Content

11ty allows you to write content directly into an HTML file (or Markdown, Nunjucks, and [other template languages](https://www.11ty.dev/docs/languages/)). You can even store data in the [front matter](https://www.11ty.dev/docs/data-frontmatter/) or in a JSON file. I don’t want to manage hundreds of entries manually, so I’ll store them in the JSON file we just created. Let’s add some data to the file:

<pre><code class="language-javascript">[
  {
    "artist": "Akne Kid Joe",
    "title": "Die große Palmöllüge",
    "year": 2020
  },
  {
    "artist": "Bring me the Horizon",
    "title": "Post Human: Survial Horror",
    "year": 2020
  },
  {
    "artist": "Idles",
    "title": "Joy as an Act of Resistance",
    "year": 2018
  },
  {
    "artist": "Beastie Boys",
    "title": "Licensed to Ill",
    "year": 1986
  },
  {
    "artist": "Beastie Boys",
    "title": "Paul's Boutique",
    "year": 1989
  },
  {
    "artist": "Beastie Boys",
    "title": "Check Your Head",
    "year": 1992
  },
  {
    "artist": "Beastie Boys",
    "title": "Ill Communication",
    "year": 1994
  }
]</code></pre>

Finally, let’s add a basic HTML structure to the `index.njk` file and start eleventy:

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    
  &lt;title&gt;My Record Collection&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;My Record Collection&lt;/h1&gt;
    
&lt;/body&gt;
&lt;/html&gt;</code></pre>

By running the following command you should be able to access the site at `http://localhost:8080`:

<pre><code class="language-bash">eleventy --serve</code></pre>

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2c44ab0d-330a-4228-8f5d-62908ed7b3f1/2-accessible-filterable-paginated-list-11ty-alpinejs.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2c44ab0d-330a-4228-8f5d-62908ed7b3f1/2-accessible-filterable-paginated-list-11ty-alpinejs.png" width="800" height="396" sizes="100vw" caption="Eleventy running on port <code>:8080</code>. The site just shows the heading ‘My Record Collection’. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2c44ab0d-330a-4228-8f5d-62908ed7b3f1/2-accessible-filterable-paginated-list-11ty-alpinejs.png'>Large preview</a>)" alt="A screenshot where the site showing the heading ‘My Record Collection" >}}

### Displaying Content

Now let’s take the data from our JSON file and turn it into HTML. We can access it by looping over the `records` object in nunjucks:

<pre><code class="language-html">&lt;div class="collection"&gt;
  &lt;ol&gt;
    {% for record in records %}
    &lt;li&gt;
      &lt;strong&gt;{{ record.title }}&lt;/strong&gt;&lt;br&gt;
      Released in &lt;time datetime="{{ record.year }}"&gt;{{ record.year }}&lt;/time&gt; by {{ record.artist }}.
    &lt;/li&gt;
    {% endfor %}
  &lt;/ol&gt;
&lt;/div&gt;</code></pre>

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2995f1e8-2aab-4cc9-9707-b4f6a363008d/3-accessible-filterable-paginated-list-11ty-alpinejs.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2995f1e8-2aab-4cc9-9707-b4f6a363008d/3-accessible-filterable-paginated-list-11ty-alpinejs.png" width="800" height="577" sizes="100vw" caption="7 Records listed, each with their title, artist and release date. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2995f1e8-2aab-4cc9-9707-b4f6a363008d/3-accessible-filterable-paginated-list-11ty-alpinejs.png'>Large preview</a>)" alt="A screenshot with 7 Records listed, each with their title, artist and release date" >}}

### Pagination

Eleventy supports pagination out of the box. All we have to do is add a frontmatter block to our page, tell 11ty which dataset it should use for pagination, and finally, we have to adapt our `for` loop to use the paginated list instead of all records:

<pre><code class="language-html">---
pagination:
  data: records
  size: 5
---
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
      
    &lt;title&gt;My Record Collection&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;My Record Collection&lt;/h1&gt;
  
    &lt;div class="collection"&gt;
      &lt;p id="message"&gt;Showing &lt;output&gt;{{ records.length }} records&lt;/output&gt;&lt;/p&gt;
      
      &lt;div aria-labelledby="message" role="region"&gt;
        &lt;ol class="records"&gt;
          {% for record in pagination.items %}
          &lt;li&gt;
            &lt;strong&gt;{{ record.title }}&lt;/strong&gt;&lt;br&gt;
            Released in &lt;time datetime="{{ record.year }}"&gt;{{ record.year }}&lt;/time&gt; by {{ record.artist }}.
          &lt;/li&gt;
          {% endfor %}
        &lt;/ol&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

If you access the page again, the list only contains 5 items. You can also see that I’ve added a status message (ignore the `output` element for now), wrapped the list in a `div` with the `role` “region”, and that I’ve labelled it by creating a reference to `#message` using `aria-labelledby`. I did that to turn it into a [landmark](https://www.htmhell.dev/tips/landmarks/) and allow screen reader users to access the list of results directly using keyboard shortcuts.

Next, we’ll add a navigation with links to all pages created by the static site generator. The `pagination` object holds an `array` that contains all pages. We use `aria-current="page"` to highlight the current page:

<pre><code class="language-html">&lt;nav aria-label="Select a page"&gt;
  &lt;ol class="pages"&gt;
    {% for page_entry in pagination.pages %}
      {%- set page_url = pagination.hrefs[loop.index0] -%}
      &lt;li&gt;
        &lt;a href="{{ page_url }}"{% if page.url == page_url %} aria-current="page"{% endif %}&gt;
          Page {{ loop.index }}
        &lt;/a&gt;
      &lt;/li&gt;
    {% endfor %}
  &lt;/ol&gt;
&lt;/nav&gt;</code></pre>

Finally, let’s add some basic CSS to improve the styling:

<pre><code class="language-css">body {
  font-family: sans-serif;
  line-height: 1.5;
}

ol {
  list-style: none;
  margin: 0;
  padding: 0;
}

.records > &#42; + &#42; {
  margin-top: 2rem;
}

h2 {
  margin-bottom: 0;
}

nav {
  margin-top: 1.5rem;
}

.pages {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.pages a {
  border: 1px solid #000000;
  padding: 0.5rem;
  border-radius: 5px;
  display: flex;
  text-decoration: none;
}

.pages a:where([aria-current]) {
  background-color: #000000;
  color: #ffffff;
}

.pages a:where(:focus, :hover) {
  background-color: #6c6c6c;
  color: #ffffff;
}</code></pre>

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/86b4494b-c550-42b3-8db3-792d24049008/4-accessible-filterable-paginated-list-11ty-alpinejs.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/86b4494b-c550-42b3-8db3-792d24049008/4-accessible-filterable-paginated-list-11ty-alpinejs.png" width="800" height="577" sizes="100vw" caption="(<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/86b4494b-c550-42b3-8db3-792d24049008/4-accessible-filterable-paginated-list-11ty-alpinejs.png'>Large preview</a>)" alt="A screenshot with 7 Records listed, each with their title, artist and release date, with links to all pages and a highlighted current page" >}}

You can see it in action in the [live demo](https://sad-kare-e07051.netlify.app/) and you can check out the [code on GitHub](https://github.com/matuzo/articles/tree/main/11ty-alpine).

This works fairly well with 7 records. It might even work with 10, 20, or 50, but I have over 400 records. We can make browsing the list easier by adding filters.

{{% feature-panel %}}

## A Dynamic Paginated And Filterable List

I like JavaScript, but I also believe that the core content and functionality of a website should be accessible without it. This doesn’t mean that you can’t use JavaScript at all, it just means that you start with a basic server-rendered foundation of your component or site, and you add functionality layer by layer. This is called [progressive enhancement](https://briefs.video/videos/is-progressive-enhancement-dead-yet/).

Our foundation in this example is the static list created with 11ty, and now we add a layer of functionality with Alpine. 

First, right before the closing `body` tag, we reference the latest version (as of writing 3.9.1) of Alpine.js:

<pre><code class="language-html"> &lt;script src="https://unpkg.com/alpinejs@3.9.1/dist/cdn.min.js" integrity="sha384-mDHH3kdyMS0F6QcfHCxEgPMMjssTurzucc7Jct3g1GOfB4p7PxJuugPP1NOLvE7I" crossorigin="anonymous"&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>

**Note:** *Be careful using a third-party CDN, this can have all kinds of negative implications (performance, privacy, security). Consider referencing the file locally or [importing it as a module](https://alpinejs.dev/essentials/installation#as-a-module).  
In case you’re wondering why you don’t see the [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) hash in the official docs, it’s because I’ve created and added it manually.*

Since we’re moving into JavaScript-world, we need to make our records available to Alpine.js. Probably not the best, but the quickest solution is to create a `.eleventy.js` file in your root folder and add the following lines:

<pre><code class="language-css">module.exports = function(eleventyConfig) {
    eleventyConfig.addPassthroughCopy("_data");
};</code></pre>

This ensures that eleventy doesn’t just generate HTML files, but it also copies the contents of the `_data` folder into our destination folder, making it accessible to our scripts.

### Fetching Data

Just like in the previous example, we’ll add the `x-data` directive to our component to pass data:

<pre><code class="language-html">&lt;div class="collection" x-data="{ records: [] }"&gt;
&lt;/div&gt;</code></pre>

We don’t have any data, so we need to fetch it as the component initialises. The `x-init` directive allows us to hook into the initialisation phase of any element and perform tasks:

<pre><code class="language-html">&lt;div class="collection" x-init="records = await (await fetch('/_data/records.json')).json()" x-data="{ records: [] }"&gt;
  &lt;div x-text="records"&gt;&lt;/div&gt;
  […]
&lt;/div&gt;</code></pre>

If we output the results directly, we see a list of `[object Object]`s, because we’re fetching and receiving an `array`. Instead, we should iterate over the list using the `x-for` directive on a `template` tag and output the data using `x-text`:

<pre><code class="language-html">&lt;template x-for="record in records"&gt;
  &lt;li&gt;
    &lt;strong x-text="record.title"&gt;&lt;/strong&gt;&lt;br&gt;
    Released in &lt;time :datetime="record.year" x-text="record.year"&gt;&lt;/time&gt; by &lt;span x-text="record.artist"&gt;&lt;/span&gt;.
  &lt;/li&gt;
&lt;/template&gt;</code></pre>

<blockquote>The <code>&lt;template&gt;</code> HTML element is a mechanism for holding HTML that is not to be rendered immediately when a page is loaded but may be instantiated subsequently during runtime using JavaScript.<br /><br /><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template">MDN: <code>&lt;template&gt;</code>: The Content Template Element</a></blockquote>

Here’s how the whole list looks like now:

<pre><code class="language-html">&lt;div class="collection" x-init="records = await (await fetch('/_data/records.json')).json()" x-data="{ records: [] }"&gt;
  &lt;p id="message"&gt;Showing &lt;output&gt;{{ records.length }} records&lt;/output&gt;&lt;/p&gt;
  
  &lt;div aria-labelledby="message" role="region"&gt;
    &lt;ol class="records"&gt;  
      &lt;template x-for="record in records"&gt;
        &lt;li&gt;
          &lt;strong x-text="record.title"&gt;&lt;/strong&gt;&lt;br&gt;
          Released in &lt;time :datetime="record.year" x-text="record.year"&gt;&lt;/time&gt; by &lt;span x-text="record.artist"&gt;&lt;/span&gt;.
        &lt;/li&gt;
      &lt;/template&gt;
      
      {%- for record in pagination.items %}
        &lt;li&gt;
          &lt;strong&gt;{{ record.title }}&lt;/strong&gt;&lt;br&gt;
          Released in &lt;time datetime="{{ record.year }}"&gt;{{ record.year }}&lt;/time&gt; by {{ record.artist }}.
        &lt;/li&gt;
      {%- endfor %}
    &lt;/ol&gt;
  &lt;/div&gt;
  […]
&lt;/div&gt;</code></pre>

Isn’t it amazing how quickly we were able to fetch and output data? Check out the demo below to see how Alpine populates the list with results.

{{% ad-panel-leaderboard %}}

**Hint:** *You don’t see any Nunjucks code in this CodePen, because 11ty doesn’t run in the browser. I’ve just copied and pasted the rendered HTML of the first page.*

{{< codepen height="480" theme_id="light" slug_hash="abEWRMY" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 1](https://codepen.io/smashingmag/pen/abEWRMY) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}
  
You can achieve a lot by using Alpine’s directives, but at some point relying only on attributes can get messy. That’s why I’ve decided to move the data and some of the logic into a separate Alpine component object. 

Here’s how that works: Instead of passing data directly, we now reference a component using `x-data`. The rest is pretty much identical: Define a variable to hold our data, then fetch our JSON file in the initialization phase. However, we don’t do that inside an attribute, but inside a `script` tag or file instead:

<pre><code class="language-javascript">&lt;div class="collection" x-data="collection"&gt;
  […]
&lt;/div&gt;

[…]

&lt;script&gt;
  document.addEventListener('alpine:init', () =&gt; {
    Alpine.data('collection', () =&gt; ({
      records: [],
      async getRecords() {
        this.records = await (await fetch('/&#95;data/records.json')).json();
      },
      init() {
        this.getRecords();
      }
    }))
  })
&lt;/script&gt;

&lt;script src="https://unpkg.com/alpinejs@3.9.1/dist/cdn.min.js" integrity="sha384-mDHH3kdyMS0F6QcfHCxEgPMMjssTurzucc7Jct3g1GOfB4p7PxJuugPP1NOLvE7I" crossorigin="anonymous"&gt;&lt;/script&gt;</code></pre>

Looking at the previous CodePen, you’ve probably noticed that we now have a duplicate set of data. That’s because our static 11ty list is still there. Alpine has a directive that tells it to ignore certain DOM elements. I don’t know if this is actually necessary here, but it’s a nice way of marking these *unwanted* elements. So, we add the `x-ignore` directive on our 11ty list items, and we add a class to the `html` element when the data has loaded and then use the class and the attribute to hide those list items in CSS:

<pre><code class="language-javascript">&lt;style&gt;
  .alpine [x-ignore] {
    display: none;
  }
&lt;/style&gt;

[…]
{%- for record in pagination.items %}
  &lt;li x-ignore&gt;
    &lt;strong&gt;{{ record.title }}&lt;/strong&gt;&lt;br&gt;
    Released in &lt;time datetime="{{ record.year }}"&gt;{{ record.year }}&lt;/time&gt; by {{ record.artist }}.
  &lt;/li&gt;
{%- endfor %}
[…]
&lt;script&gt;
  document.addEventListener('alpine:init', () =&gt; {
    Alpine.data('collection', () =&gt; ({
      records: [],
      async getRecords() {
        this.records = await (await fetch('/&#95;data/records.json')).json();
        document.documentElement.classList.add('alpine');
      },
      init() {
        this.getRecords();
      }
    }))
  })
&lt;/script&gt;</code></pre>

11ty data is hidden, results are coming from Alpine, but the pagination is not functional at the moment:

{{< codepen height="480" theme_id="light" slug_hash="eYyWQOe" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 2](https://codepen.io/smashingmag/pen/eYyWQOe) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}

### Pagination

Before we add filters, let’s paginate our data. 11ty did us the favor of handling all the logic for us, but now we have to do it on our own. In order to split our data across multiple pages, we need the following:

- the number of items per page (`itemsPerPage`),
- the current page (`currentPage`),
- the total number of pages (`numOfPages`),
- a dynamic, paged subset of the whole data (`page`).

<pre><code class="language-javascript">document.addEventListener('alpine:init', () =&gt; {
  Alpine.data('collection', () =&gt; ({
    records: [],
    itemsPerPage: 5,
    currentPage: 0,
    numOfPages: // total number of pages,
    page: // paged items
    async getRecords() {
      this.records = await (await fetch('/_data/records.json')).json();
      document.documentElement.classList.add('alpine');
    },
    init() {
      this.getRecords();
     }
  }))
})</code></pre>

The number of items per page is a fixed value `(5)`, and the current page starts with `0`. We get the number of pages by dividing the total number of items by the number of items per page:

<pre><code class="language-javascript">numOfPages() {
  return Math.ceil(this.records.length / this.itemsPerPage)
  // 7 / 5 = 1.4
  // Math.ceil(7 / 5) = 2
},</code></pre>

The easiest way for me to get the items per page was to use the `slice()` method in JavaScript and take out the slice of the dataset that I need for the current page:

<pre><code class="language-javascript">page() {
  return this.records.slice(this.currentPage &#42; this.itemsPerPage, (this.currentPage + 1) &#42; this.itemsPerPage)

  // this.currentPage &#42; this.itemsPerPage, (this.currentPage + 1) &#42; this.itemsPerPage
  // Page 1: 0 &#42; 5, (0 + 1) &#42; 5 (=> slice(0, 5);)
  // Page 2: 1 &#42; 5, (1 + 1) &#42; 5 (=> slice(5, 10);)
  // Page 3: 2 &#42; 5, (2 + 1) &#42; 5 (=> slice(10, 15);)
}</code></pre>

To only display the items for the current page, we have to adapt the `for` loop to iterate over `page` instead of `records`:

<pre><code class="language-html">&lt;ol class="records"&gt; 
  &lt;template x-for="record in page"&gt;
    &lt;li&gt;
      &lt;strong x-text="record.title"&gt;&lt;/strong&gt;&lt;br&gt;
      Released in &lt;time :datetime="record.year" x-text="record.year"&gt;&lt;/time&gt; by &lt;span x-text="record.artist"&gt;&lt;/span&gt;.
    &lt;/li&gt;
  &lt;/template&gt;
&lt;/ol&gt;</code></pre>

We now have a page, but no links that allow us to jump from page to page. Just like earlier, we use the `template` element and the `x-for` directive to display our page links:

<pre><code class="language-html">&lt;ol class="pages"&gt;
  &lt;template x-for="idx in numOfPages"&gt;
    &lt;li&gt;
      &lt;a :href="`/${idx}`" x-text="`Page ${idx}`" :aria-current="idx === currentPage + 1 ? 'page' : false" @click.prevent="currentPage = idx - 1"&gt;&lt;/a&gt;
    &lt;/li&gt;
  &lt;/template&gt;
  
  {% for page_entry in pagination.pages %}
    &lt;li x-ignore&gt;
      […]
    &lt;/li&gt;
  {% endfor %}
&lt;/ol&gt;</code></pre>

Since we don’t want to reload the whole page anymore, we put a `click` event on each link, prevent the default click behavior, and change the current page number on click:

<pre><code class="language-html">&lt;a href="/" @click.prevent="currentPage = idx - 1"&gt;&lt;/a&gt;</code></pre>

Here’s what that looks like in the browser. (I’ve added more entries to the JSON file. You can [download it on GitHub](https://raw.githubusercontent.com/matuzo/articles/main/11ty-alpine/_data/records_full.json).)

{{< codepen height="480" theme_id="light" slug_hash="GRymwjg" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 3](https://codepen.io/smashingmag/pen/GRymwjg) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}

### Filtering

I want to be able to filter the list by artist and by decade. 

We add two select elements wrapped in a `fieldset` to our component, and we put a `x-model` directive on each of them. `x-model` allows us to bind the value of an input element to Alpine data:

<pre><code class="language-html">&lt;fieldset class="filters"&gt;
  &lt;legend&gt;Filter by&lt;/legend&gt;

  &lt;label for="artist"&gt;Artist&lt;/label&gt;
  &lt;select id="artist" x-model="filters.artist"&gt;
    &lt;option value=""&gt;All&lt;/option&gt;
  &lt;/select&gt;

  &lt;label for="decade"&gt;Decade&lt;/label&gt;
  &lt;select id="decade" x-model="filters.year"&gt;
    &lt;option value=""&gt;All&lt;/option&gt;
  &lt;/select&gt;
&lt;/fieldset&gt;</code></pre>

Of course, we also have to create these data fields in our Alpine component:

<pre><code class="language-javascript">document.addEventListener('alpine:init', () =&gt; {
  Alpine.data('collection', () =&gt; ({
      filters: {
        year: '',
        artist: '',
      },
      records: [],
      itemsPerPage: 5,
      currentPage: 0,
      numOfPages() {
        return Math.ceil(this.records.length / this.itemsPerPage)
      },
      page() {
        return this.records.slice(this.currentPage &#42; this.itemsPerPage, (this.currentPage + 1) &#42; this.itemsPerPage)
      },
      async getRecords() {
        this.records = await (await fetch('/_data/records.json')).json();
        document.documentElement.classList.add('alpine');
      },
      init() {
        this.getRecords();
      }
  }))
})</code></pre>

If we change the selected value in each `select`, `filters.artist` and `filters.year` will update automatically. You can try it here with some dummy data I’ve added manually:

{{< codepen height="480" theme_id="light" slug_hash="GRymwEp" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 4](https://codepen.io/smashingmag/pen/GGRymwEp) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}

Now we have `select` elements, and we’ve bound the data to our component. The next step is to populate each `select` dynamically with artists and decades respectively. For that we take our `records` array and manipulate the data a bit:

<pre><code class="language-javascript">document.addEventListener('alpine:init', () =&gt; {
  Alpine.data('collection', () =&gt; ({
    artists: [],
    decades: [],
    // […]
    async getRecords() {
      this.records = await (await fetch('/_data/records.json')).json();
      this.artists = [...new Set(this.records.map(record =&gt; record.artist))].sort();
      this.decades = [...new Set(this.records.map(record =&gt; record.year.toString().slice(0, -1)))].sort();
      document.documentElement.classList.add('alpine');
    },
    // […]
  }))
})</code></pre>

This looks wild, and I’m sure that I’ll forget what’s going on here real soon, but what this code does is that it takes the array of objects and turns it into an array of strings (`map()`), it makes sure that each entry is unique (that’s what `[...new Set()]` does here) and sorts the array alphabetically (`sort()`). For the decade's array, I’m additionally slicing off the last digit of the year because I don’t want this filter to be too granular. Filtering by decade is good enough. 

Next, we populate the artist and decade `select` elements, again using the `template` element and the `x-for` directive: 

<pre><code class="language-javascript">&lt;label for="artist"&gt;Artist&lt;/label&gt;
&lt;select id="artist" x-model="filters.artist"&gt;
  &lt;option value=""&gt;All&lt;/option&gt;
  &lt;template x-for="artist in artists"&gt;
    &lt;option x-text="artist"&gt;&lt;/option&gt;
  &lt;/template&gt;
&lt;/select&gt;

&lt;label for="decade"&gt;Decade&lt;/label&gt;
&lt;select id="decade" x-model="filters.year"&gt;
  &lt;option value=""&gt;All&lt;/option&gt;
  &lt;template x-for="year in decades"&gt;
    &lt;option :value="year" x-text="`${year}0`"&gt;&lt;/option&gt;
  &lt;/template&gt;
&lt;/select&gt;</code></pre>

Try it yourself in [demo 5 on Codepen](https://codepen.io/matuzo/pen/KKZwqQe?editors=1010).

{{< codepen height="480" theme_id="light" slug_hash="OJzmaZb" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 5](https://codepen.io/smashingmag/pen/OJzmaZb) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}
  
We’ve successfully populated the select elements with data from our JSON file. To finally filter the data, we go through all records, we check whether a filter is set. If that’s the case, we check that the respective field of the record corresponds to the selected value of the filter. If not, we filter this record out. We’re left with a filtered array that matches the criteria:

<pre><code class="language-javascript">get filteredRecords() {
  const filtered = this.records.filter((item) =&gt; {
    for (var key in this.filters) {
      if (this.filters[key] === '') {
        continue
      }

      if(!String(item[key]).includes(this.filters[key])) {
        return false
      }
    }

    return true
  });

  return filtered
}</code></pre>

For this to take effect we have to adapt our `numOfPages()` and `page()` functions to use only the filtered records:

<pre><code class="language-javascript">numOfPages() {
  return Math.ceil(this.filteredRecords.length / this.itemsPerPage)
},
page() {
  return this.filteredRecords.slice(this.currentPage &#42; this.itemsPerPage, (this.currentPage + 1) &#42; this.itemsPerPage)
},</code></pre>

{{< codepen height="480" theme_id="light" slug_hash="GRymwQZ" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 6](https://codepen.io/smashingmag/pen/GRymwQZ) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}

**Three things left to do:**

1. fix a bug;
2. hide the form;
3. update the status message.

### Bug Fix: Watching a Component Property

When you open the first page, click on page 6, then select “1990” &mdash; you don’t see any results. That’s because our filter thinks that we’re still on page 6, but 1) we’re actually on page 1, and 2) there is no page 6 with “1990” active. We can fix that by resetting the `currentPage` when the user changes one of the filters. To watch changes in the `filter` object, we can use a so-called magic method:

<pre><code class="language-javascript">init() {
  this.getRecords();
  this.$watch('filters', filter =&gt; this.currentPage = 0);
}</code></pre>

Every time the `filter` property changes, the currentPage will be set to `0`.

### Hiding the Form

Since the filters only work with JavaScript enabled and functioning, we should hide the whole form when that’s not the case. We can use the `.alpine` class we created earlier for that:

<pre><code class="language-html">&lt;fieldset class="filters" hidden&gt;
  […]
&lt;/fieldset&gt;</code></pre>

<pre><code class="language-css">.filters {
  display: block;
}

html:not(.alpine) .filters {
  visibility: hidden;
}</code></pre>

I’m using `visibility: hidden` instead of `hidden` only to avoid content shifting while Alpine is still loading.

{{% ad-panel-leaderboard %}}

### Communicating Changes

The status message at the beginning of our list still reads “Showing 7 records”, but this doesn’t change when the user changes the page or filters the list. There are two things we have to do to make the paragraph dynamic: bind data to it and communicate changes to assistive technology (a screen reader, e.g.).

First, we bind data to the `output` element in the paragraph that changes based on the current page and filter:

<pre><code class="language-html">&lt;p id="message"&gt;Showing &lt;output x-text="message"&gt;{{ records.length }} records&lt;/output&gt;&lt;/p&gt;</code></pre>

<pre><code class="language-javascript">Alpine.data('collection', () =&gt; ({
  message() {
    return `${this.filteredRecords.length} records`;
  },
// […]</code></pre>

Next, we want to communicate to screen readers that the content on the page has changed. There are at least two ways of doing that:

<ol>
  <li>We could turn an element into a so-called <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions">live region</a> using the <code>aria-live</code> attribute. A live region is an element that announces its content to screen readers every time it changes.<br />

  <pre><code class="language-html">&lt;div aria-live="polite"&gt;Dynamic changes will be announced&lt;/div&gt;</code></pre>
  In our case, we don’t have to do anything, because we’re already using the <code>output</code> element (remember?) which is an implicit live region by default.<br />

  <pre><code class="language-html">&lt;p id="message"&gt;Showing &lt;output x-text="message"&gt;{{ records.length }} records&lt;/output&gt;&lt;/p&gt;</code></pre>
  <blockquote>“The <code>&lt;output&gt;</code> HTML element is a container element into which a site or app can inject the results of a calculation or the outcome of a user action.”<br /><br />Source: <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output"><code>&lt;output&gt;</code>: The Output Element</a>, MDN Web Docs</blockquote></li>
  <li>We could make the region focusable and move the focus to the region when its content changes. Since the region is labelled, its name and role will be announced when that happens.<br />

<pre><code class="language-html">&lt;div aria-labelledby="message" role="region" tabindex="-1" x-ref="region"&gt;</code></pre>
  We can reference the region using the <code>x-ref</code> directive.<br />

  <pre><code class="language-html">&lt;a @click.prevent="currentPage = idx - 1; $nextTick(() =&gt; { $refs.region.focus(); $refs.region.scrollIntoView(); });" :href="`/${idx}`" x-text="`Page ${idx}`" :aria-current="idx === currentPage + 1 ? 'page' : false"></a></code></pre></li>
</ol>

I’ve decided to do both: 

1. When users *filter* the page, we update the live region, but we don’t move focus. 
2. When they *change* the page, we move focus to the list.

That’s it. Here’s the [final result](https://sad-kare-e07051.netlify.app/index_js/): 

{{< codepen height="480" theme_id="light" slug_hash="zYpwMXX" default_tab="result" breakout="true" user="smashingmag" editable="true" data-editable="true" >}}See the Pen [Pagination + Filter with Alpine.js Step 7](https://codepen.io/smashingmag/pen/zYpwMXX) by <a href="https://codepen.io/matuzo">Manuel Matuzovic</a>.{{< /codepen >}}

**Note:** *When you filter by artist, and the status message shows “1 records”, and you filter again by another artist, also with just one record, the content of the `output` element doesn’t change, and nothing is reported to screen readers. This can be seen as a bug or as a feature to reduce redundant announcements. You’ll have to test this with users.*

## What’s Next?

What I did here might seem redundant, but if you’re like me, and you don’t have enough trust in JavaScript, it’s worth the effort. And if you look at the [final CodePen](https://codepen.io/matuzo/pen/GRygvwY?editors=1100) or the [complete code on GitHub](https://github.com/matuzo/articles/tree/main/11ty-alpine), it actually wasn’t that much extra work. Minimal frameworks like Alpine.js make it really easy to progressively enhance static components and make them reactive.

I’m pretty happy with the result, but there are a few more things that could be improved:

1. The pagination could be smarter (maximum number of pages, previous and next links, and so on).
2. Let users pick the number of items per page.
3. Sorting would be a nice feature.
4. Working with the history API would be great.
5. Content shifting can be improved.
6. The solution needs user testing and browser/screen reader testing.

**P.S.** *Yes, I know, Alpine produces invalid HTML with its custom `x-` attribute syntax. That hurts me as much as it hurts you, but as long as it doesn’t affect users, I can live with that. :)*

**P.S.S.** *Special thanks to Scott, Søren, Thain, David, Saptak and Christian for their feedback.*

### Further Resources

- “[How To Build A Filterable List Of Things](https://annualbeta.com/blog/how-to-build-a-filterable-list-of-things/)”, Søren Birkemeyer
- “[Considering Dynamic Search Results And Content](https://www.scottohara.me/blog/2022/02/05/dynamic-results.html)”, Scott O’Hara

{{< signature "vf, yk, il" >}}
