---
title: An In-Depth Overview Of Living Style Guide Tools
slug: an-in-depth-overview-of-living-style-guide-tools
image: >-
  https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0914bf76-eedd-4ce2-82d8-09b699e9314e/code-colors-illu-opt.png
date: 2015-04-14T02:10:01.000Z
author: robertharitonov
description: >-
  Following the market's demand for minimalistic and consistent UIs, and the
  growth in modular web development, we tend to pay more and more attention to
  documentation and the efficiency of designer–engineer workflow with each
  project we undertake. Also, since **the documentation process is often the
  weakest spot for modern web teams**, we're constantly looking for the right
  tools to help us.

  Living style guides help front-end developers transform front-end codebases
  into well-described pattern libraries with the minimum of effort. But to make
  them really efficient, we need to choose the proper tools — so let’s have a
  closer look at what our community has to offer.
categories:
  - Coding
  - Workflow
  - CSS
  - Style Guides
  - Design Systems
---
Following the market's demand for minimalistic and consistent UIs, and the growth in modular web development, we tend to pay more and more attention to documentation and the efficiency of designer–engineer workflow with each project we undertake. Also, since <strong>the documentation process is often the weakest spot for modern web teams</strong>, we're constantly looking for the right tools to help us.

Living style guides help front-end developers transform front-end code bases into well-described pattern libraries with the minimum of effort. But to make them really efficient, we need to choose the proper tools — so let’s have a closer look at what our community has to offer.

I've arranged the tools by function, highlighting only the most powerful ones worth knowing about. You can find more tools, plus videos, articles and other material about style guides at <a href="https://styleguides.io/tools.html">styleguide.io</a>.

Before we start, if you are not yet familiar with living style guides, I suggest looking into these resources to get a good grounding in the topic:

## <span class="rh">Further Reading</span> on SmashingMag:

*   [How To Design Style Guides For Brands And Websites](https://www.smashingmagazine.com/2010/07/designing-style-guidelines-for-brands-and-websites/)
*   [How To Make An Effective Style Guide](https://www.smashingmagazine.com/2014/02/effective-style-guides-with-adobe-fireworks/)
*   [Automating Style Guide-Driven Development](https://www.smashingmagazine.com/2015/03/automating-style-guide-driven-development/)

{{% feature-panel %}}

In a nutshell, living style guides are designed to aid in building well-organized documentation of front-end codebases. By “living” we mean the documentation remains in constant sync with the actual code.</p>

## CSS Documentation Tools

The first players in the field are <em>CSS documentation parsing tools</em>. The idea of including descriptions of components in style source code first came from web designers. Combining a creative approach to design style guides with web implementation practices led to the development of <a href="https://warpspire.com/kss/">KSS</a>.

Similar to <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a>, in KSS, CSS components are described right in the source code as comments.</p>

<pre><code class="language-css">
// A button suitable for giving a star to someone.
//
// :hover             - Subtle hover highlight.
// .star-given        - A highlight indicating.
// .star-given:hover  - Subtle hover highlight.
// .disabled          - Dims the button.
//
// Styleguide 2.1.3.
a.button.star{
  ...
  &amp;.star-given{
    ...
  }
  &amp;.disabled{
    ...
  }
}
</code></pre>

KSS allows you to define components by style guide section number and describe their different states. This information is then parsed, generating either a single-page document or a set of static HTML files with rendered examples and code snippets.</p>

<figure><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8c97d044-aac4-4acb-bc6b-f6223eb06b86/styleguide-screenshot-large-preview-opt.jpg"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bba97fa1-2abc-434d-9f8c-748dbf81d39c/styleguide-screenshot-preview-opt.jpg" alt="Single-page documentation generated by KSS." /></a><figcaption>Single-page documentation generated by KSS. (<a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8c97d044-aac4-4acb-bc6b-f6223eb06b86/styleguide-screenshot-large-preview-opt.jpg">Large preview</a>)</figcaption></figure>

In other CSS documentation parsing tools, it is also possible to define HTML markup in the comments, whereas KSS only parses the actual CSS selectors and generates simple markup automatically.

Currently, KSS is a documentation solution only, and the parsing tool is not being updated. Although it's implementations like <a href="https://kss-node.github.io/kss-node/">KSS-node</a> are still being improved with custom documentation fields and better templating support.</p>

### Alternatives To KSS

Since the original KSS, many similar tools have been released to do exactly the same thing. One of the most successful is the <a href="https://styleguide.sc5.io/">SC5 Style Guide Generator</a>, which is based on KSS. In addition to encapsulated (using Shadow DOM) rendered component previews, the tool also allows you to edit Sass or LESS styles in the browser. It is also possible to define Angular.js directives or web components as a markup example in CSS comments, which will then be transformed into a fully operational component.

Unfortunately, most CSS documentation tools copy one another's functionality, without introducing new possibilities (making describing each one somewhat redundant), but available ones include: <a href="https://github.com/nopr/sassdown/">Sassdown</a>; <a href="https://jacobrask.github.io/styledocco/">StyleDocco</a>; <a href="https://kaleistyleguide.com/">Kalei Styleguide</a> (client-side only); <a href="https://trulia.github.io/hologram/">Hologram</a>; and <a href="https://github.com/styledown/styledown">Styledown</a>.

One tool, however, is more distinctive. <a href="https://github.com/darcyclarke/DSS">DSS</a> is the only standalone CSS documentation parser that produces JSON for later templating. DSS is based on Node.js with support for all modern preprocessors. Compared to KSS, it is possible to integrate DSS into any other tool or environment, as the original author also did with the <a href="https://github.com/darcyclarke/grunt-dss">DSS Grunt plugin</a>.

## Style Guide Platforms

While they are straightforward to implement, CSS documentation parsers are very limited. If you try to describe complex components in CSS, you will end up with bloated and hard to manage styles, containing a lot of copy-and-pasted HTML snippets all over the codebase.

The more duplicated templates and HTML you have, the less living your style guides will be. Without constant syncing between codebase and the pattern library, you may face more problems than if you had no documentation at all.

If you have serious plans for maintaining your own UI components library, it’s better to chose an alternative group of tools I call <em>style guide platforms</em>. Whether they're static site generators or dynamic environments, style guide platforms provide alternative and scalable solutions for collating your documentation.</p>

## Static Style Guide Generators

The most basic example of a static front-end style guide generator is <a href="https://github.com/adactio/Pattern-Primer">Pattern Primer</a>. It simply concatenates a list of HTML files into a single-page document that you can enhance with brief text descriptions and code examples.

All the other tools I will mention in this section do almost the same thing, but with additional perks on top.</p>

### Pattern Lab

<a href="https://patternlab.io/">Pattern Lab</a> also concatenates a set of templates into a static style guide website. But on top of that it also provides a set of useful features like navigation, annotation support and smart templating.

Every tool must have a workflow and Pattern Lab does it best, combining structure with an <a href="https://bradfrost.com/blog/post/atomic-web-design/">atomic design</a> approach. This is an ideal combination for easy prototyping and passing HTML markup to clients or back-end developers. However, you might find that its rigorous stance on technologies and file naming may interfere with your existing codebase and individual requirements.</p>

<figure><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6e2d5931-0575-4710-be3c-67d930d800f3/pattern-lab-large-preview-opt.jpg"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/abeb2305-d6a5-4129-8804-d0f8466e6685/pattern-lab-preview-opt.jpg" alt="" /></a><figcaption>Pattern Lab in action. (<a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6e2d5931-0575-4710-be3c-67d930d800f3/pattern-lab-large-preview-opt.jpg">Large preview</a>)</figcaption></figure>

Pattern Lab sets up a <i>_patterns</i> directory with subfolders for each component, following the naming convention. Each folder contains a set of logicless Mustache templates with HTML markup.</p>

<figure><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6968f095-495a-4c22-836f-d8c3b237e9a5/pattern-lab-files-large-preview-opt.jpg"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2034afef-55ea-4bf4-aed2-8fe487463b64/pattern-lab-files-preview-opt.jpg" alt="Folder structure and Pattern Lab generated navigation." /></a><figcaption>Folder structure and Pattern Lab generated navigation. (<a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6968f095-495a-4c22-836f-d8c3b237e9a5/pattern-lab-files-large-preview-opt.jpg">Large preview</a>)</figcaption></figure>

Data for templates is defined on a global level, or may be set locally next to the markup itself:

<pre><code class="language-markup">
pages/article.mustache
pages/article.json
</code></pre>

All that's left is to link project styles into a generic page template and run the Pattern Lab builder. View the resulting demo page of generated pattern library.</p>

### Other Static Site Generators

There are a few more tools, following similar. <a href="https://fbrctr.github.io/">Fabricator</a> collates HTML and Markdown files, providing you greater flexibility in structuring component documentation.</p>

<figure><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68a3910b-a713-481d-804e-2cd39d668e83/fabricator-large-preview-opt.jpg"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fff0adcb-843f-4063-9d30-89418ab17270/fabricator-preview-opt.jpg" alt="Fabricator-compatible folder structure and produced page screenshot." /></a><figcaption>Fabricator-compatible folder structure and produced page screenshot. (<a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68a3910b-a713-481d-804e-2cd39d668e83/fabricator-large-preview-opt.jpg">Large preview</a>)</figcaption></figure>

Pattern Lab allows you to define template data next to Mustache sources; with Fabricator it is possible to define Markdown files with text descriptions next to the HTML source. Documentation processing is done using a Gulp build task, which also includes live reload for ease of development. Here is an <a href="https://fbrctr.github.io/demo/">example output</a> generated by Fabricator.</p>

### LivingStyleGuide Gem

Another tool worth mentioning is <a href="https://livingstyleguide.org/">LivingStyleGuide Gem</a>, based on Sass and Markdown.

To define markup, you can choose between HTML and Haml. UI elements are described using Markdown with custom syntax for imports and data definition.</p>

<pre><code class="language-html">
@haml
@full-width
***.concept-page***
  ***.concept-page--container***
    %h1***.concept-page--title*** Concept
    ***.concept-page--section***
</code></pre>

Here is a list of demo components used as an input to LivingStyleGuide Gem and the resulting <a href="https://livingstyleguide.com/eurucamp/">single-page doc</a>.

Since it follows a quite opinionated technology stack, most benefits will be gained only by using a Ruby ecosystem.</p>

## Dynamic Style Guide Platforms

To get even more flexibility and richer sets of features you can choose <em>dynamic style guide platforms</em>. The difference from the tools mentioned so far is that rather than static websites, they provide full-featured web applications.

At the moment, there are only two good examples of dynamic style guide platforms: <a href="https://github.com/lonelyplanet/rizzo">Rizzo</a>; and <a href="https://sourcejs.com/">SourceJS</a>.
<blockquote>Compared to CSS-focused tools, style guide platforms are more engineer-driven, covering the full development and integration processes, not just the HTML markup and web design aspects.</blockquote>

### Rizzo

Rizzo is a small Ruby application that pulls UI component assets via a special API that the master (main product) application provides. Instead of copying templates and markup into the style guide repository, component sources are pulled there automatically. It is currently the best way to develop truly <em>living</em> style guides that are constantly in sync with the real codebase, thus providing more flexibility than CSS documentation parsers.

Unfortunately, Rizzo is highly opinionated and is not yet suited for easy reuse in other applications. However, I definitely suggest you read more about <a href="https://github.com/lonelyplanet/rizzo">the ideas behind it</a> on the Lonely Planet engineering blog.</p>

### SourceJS

Compared to Rizzo, <a href="https://sourcejs.com/">SourceJS</a> is a scalable open source solution. The dynamic app environment allows you to configure any custom routing and on-the-fly API-based documentation generation. This provides more freedom for integration with your main application sources than with Rizzo.

Out of the box, SourceJS allows you to use Markdown files and special template pages for describing UI components. With official plugins, it is also possible to use <a href="https://github.com/sourcejs/sourcejs-contrib-dss">CSS Documentation</a> and <a href="https://github.com/sourcejs/sourcejs-jade">Jade</a>-based templates. Choose your preferred syntax or combine everything at once (see <a href="https://sourcejs.com/specs/">examples</a>).</p>

<figure><br>
<div style="height: 0;padding-bottom: 56.25%;margin-bottom: -1em"></div>
<figcaption>SourceJS introduction video</figcaption></figure>

The application's core is highly modular, containing only the most common features and APIs used for <a href="https://sourcejs.com/docs/api/plugins/">developing custom plugins</a>. The platform is built with Node.js but does not provide any opinion on technologies you might want to integrate, such as different templating languages and CSS preprocessors.</p>

### Components-Oriented

SourceJS workflow is mostly focused on <em>component libraries</em> organization and supports living style guide-driven development rules. This helps to develop and test components right in the documentation pages.

Such an approach allows you to combine multiple sets of components in one environment, even for different web projects. Simply place the main application next to the SourceJS app and link CSS styles, JavaScript and templates into your documentation pages.

If the project codebase is already focused on standalone UI components, link their folders to the SourceJS spec catalog:

<pre><code class="language-javascript">
sourcejs/specs/
    menu-component/
        menu.css
        menu.js
        menu.html
        readme.md
        [index.src]
</code></pre>

The engine will parse the <i>readme.md</i> file or special <i>index.src</i> template with examples of how the components will render and expose a rich <a href="https://sourcejs.com/docs/spec/">documentation page</a>. Use this page to list all component states with different data, making it easier to test and share among team members.</p>

<a href="mailto:r@rhr.me">Request a consultation session</a> with the authors of the SourceJS platform to see how it could be integrated with your codebase, or use GitHub issues and <a href="https://gitter.im/sourcejs/Source">Gitter chat</a> to ask questions.</p>

## Starter Kits

The most common misunderstanding I see in compilations of style guide tools is that <em>starter kits</em> are often mixed in with generators and parsers. They should only really be regarded as boilerplates for your style guide. Here are three such starter kits:

*   [Style Guide Boilerplate](https://bjankord.github.io/Style-Guide-Boilerplate/)
*   [Barebones](https://barebones.paulrobertlloyd.com/)
*   [Google Web Starter Kit](https://developers.google.com/web/starter-kit/) also contains style guide template

These starter templates could be used in any of the tools I've mentioned, as markup examples.</p>

## Summing Up

The technologies on which these tools are based are rarely important, because in most cases it does not matter if a generator or dynamic server is running on Ruby or Node.js. The things that <em>really matter</em> are the organizational structure, the templating engines used and platform flexibility.</p>

### Starting Small

For simple CSS frameworks and small web projects, that are not going to require long-term support, I would suggest using <a href="https://styleguide.sc5.io/">SC5 Style Guide Generator</a> or <a href="https://github.com/darcyclarke/DSS">DSS</a>. Both of them are really easy to set up and master.</p>

<figure><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e5c4dfe6-566c-40be-8800-3493d1a42d11/small-comp-lib-large-preview-opt.jpg"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dabda264-e143-4c46-beeb-7e9c85bda4eb/small-comp-lib-preview-opt.jpg" alt="Simple CSS Components Library from Heroku." /></a><figcaption>Simple CSS components library from Heroku. (<a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e5c4dfe6-566c-40be-8800-3493d1a42d11/small-comp-lib-large-preview-opt.jpg">Large preview</a>)</figcaption></figure>

### More Complex Component Libraries

If you need to support components more complex than buttons and forms, components that contain several technologies like templates and JavaScript, the best choice will be one of the style guide platforms. Compared to CSS documentation parsers, platforms encourage you to follow style guide-driven development with all its benefits.

This combination will help you maintain really living pattern libraries, keeping your codebase well structured and easy to reuse.</p>

### Flexible Solutions For Deep Integration

The only efficient and long-lasting way of supporting living style guides is having no code duplication at all. <a href="https://github.com/lonelyplanet/rizzo">Rizzo</a> and <a href="https://sourcejs.com/">SourceJS</a> allow you to seamlessly integrate your development workflow with the documentation process. Write code once and use it both in the application product and in the style guide with descriptions and representations of different states.

With SourceJS, it is possible to repeat almost all the workflows offered by other tools, but with wider possibilities for custom integration and a powerful plugins infrastructure.</p>

## The Future Of Style Guides

I am the main contributor to SourceJS and I hope you'll let me mention a few additional benefits of the engine, and share our team’s vision about the future of style guides.
<blockquote>We believe that style guides must serve as an entry point to any front-end-related workflows for the whole team. Therefore, style guides should be treated more seriously than just regular documentation or brand guidelines.</blockquote>

Using plugins like <a href="https://github.com/sourcejs/sourcejs-comments">comments</a> or <a href="https://github.com/sourcejs/sourcejs-crowd-voice">crowd-voice</a>, teams are able to communicate between different departments within the style guide, leaving their remarks and feedback in the place where components are developed, tested and maintained.</p>

<figure><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d66f3125-b0e4-4846-9916-3990ea7f7a62/sourcejs-commnets-large-preview-opt.jpg"><img loading="lazy" decoding="async" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7fa9d352-f79d-4ad1-aa27-7d329721f066/sourcejs-commnets-preview-opt.jpg" alt="SourceJS plugin for commenting on the rendered UI examples." /></a><figcaption>SourceJS plugin for commenting on the rendered UI examples. (<a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d66f3125-b0e4-4846-9916-3990ea7f7a62/sourcejs-commnets-large-preview-opt.jpg">Large preview</a>)</figcaption></figure>

As well as in-place communication, we can combine different development tools in one place; run live reload, linting and testing tools with a single command all together within the style guide platform; integrate performance metrics and provide optimization suggestions right on the documentation page. The possibilities are endless.

We are working on getting further different interactive documentation and various front-end infrastructure dashboards in one place, making an ultimate tool for the web developers.

If you believe in the future of style guides and are willing to support this movement, we will be happy to welcome you to the SourceJS community.</p>

### Resources

*   [styleguides.io](https://styleguides.io/): a collection of tools, articles and other materials on style guides
*   [Extensive list of tools for building style guides](https://github.com/davidhund/styleguide-generators)

{{< signature "og" >}}

