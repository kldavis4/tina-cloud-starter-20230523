---
title: 'Customizing WordPress Archives For Categories, Tags And Other Taxonomies'
slug: customizing-wordpress-archives-categories-terms-taxonomies
image: >-
  https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b10a614e-b401-4f69-92af-1e37a09e8ea2/wordpress-categories-taxonomies-opt.png
date: 2014-08-28T00:47:02.000Z
author: josh-pollock
description: >-
  Most WordPress users are familiar with tags and categories and with how to use
  them to organize their blog posts. If you use custom post types in WordPress,
  you might need to organize them like categories and tags. Categories and tags
  are examples of taxonomies, and **WordPress allows you to create as many
  custom taxonomies as you want**. These custom taxonomies operate like
  categories or tags, but are separate.

  In this tutorial, we’ll explain custom taxonomies and how to create them.
  We’ll also go over which template files in a WordPress theme control the
  archives of built-in and custom taxonomies, and some advanced techniques for
  customizing the behavior of taxonomy archives.
categories:
  - WordPress
  - Techniques (WP)
---
Most WordPress users are familiar with tags and categories and with how to use them to organize their blog posts. If you use custom post types in WordPress, you might need to organize them like categories and tags. Categories and tags are examples of taxonomies, and WordPress allows you to create as many custom taxonomies as you want. These custom taxonomies operate like categories or tags, but are separate.

In this tutorial, we’ll explain custom taxonomies and how to create them. We’ll also go over which template files in a WordPress theme control the archives of built-in and custom taxonomies, and some advanced techniques for customizing the behavior of taxonomy archives.</p>

## <span class="rh">Further Reading</span> on SmashingMag:

*   [Building A Custom Archive Page For WordPress](https://www.smashingmagazine.com/2015/04/building-custom-wordpress-archive-page/)
*   [Website Archives Design: Good Practices and Examples](https://www.smashingmagazine.com/2010/05/website-archives-best-practices-and-showcase/)
*   [A Detailed Guide To WordPress Custom Page Templates](https://www.smashingmagazine.com/2015/06/wordpress-custom-page-templates/)

## Terminology

Before continuing, let’s get our terminology straight. A taxonomy is a WordPress content type, used primarily to organize content of any other content type. The two taxonomies everyone is familiar with are built in: categories and tags. We tend to call an individual posting of a tag a “tag,” but to be precise, we should refer to it as a “term” in the “tag” taxonomy. We pretty much always refer to items in a custom taxonomy as “terms.”

{{% feature-panel %}}

Categories and tags represent the two types of taxonomies: hierarchical and non-hierarchical. Like categories, hierarchical taxonomies can have parent-child relationships between terms in the taxonomy. For example, you might have on your blog a “films” category that has several child categories, with names like “foreign” and “domestic.” Custom taxonomies may also be hierarchical, like categories, or non-hierarchical, like tags.</p>

<figure><img loading="lazy" decoding="async"  src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b10a614e-b401-4f69-92af-1e37a09e8ea2/wordpress-categories-taxonomies-opt.png" alt="wordpress-categories-taxonomies-opt" width="500" height="369" /><figcaption>A small part of the "WordPress Template Hierarchy". (<a href="https://wphierarchy.com/">Source</a>)</figcaption></figure>

The archive of a taxonomy is the list of posts in a taxonomy that is automatically generated by WordPress. For example, this would be the page you see when you click on a category link and see all posts in that category. We’ll go over how to change the behavior of these pages and learn which template files generate them.</p>

## How Tag, Category and Custom Taxonomy Archives Work

For every category, tag and custom taxonomy, WordPress automatically generates an archive that lists each post associated with that taxonomy, in reverse chronological order. The system works really well if you organize your blog posts with categories and tags. If you have a complex system of organizing custom post types with custom taxonomies, then it might not be ideal. We’ll go over the many ways to modify these archives.

The first step to customizing is to know which files in your theme are used to display the archive. Different themes have different template files, but all themes have an <code>index.php</code> template. The <code>index.php</code> template is used to display all content, unless a template exists higher up in the hierarchy. WordPress’ template hierarchy is the system that dictates which template file is used to display which content. We’ll briefly go over the template hierarchy for categories, tags and custom taxonomies. If you’d like to learn more, these resources are highly recommended:

*   “[Template Hierarchy](https://codex.wordpress.org/Template_Hierarchy),” WordPress Codex
*   “[Template Hierarchy](https://www.chipbennett.net/themes/template-hierarchy/),” Chip Bennett A flow chart
*   [The WordPress Template Hierarchy: A Mini Resource](https://wphierarchy.com/), Rami Abraham and Michelle Schulp An interactive chart
*   [Reveal Template](https://wordpress.org/plugins/reveal-template/), Scott Reilly A WordPress plugin

Most themes have an <code>archive.php</code> template, which is used for category and tag archives, as well as date and author archives. You can add a template file to handle category and tag archives separately. These templates would be named <code>category.php</code> or <code>tag.php</code>, respectively. You could also create templates for specific tags or categories, using the ID or slug of the category or tag. For example, a tag with the ID of 7 would use <code>tag-7.php</code>, if it exists, rather than <code>tag.php</code> or <code>archive.php</code>. A tag with the slug of “avocado” would be displayed using the <code>tag-avocado.php</code> template.

One tricky thing to keep in mind is that a template named after a slug will override a template named after an ID number. So, if a tag with the slug of “avocado” had an ID of 7, then <code>tag-avocado.php</code> would override <code>tag-7.php</code>, if it exists.

The template hierarchy for custom taxonomies is a little different, because there are templates for all taxonomies, for specific taxonomies and for specific terms in a specific taxonomy. So, imagine that you have two taxonomies, “fruits” and “vegetables,” and the “fruits” taxonomy has two terms, “apples” and “oranges,” while “vegetables” has two terms, “carrots” and “celery.” Let’s add three templates to our website’s theme: <code>taxonomy.php</code>, <code>taxonomy-fruits.php</code> and <code>taxonomy-vegetables-carrots.php</code>.

For the terms in the “fruits” taxonomy, all archives would be generated using <code>taxonomy-fruits.php</code> because no term-specific template exists. On the other hand, the term “carrots” in the “vegetables” taxonomy’s archives would be generated using <code>taxonomy-vegetables-carrots.php</code>. Because no <code>taxonomy-vegetables.php</code> template exists, all other terms in “vegetables” would be generated using <code>taxonomy.php</code>.</p>

### Using Conditional Tags

While you can add any of the custom templates listed above to create a totally unique view for any category, tag, custom taxonomy or custom taxonomy term, sometimes all you want to do is make one or two little changes. In fact, try to avoid creating a lot of templates because you will need to adjust each one when you make overall changes to the basic HTML markup that you use in each template in the theme. Unless I need a template that is radically different from the theme’s <code>archive.php</code>, I tend to stick to adding conditional changes to <code>archive.php</code>.

WordPress provides conditional functions to determine whether a category, tag or custom taxonomy is being displayed. To determine whether a category archive is being shown, you can use <code>is_category()</code> for categories, <code>is_tag()</code> for tags and <code>is_tax()</code> for custom taxonomies. The <code>is_tag()</code> and <code>is_category()</code> functions can also test for specific categories or tags by slug or ID. For example:

<pre><code class="language-php">
&lt;?php
    if ( is_tag() ) {
        echo "True for any tag!";
    }
    if ( is_tag( 'jedis' ) ) {
        echo "True for the tag whose slug is jedi";
    }
    if ( is_tag( array( 'jedi', 'sith' ) ) ) {
        echo "True for tags whose slug is jedi or sith";
    }
    if ( is_tag( 7 ) ) {
        echo "You can also use tag IDs. This is true for tag ID 7";
    }
?&gt;
</code></pre>

For custom taxonomies, the <code>is_tax()</code> function can be used to check whether any taxonomy (not including categories and tags), a specific taxonomy or a specific term in a taxonomy is being shown. For example:

<pre><code class="language-php">
&lt;?php
    if ( is_tax() ) {
        echo "True for any custom taxonomy.";
    }
    if ( is_tax( 'vegetable' ) ) {
        echo "True for any term in the vegetable taxonomy.";
    }
    if ( is_tax( 'vegetable', 'celery' ) ) {
        echo "True only for the term celery, in the vegetable taxonomy.";
    }
?&gt;
</code></pre>

## Creating Custom Taxonomies

Adding a custom taxonomy can be done in one of three ways: coding it manually according to the instructions in the Codex, which I don’t recommend; generating the code using <a href="https://generatewp.com/">GenerateWP</a>; or using a plugin for custom content types, such as <a href="https://pods.io">Pods</a> or <a href="https://wp-types.com/home/types-manage-post-types-taxonomy-and-custom-fields/">Types</a>. Plugins for custom content types enable you to create custom taxonomies and custom post types in WordPress’ back end without having to write any code. Using one is the easiest way to add a custom taxonomy and to get a framework for working with custom content types.

If you opt for one of the first two options, rather than a plugin, then you will need to add the code either to your theme’s <code>functions.php</code> file or to a custom plugin. I strongly recommend creating a custom plugin, rather than adding the code to <code>functions.php</code>. Even if you’ve never created a plugin before, I urge you to do it. While adding the code to your theme’s <code>functions.php</code> will work, when you switch themes (say, because you want to use a new theme or to troubleshoot a problem), the taxonomy will no longer work.

Whether you write your custom taxonomy code by following the directions in the Codex or by generating it with GenerateWP, just paste it in a text file and add one line of code before it and you’ll have a plugin. Upload it and install it as you would any other plugin.

The only line you need to create a custom plugin is <code>/* Plugin name: Custom Taxonomy */</code>.

Below is a plugin to register a custom taxonomy named “vegetables,” which I created using GenerateWP because it’s significantly easier and way less likely to contain errors than doing it manually:

<pre><code class="language-php">
&lt;?php
    /* Plugin Name: Veggie Taxonomy */
    if ( ! function_exists( 'slug_veggies_tax' ) ) {

    // Register Custom Taxonomy
    function slug_veggies_tax() {

    $labels = array(
    'name'                      	=&gt; _x( 'Vegetables', 'Taxonomy General Name', 'text_domain' ),
    'singular_name'              	=&gt; _x( 'Vegetable', 'Taxonomy Singular Name', 'text_domain' ),
    'menu_name'                  	=&gt; __( 'Taxonomy', 'text_domain' ),
    'all_Veggies'                   =&gt; __( 'All Veggies', 'text_domain' ),
    'parent_Veggie'                 =&gt; __( 'Parent Veggie', 'text_domain' ),
    'parent_Veggie_colon'           =&gt; __( 'Parent Veggie:', 'text_domain' ),
    'new_Veggie_name'               =&gt; __( 'New Veggie name', 'text_domain' ),
    'add_new_Veggie'                =&gt; __( 'Add new Veggie', 'text_domain' ),
    'edit_Veggie'                   =&gt; __( 'Edit Veggie', 'text_domain' ),
    'update_Veggie'                 =&gt; __( 'Update Veggie', 'text_domain' ),
    'separate_Veggies_with_commas'  =&gt; __( 'Separate Veggies with commas', 'text_domain' ),
    'search_Veggies'                =&gt; __( 'Search Veggies', 'text_domain' ),
    'add_or_remove_Veggies'         =&gt; __( 'Add or remove Veggies', 'text_domain' ),
    'choose_from_most_used'         =&gt; __( 'Choose from the most used Veggies', 'text_domain' ),
    'not_found'                     =&gt; __( 'Not Found', 'text_domain' ),
    );
    $args = array(
    'labels'                     =&gt; $labels,
    'hierarchical'               =&gt; false,
    'public'                     =&gt; true,
    'show_ui'                    =&gt; true,
    'show_admin_column'          =&gt; true,
    'show_in_nav_menus'          =&gt; true,
    'show_tagcloud'              =&gt; false,
    );
    register_taxonomy( 'vegetable', array( 'post' ), $args );

    }

    // Hook into the 'init' action
    add_action( 'init', 'slug_veggies_tax', 0 );

    }
?&gt;
</code></pre>

By the way, I created this code using GenerateWP in less than two minutes! The service is great, and manually writing code that this website can automatically generate for you makes no sense. To make the process even easier, you can use the plugin <a href="https://wordpress.org/plugins/pluginception/">Pluginception</a> to create a blank plugin for you and then paste the code from GenerateWP into it using WordPress’ plugin editor.</p>

### Using WP_Query With Custom Taxonomies

Once you have added a custom taxonomy, you might want to query for posts with terms in that taxonomy. To do this, we can use taxonomy queries with <code>WP_QUERY</code>.

Taxonomy queries can be very simple or complicated. The simplest query would be for all posts with a certain term. For example, if you had a post type named “jedi” and an associated custom taxonomy named “level,” then you could get all Jedi masters like this:

<pre><code class="language-php">
&lt;?php
    $args = array(
        'post_type' =&gt; 'jedi',
        'level' =&gt; 'master'
    );
    $query = new WP_Query( $args );
?&gt;
</code></pre>

If you added a second custom taxonomy named “era,” then you could find all Jedi masters of the Old Republic like this:

<pre><code class="language-php">
&lt;?php
    $args = array(
        'post_type' =&gt; 'jedi',
        'level' =&gt; 'master',
        'era' =&gt; 'old-republic',
    );
    $query = new WP_Query( $args );
?&gt;
</code></pre>

We can also do more complicated comparisons, using a full <code>tax_query</code>. The <code>tax_query</code> argument enables us to search by ID instead of slug (as we did before) and to search for more than one term. It also enables us to combine multiple taxonomy queries and to set the relationship between the two. In addition, we can even use SQL operators such as <code>NOT IN</code> to exclude terms.

The possibilities are endless. Explore the “<a href="https://codex.wordpress.org/Class_Reference/WP_Query#Taxonomy_Parameters">Taxonomy Parameters</a>” section of the Codex page for “Class Reference/WP_Query” for complete information. The snippet below searches our “jedi” post type for Jedi knights and masters who are not from the Old Republic era:

<pre><code class="language-php">
&lt;?php
    $args = array(
        'post_type' =&gt; 'jedi',
        'tax_query' =&gt; array(
        'relation' =&gt; 'AND',
            array(
                'taxonomy' =&gt; 'level',
                'field' =&gt; 'slug',
                'terms' =&gt; array( 'master', 'knight' )
            ),
            array(
                'taxonomy' =&gt; 'era',
                'field' =&gt; 'slug',
                'terms' =&gt; array( 'old-republic' ),
                'operator' =&gt; 'NOT IN'
                )
        )
    );
    $query = new WP_Query( $args );
?&gt;
</code></pre>

## Customizing Taxonomy Archives

So far, we have covered how taxonomies, tags and categories work by default, as well as how to create custom taxonomies. If any of this default behavior doesn’t fit your needs, you can always modify it. We’ll go over some ways to modify WordPress’ built-in functionality for those of you who use WordPress less as a blogging platform and more as a content management system, which often requires custom taxonomies.</p>

### Hello pre_get_posts

Before any posts are outputted by the WordPress loop, WordPress automatically retrieves the posts for the user according to the page they are on, using the <code>WP_QUERY</code> class. For example, in the main blog index, it gets the most recent posts. In a taxonomy archive, it gets the most recent posts in that taxonomy.

To change that query, you can use the <code>pre_get_posts</code> filter before WordPress gets any posts. This filter exposes the query object after it is set but before it is used to actually get any posts. This means that you can modify the query using the class methods before the main WordPress loop is run. If that sounds confusing, don’t worry — the next few sections of this article give practical examples of how this works.</p>

### Adding Custom Post Types to Category or Tag Archives

A great use of modifying the <code>WP_QUERY</code> object using <code>pre_get_posts</code> is to add posts from a custom post type to the category archive. By default, custom post types are not included in this query. If we were constructing arguments to be passed to <code>WP_Query</code> and wanted to include both regular posts and posts in the custom post type “jedi,” then our argument would look like this:

<pre><code class="language-php">
&lt;?php
    $args = array( 'post_type' =&gt;
        array(
            'post',
            'jedi'
        )
    );
?&gt;
</code></pre>

In the callback for our <code>pre_get_posts</code> filter, we need to pass a similar argument. The problem is that the <code>WP_QUERY</code> object already exists, so we can’t pass an argument to it like we do when creating an instance of the class. Instead, we use the <code>set()</code> class method, which allows us to change any of the arguments after the class has been created.

In the snippet below, we use <code>set()</code> to change the <code>post_type</code> argument from the default value, which is <code>post</code>, to an array of post types, including posts and our custom post type “jedi.” Note that we are using the conditional tag <code>is_category()</code> so that the change happens only when category archives are being displayed.</p>

<pre><code class="language-php">
&lt;?php
    add_filter( 'pre_get_posts', 'slug_cpt_category_archives' );
    function slug_cpt_category_archives( $query ) {
    if ( $query-&gt;is_category() &amp;&amp; $query-&gt;is_main_query()  )  {
        $query-&gt;set( 'post_type',
            array(
                'post',
                'jedi'
            )
        );
    }

    return $query;

    }
?&gt;
</code></pre>

This function’s <code>$query</code> parameter is the <code>WP_QUERY</code> object before it is used to populate the main loop. Because a page may include multiple loops, such as those used by widgets, we use the conditional function <code>is_main_query()</code> to ensure that this affects only the main loop and not any secondary loops on the page, such as those used by widgets.</p>

### Making Category or Hierarchical Taxonomy Archives Hierarchical

By default, the archives for categories and other hierarchical taxonomies act like any other taxonomy archive: they show all posts in that category or with that taxonomy term. To show only parent terms and exclude child terms, you would use the <code>pre_get_posts</code> filter again.

Just like when creating your own <code>WP_QUERY</code> for posts in a taxonomy, the main loop’s <code>WP_QUERY</code> uses the <code>tax_query</code> arguments to get posts by taxonomy. The <code>tax_query</code> has an <code>include_children</code> argument, which by default is set to <code>1</code> or <code>true</code>. By changing it to <code>0</code> or <code>false</code>, we can prevent posts with a child term from being included in the archive:

<pre><code class="language-php">
&lt;?php
    add_action( 'pre_get_posts', 'slug_cpt_category_archives' );
    function slug_cpt_category_archives( $query ) {
        if ( is_tax( 'TAXONOMY NAME') )  {
            $tax_query = $query-&gt;tax_query-&gt;queries;
            $tax_query['include_children'] = 0;
            $query-&gt;set( 'tax_query', $tax_query );
        }

    }
?&gt;
</code></pre>

The result sounds desirable but has several major shortcomings. That’s OK, because if we address those flaws, we’ll have taken the first step to creating something very cool.

The first and biggest problem is that the result is not an archive page that shows the child terms; it’s still a post with the parent term. The other problem is that we don’t have a good way to navigate to the child term archives.

A good way to deal with this is to combine the <code>pre_get_post</code> filter above with a modification to the template that shows the category or taxonomy. We discussed earlier how to determine which template is used to output category or custom taxonomy archives. Also, keep in mind that you can always wrap your changes in conditional tags, such as <code>is_category()</code> or <code>is_tax()</code>, but that can become unwieldy quickly; so, making a copy of your <code>archive.php</code> and removing any unneeded code probably makes more sense.

The first step is to wrap the entire thing in a check to see whether the current taxonomy term has children. If it does not, then we do not want to output anything. To do this, we use <code>get_term_children()</code>, which will return an empty array if the current term has no children and which we can test for with <code>!empty()</code>.

To make this work for any taxonomy that might be displayed, we need to get the current taxonomy and taxonomy term from the <code>query_vars</code> array of the global <code>$wp_query</code> object. The taxonomy’s slug is contained in the <code>taxonomy</code> key, and the term’s slug is in the <code>tax</code> key.

To use <code>get_term_children()</code>, we must have the term’s ID. The ID is not in <code>query_vars</code>, but we can pass the slug to <code>get_term_by()</code> to get it.

Here is how we get all of the information that we need into variables:

<pre><code class="language-php">
&lt;?php
    global $wp_query;
    $taxonomy = $wp_query-&gt;query_vars['taxonomy'];
    $term = $wp_query-&gt;query_vars['tax'];
    $term_id = get_term_by( 'slug', $term, $taxonomy );
    $term_id = $term_id-&gt;term_id;
    $terms = get_term_children( $term_id, $taxonomy );
?&gt;
</code></pre>

Now we will continue only if <code>$terms</code> isn’t an empty array. To see whether it is empty in our check, first we will repopulate the terms using <code>get_terms()</code>. This is necessary because <code>get_term_children</code> returns only an array of IDs, and we need IDs <em>and</em> names, both of which are in the object returned by <code>get_terms()</code>. We can loop through this object, outputting the name as a link. The link can be generated by passing the term’s ID to <code>get_term_link()</code>.

Here is the complete code:

<pre><code class="language-php">
&lt;?php
    global $wp_query;
    $taxonomy = $wp_query-&gt;query_vars['taxonomy'];
    $term = $wp_query-&gt;query_vars['tax'];
    $term_id = get_term_by( 'slug', $term, $taxonomy );
    $term_id = $term_id-&gt;term_id;
    $terms = get_term_children( $term_id, $taxonomy );
    if ( !empty( $terms ) ) {
    $terms = get_terms( $taxonomy, array( 'child_of' =&gt; $term_id ) );
    echo '&lt;ul class="child-term-list"&gt;';
    foreach ( $terms as $term ) {
    echo '&lt;li&gt;&lt;a href="'.$term-&gt;term_id.'"&gt;'.$term-&gt;name.'&lt;/a&gt;&lt;/li&gt;';
    }

    echo '&lt;/ul&gt;';

?&gt;
</code></pre>

### Creating A Custom Landing Page For Taxonomy Archives

If your hierarchical taxonomy has no terms in the parent term, then the regular taxonomy archive system will be of no use to you. You really want to show taxonomy links instead.

In this case, a good option is to create a custom landing page for the term. We’ll use <code>query_vars</code> again to determine whether the user is on the first page of a taxonomy archive; if so, we will use the <code>taxonomy_archive</code> filter to include a separate template, like this:

<pre><code class="language-php">
&lt;?php
    add_filter( 'taxonomy_archive ', 'slug_tax_page_one' );
    function slug_tax_page_one( $template ) {
        if ( is_tax( 'TAXONOMY_NAME' ) ) {
             global $wp_query;
             $page = $wp_query-&gt;query_vars['paged'];
            if ( $page = 0 ) {
                $template = get_stylesheet_directory(). '/taxonomy-page-one.php';
            }
        }

        return $template;

    }
?&gt;
</code></pre>

This callback first checks that the user is in the taxonomy that we want to target. We can target all taxonomies by changing this to just <code>is_tax()</code>. Then, it gets the current page using the <code>query_var</code> named <code>paged</code>, and if the user is on the first page, then it returns the address for the new template file. If not, it returns the default template file.

What you put in that template file is up to you. You can create a list of terms using the code shown above. You can use it to output any content, really — for example, more information about the taxonomy term or links to specific posts.</p>

## Taking Control

With a bit of work, WordPress’ basic architecture, which still reflects its origins as a blogging platform, can be customized to fit almost any website or Web app. Using custom taxonomies to organize your content and doing it in a way that suits your needs will be an important step in many of your WordPress projects. Hopefully, this post has brought you a step closer to getting the most out of this powerful aspect of WordPress.

{{< signature "dp, al, il" >}}

