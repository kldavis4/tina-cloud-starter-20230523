---
title: 'I Used The Web For A Day On Internet Explorer 8'
slug: web-on-internet-explorer-ie8
author: chrisbashton
image: >-
  https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7989ecdf-98ce-477a-bc51-670976109aca/sharing-card-chrisbashton.png
date: 2019-03-19T12:00:08+01:00
summary: >-
  IE8 was released a decade ago today. Chris Ashton tries it out against the modern web, and considers how we can build our sites to last.
description: >-
  IE8 was released a decade ago today. Chris Ashton tries it out against the modern web, and considers how we can build our sites to last.
categories:
  - Internet Explorer
  - Browsers
---
This article is part of a series in which I attempt to use the web under various constraints, representing a given demographic of user. I hope to raise the profile of difficulties faced by real people, which are avoidable if we design and develop in a way that is sympathetic to their needs.

Last time, I [navigated the web for a day using a screen reader](https://www.smashingmagazine.com/2018/12/voiceover-screen-reader-web-apps/). This time, I spent the day using Internet Explorer 8, which was released ten years ago today, on March 19th, 2009.

## Who In The World Uses IE8?

Before we start; a disclaimer: I am _not_ about to tell you that you need to start supporting IE8.

There’s every reason to not support IE8. [Microsoft officially stopped supporting IE8, IE9 and IE10](https://venturebeat.com/2016/01/12/microsoft-ends-support-for-ie8-ie9-ie10-and-windows-8/) over three years ago, and the Microsoft executives are even telling you to [stop using Internet Explorer 11](https://techcommunity.microsoft.com/t5/Windows-IT-Pro-Blog/The-perils-of-using-Internet-Explorer-as-your-default-browser/ba-p/331732).

But as much as we developers hope for it to go away, it just. Won’t. _Die_. IE8 continues to show up in browser stats, especially outside of the bubble of the Western world.

Browser stats have to be taken with a pinch of salt, but current estimates for IE8 usage worldwide are around 0.3% to 0.4% of the desktop market share. The lower end of the estimate comes from [w3counter](https://www.w3counter.com/trends):

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9655a75d-6125-46d1-bb27-8849985a0fe7/ie8-graph-ie8-usage-over-time.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9655a75d-6125-46d1-bb27-8849985a0fe7/ie8-graph-ie8-usage-over-time.png" sizes="100vw" caption="From a peak of almost 30% at the end of 2010, W3Counter now believes IE8 accounts for 0.3% of global usage. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9655a75d-6125-46d1-bb27-8849985a0fe7/ie8-graph-ie8-usage-over-time.png'>Large preview</a>)" alt="Graph of IE8 usage over time" >}}

The higher estimate comes from [StatCounter](https://gs.statcounter.com/browser-version-partially-combined-market-share/desktop/worldwide/#monthly-201802-201901-bar) (the same data feed used by the [“Can I use” usage table](https://caniuse.com/usage-table)). It estimates global IE8 desktop browser proportion to be around 0.37%.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0c1bd914-5845-4173-808d-81ce155af42e/ie8-graph-ie8-usage-vs-other-browsers.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0c1bd914-5845-4173-808d-81ce155af42e/ie8-graph-ie8-usage-vs-other-browsers.png" sizes="100vw" caption="Worldwide usage of IE8 is at 0.37% according to StatCounter. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0c1bd914-5845-4173-808d-81ce155af42e/ie8-graph-ie8-usage-vs-other-browsers.png'>Large preview</a>)" alt="Graph of IE8 usage vs other browsers" >}}

I suspected we might see higher IE8 usage in certain geographical regions, so drilled into the data by continent.

{{% feature-panel %}}

### IE8 Usage By Region

Here is the per-continent IE8 desktop proportion (data from February 2018 &mdash; January 2019):

<table>
	<tbody>
		<tr>
			<td>1.</td>
			<td>Oceania</td>
			<td>0.09%</td>
		</tr>
		<tr>
			<td>2.</td>
			<td>Europe</td>
			<td>0.25%</td>
		</tr>
		<tr>
			<td>3.</td>
			<td>South America</td>
			<td>0.30%</td>
		</tr>
		<tr>
			<td>4.</td>
			<td>North America</td>
			<td>0.35%</td>
		</tr>
		<tr>
			<td>5.</td>
			<td>Africa</td>
			<td>0.48%</td>
		</tr>
		<tr>
			<td>6.</td>
			<td>Asia</td>
			<td>0.50%</td>
		</tr>
	</tbody>
</table>

Someone in Asia is _five times_ more likely to be using IE8 than someone in Oceania.

I looked more closely into the Asian stats, noting the proportion of IE8 usage for each country. There’s a very clear top six countries for IE8 usage, after which the figures drop down to be comparable with the world average:

<table>
	<tbody>
		<tr>
			<td>1.</td>
			<td>Iran</td>
			<td>3.99%</td>
		</tr>
		<tr>
			<td>2.</td>
			<td>China</td>
			<td>1.99%</td>
		</tr>
		<tr>
			<td>3.</td>
			<td>North Korea</td>
			<td>1.38%</td>
		</tr>
		<tr>
			<td>4.</td>
			<td>Turkmenistan</td>
			<td>1.31%</td>
		</tr>
		<tr>
			<td>5.</td>
			<td>Afghanistan</td>
			<td>1.27%</td>
		</tr>
		<tr>
			<td>6.</td>
			<td>Cambodia</td>
			<td>1.05%</td>
		</tr>
		<tr>
			<td>7.</td>
			<td>Yemen</td>
			<td>0.63%</td>
		</tr>
		<tr>
			<td>8.</td>
			<td>Taiwan</td>
			<td>0.62%</td>
		</tr>
		<tr>
			<td>9.</td>
			<td>Pakistan</td>
			<td>0.57%</td>
		</tr>
		<tr>
			<td>10.</td>
			<td>Bangladesh</td>
			<td>0.54%</td>
		</tr>
	</tbody>
</table>

This data is summarized in the map below:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6ebd221a-5edf-4d77-b029-92c8649a843b/ie8-usage-asia.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6ebd221a-5edf-4d77-b029-92c8649a843b/ie8-usage-asia.png" sizes="100vw" caption="Iran, Turkmenistan and Afghanistan in the Middle East, and China, North Korea & Cambodia in the Far East stand out for their IE8 usage. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6ebd221a-5edf-4d77-b029-92c8649a843b/ie8-usage-asia.png'>Large preview</a>)" alt="Graph showing IE8 breakdown in Asia" >}}

Incredibly, IE8 makes up around 4% of desktop users in Iran &mdash; _forty times_ the proportion of IE8 users in Oceania.

Next, I looked at the country stats for Africa, as it had around the same overall IE8 usage as Asia. There was a clear winner (Eritrea), followed by a number of countries above or around the 1% usage mark:

<table>
	<tbody>
		<tr>
			<td>1.</td>
			<td>Eritrea</td>
			<td>3.24%</td>
		</tr>
		<tr>
			<td>2.</td>
			<td>Botswana</td>
			<td>1.37%</td>
		</tr>
		<tr>
			<td>3.</td>
			<td>Sudan & South Sudan</td>
			<td>1.33%</td>
		</tr>
		<tr>
			<td>4.</td>
			<td>Niger</td>
			<td>1.29%</td>
		</tr>
		<tr>
			<td>5.</td>
			<td>Mozambique</td>
			<td>1.19%</td>
		</tr>
		<tr>
			<td>6.</td>
			<td>Mauritania</td>
			<td>1.18%</td>
		</tr>
		<tr>
			<td>7.</td>
			<td>Guinea</td>
			<td>1.12%</td>
		</tr>
		<tr>
			<td>8.</td>
			<td>Democratic Republic of the Congo</td>
			<td>1.07%</td>
		</tr>
		<tr>
			<td>9.</td>
			<td>Zambia</td>
			<td>0.94%</td>
		</tr>
	</tbody>
</table>

This is summarized in the map below:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fbfdf71e-401b-409c-b44e-0e6b70e2f8d5/ie8-usage-africa.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fbfdf71e-401b-409c-b44e-0e6b70e2f8d5/ie8-usage-africa.png" sizes="100vw" caption="Eritrea stands out for its IE8 usage (3.24%). A number of other countries also have >1% usage. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fbfdf71e-401b-409c-b44e-0e6b70e2f8d5/ie8-usage-africa.png'>Large preview</a>)" alt="Graph showing IE8 breakdown in Africa" >}}

Whereas the countries in Asia that have higher-than-normal IE8 usage are roughly batched together geographically, there doesn’t appear to be a pattern in Africa. The only pattern I can see &mdash; unless it’s a coincidence &mdash; is that a number of the world’s largest IE8 using countries famously censor internet access, and therefore probably don’t encourage or allow updating to more secure browsers.

If your site is aimed at a purely Western audience, you’re unlikely to care much about IE8. If, however, you have a burgeoning Asian or African market &mdash; and particularly if you care about users in China, Iran or Eritrea &mdash; you might very well care about your website’s IE8 experience. Yes &mdash; even in 2019!

{{% ad-panel-leaderboard %}}

## Who’s Still Using IE?

So, who _are_ these people? Do they really walk among us?!

Whoever they are, you can bet they’re not using an old browser just to annoy you. Nobody _deliberately chooses_ a worse browsing experience.

Someone might be using an old browser due to the following reasons:

- **Lack of awareness**  
They simply aren’t aware that they’re using outdated technology.
- **Lack of education**  
They don’t know the upgrade options and alternative browsers open to them.
- **Lack of planning**  
Dismissing upgrade prompts because they’re busy, but not having the foresight to upgrade during quieter periods.
- **Aversion to change**  
The last time they upgraded their software, they had to learn a new UI. “If it ain’t broke, don’t fix it.”
- **Aversion to risk**  
The last time they upgraded, their machine slowed to a crawl, or they lost their favorite feature.
- **Software limitation**  
Their OS is too old to let them upgrade, or their admin privileges may be locked down.
- **Hardware limitation**  
Newer browsers are generally more demanding of your hard disk space, memory and CPU.
- **Network limitation**  
A capped data allowance or slow connection mean they [don’t want to download 75MB of software](https://www.google.co.uk/chrome/).
- **Legal limitation**  
They might be on a corporate machine that only condones the use of one specific browser.

Is it really such a surprise that there are still people around the world who are clinging to IE8?

I decided to put myself in the shoes of one of these anonymous souls, and browse the web for a day using IE8. You can play along at home! Download an [“IE8 on Windows 7” Virtual Machine from the Microsoft website](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/), then run it in a virtualizer like [VirtualBox](https://www.virtualbox.org/).

## IE8 VM: Off To A Bad Start

I booted up my IE8 VM, clicked on the Internet Explorer program in anticipation, and this is what I saw:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/10c1a60f-7854-41f5-8c0f-264e14880178/ie8-default-error.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/10c1a60f-7854-41f5-8c0f-264e14880178/ie8-default-error.png" sizes="100vw" caption="The first thing I saw was a 404. Great. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/10c1a60f-7854-41f5-8c0f-264e14880178/ie8-default-error.png'>Large preview</a>)" alt="Screenshot of default homepage of IE8 not loading" >}}

Hmm, okay. Looks like the default web page pulled up by IE8 no longer exists. Well, that figures. Microsoft has officially stopped supporting IE8 so why should it make sure the IE8 landing page still works?

I decided to switch to the most widely used site in the world.

## Google

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/076b8f66-c4cf-4bfa-b4fc-708c6b2ad8f7/ie8-google.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/076b8f66-c4cf-4bfa-b4fc-708c6b2ad8f7/ie8-google.png" sizes="100vw" caption="The Google homepage renders fine in IE8. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/076b8f66-c4cf-4bfa-b4fc-708c6b2ad8f7/ie8-google.png'>Large preview</a>)" alt="Screenshot of Google.com" >}}

It’s a simple site, therefore difficult to get wrong &mdash; but to be fair, it’s looking great! I tried searching for something:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/899d528a-4d19-49c4-8be8-04a00a014c92/ie8-google-search-result.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/899d528a-4d19-49c4-8be8-04a00a014c92/ie8-google-search-result.png" sizes="100vw" caption="Those who have read my previous articles may notice a recurring theme here. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/899d528a-4d19-49c4-8be8-04a00a014c92/ie8-google-search-result.png'>Large preview</a>)" alt="Screenshot of Google search results for Impractical Jokers" >}}

The search worked fine, though the layout looks a bit different to what I’m used to. Then I remembered &mdash; I’d seen the same search result layout when [I used the Internet for a day with JavaScript turned off](https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/).

For reference, here is how the search results look in a modern browser with JavaScript enabled:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ced21feb-af43-4f35-9686-9d300f528be2/ie8-google-chrome-normal.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ced21feb-af43-4f35-9686-9d300f528be2/ie8-google-chrome-normal.png" sizes="100vw" caption="Cleaner layout, extra images and meta information, Netflix/Twitter integration. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ced21feb-af43-4f35-9686-9d300f528be2/ie8-google-chrome-normal.png'>Large preview</a>)" alt="Screenshot of Google Chrome search results for Impractical Jokers" >}}

So, it looks like IE8 gets the no-JS version of Google search. I don’t think this was necessarily a deliberate design decision &mdash; it could just be that the JavaScript errored out:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/85b35d9b-dd67-4901-802e-dddfd82a5844/ie8-google-search-error.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/85b35d9b-dd67-4901-802e-dddfd82a5844/ie8-google-search-error.png" sizes="100vw" caption="The page tried and failed to run JavaScript. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/85b35d9b-dd67-4901-802e-dddfd82a5844/ie8-google-search-error.png'>Large preview</a>)" alt="Screenshot of Google search error “Object doesn’t support this property or method”" >}}

Still, the end result is fine by me &mdash; I got my search results, which is all I wanted.

I clicked through to watch a YouTube video.

## YouTube

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ba3fca5-607b-4456-bf93-b7686230c5c7/ie8-youtube-video-error.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ba3fca5-607b-4456-bf93-b7686230c5c7/ie8-youtube-video-error.png" sizes="100vw" caption="Funky logo, no images for related videos, and unsurprisingly, no video. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ba3fca5-607b-4456-bf93-b7686230c5c7/ie8-youtube-video-error.png'>Large preview</a>)" alt="Screenshot of buggy YouTube video page" >}}

There’s quite a lot broken about this page. All to do with little quirks in IE.

The logo, for instance, is zoomed in and cropped. This is down to IE8 not supporting SVG, and what we’re actually seeing is the fallback option provided by YouTube. They’ve applied a `background-image` CSS property so that in the event of no SVG support, you’ll get an attempt at displaying the logo. Only they seem to have not set the `background-size` properly, so it’s a little too far zoomed in.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ebc028ba-e17e-4463-b8c5-1e4a6b7f4948/ie8-youtube-background-img.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ebc028ba-e17e-4463-b8c5-1e4a6b7f4948/ie8-youtube-background-img.png" sizes="100vw" caption="YouTube set a <code>background-img</code> on the logo <code>span</code>, which pulls in a sprite. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ebc028ba-e17e-4463-b8c5-1e4a6b7f4948/ie8-youtube-background-img.png'>Large preview</a>)" alt="Screenshot of YouTube logo in IE8 and Developer Tools inspecting it" >}}

For reference, here is the same page in Chrome (see how Chrome renders an SVG instead):

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d427783c-647e-41be-8b1e-0eee06bf0167/ie8-chrome-renders-svg.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d427783c-647e-41be-8b1e-0eee06bf0167/ie8-chrome-renders-svg.png" sizes="100vw" caption="(<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d427783c-647e-41be-8b1e-0eee06bf0167/ie8-chrome-renders-svg.png'>Large preview</a>)" alt="Screenshot of Chrome DevTools inspecting YouTube logo" >}}

And what about that Autoplay toggle? It’s rendered like a weird looking checkbox:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/836c4934-bcd9-462d-960d-b972e1cdc5c8/ie8-screenshot-autoplay-toggle.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/854e137e-db19-486f-b8aa-6ce7ef9ffc0f/ie8-screenshot-autoplay-toggle-small.png" sizes="100vw" caption="Looks like IE8 defaults to a checkbox under the hood. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/836c4934-bcd9-462d-960d-b972e1cdc5c8/ie8-screenshot-autoplay-toggle.png'>Large preview</a>)" alt="Screenshot of Autoplay toggle" >}}

This appears to be down to use of a custom element (a [paper-toggle-button](https://www.webcomponents.org/element/@polymer/paper-toggle-button), which is a Material Design element), which IE doesn’t understand:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/14808816-ef7e-41b8-8b94-da90ab501c5e/ie8-screenshot-autoplay-toggle-markup.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/14808816-ef7e-41b8-8b94-da90ab501c5e/ie8-screenshot-autoplay-toggle-markup.png" sizes="100vw" caption="<code>paper-toggle-button</code> is a custom element. (The screenshot is from Chrome DevTools, alongside how the Autoplay toggle SHOULD render.) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/14808816-ef7e-41b8-8b94-da90ab501c5e/ie8-screenshot-autoplay-toggle-markup.png'>Large preview</a>)" alt="Screenshot of Autoplay toggle markup" >}}

I’m not surprised this hasn’t rendered properly; IE8 doesn’t even cope with the basic semantic markup we use these days. Try using an `<aside>` or `<main>` and it will basically render them as divs, but ignoring any styling you apply to them.

To enable HTML5 markup, you have to explicitly tell the browser these elements exist. They can then be styled as normal:

<pre><code class="language-html">&lt;!--[if lt IE 9]&gt;
   &lt;script&gt;
      document.createElement('header');
      document.createElement('nav');
      document.createElement('section');
      document.createElement('article');
      document.createElement('aside');
      document.createElement('footer');
   &lt;/script&gt;
&lt;![endif]--&gt;
</code></pre>

That is wrapped in an [IE conditional](https://www.quirksmode.org/css/condcom.html), by the way. `<!--[if lt IE 9]>` is a HTML comment to most browsers &mdash; and therefore gets skipped &mdash; but in IE it is a conditional which only passes “if less than IE 9”, where it executes/renders the DOM nodes within it.

So, the video page was a fail. Visiting YouTube.com directly didn’t fare much better:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cb1fcef5-b967-454c-8d47-aec2cca1f10c/ie8-youtube-search.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cb1fcef5-b967-454c-8d47-aec2cca1f10c/ie8-youtube-search.png" sizes="100vw" caption="At least I had a visible error message this time! (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cb1fcef5-b967-454c-8d47-aec2cca1f10c/ie8-youtube-search.png'>Large preview</a>)" alt="Screenshot of IE8 YouTube homepage: “Your web browser is no longer supported”" >}}

Undeterred, I ignored the warning and tried searching for a video within YouTube’s search bar.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/990b4fc3-f0d1-4323-b862-11fa48d62ccd/ie8-youtube-fail-search.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/990b4fc3-f0d1-4323-b862-11fa48d62ccd/ie8-youtube-fail-search.png" sizes="100vw" caption="Computer says no. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/990b4fc3-f0d1-4323-b862-11fa48d62ccd/ie8-youtube-fail-search.png'>Large preview</a>)" alt="Screenshot of Google “Sorry, your computer may be sending automated queries. We can't process your request”" >}}

IE8 traffic is clearly suspicious enough that YouTube didn’t trust that I’m a real user, and decided not to process my search request!

## Signing Up To Gmail

If I’m going to spend the day on IE8, I’m going to need an email address. So I go about trying to set up a new one.

First of all, I tried Gmail.

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/109776e0-f724-4596-a3ef-b33389259860/ie8-gmail-homepage-screenshot.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/109776e0-f724-4596-a3ef-b33389259860/ie8-gmail-homepage-screenshot.png" sizes="100vw" caption="The text isn’t going to pass color contrast standards! (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/109776e0-f724-4596-a3ef-b33389259860/ie8-gmail-homepage-screenshot.png'>Large preview</a>)" alt="Screenshot of Gmail homepage" >}}

There’s something a bit off about the image and text here. I think it’s down to the fact that IE8 doesn’t support media queries &mdash; so it’s trying to show me a mobile image on desktop.

One way you can get around this is to use Sass to generate two stylesheets; one for modern browsers, and one for legacy IE. You can get IE-friendly, mobile-first CSS (see [tutorial by Jake Archibald](https://jakearchibald.github.io/sass-ie/)) by using a mixin for your media queries. The mixin “flattens” your legacy IE CSS to treat IE as though it’s always a specific predefined width (e.g. 65em), giving only the relevant CSS for that width. In this case, I’d have seen the correct `background-image` for my assumed screen size and had a better experience.

Anyway, it didn’t stop me clicking ‘Create an Account’. There were a few differences between how it looked in IE8 and a modern browser:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/51e43037-7494-4347-8b9d-f18cf1c29838/ie8-gmail-signup-chrome-ie8.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/51e43037-7494-4347-8b9d-f18cf1c29838/ie8-gmail-signup-chrome-ie8.png" sizes="100vw" caption="IE8 is missing the tight layout, and there’s an overlap of text, but otherwise still works. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/51e43037-7494-4347-8b9d-f18cf1c29838/ie8-gmail-signup-chrome-ie8.png'>Large preview</a>)" alt="Screenshot comparing Gmail signup screen on Chrome and IE8" >}}

Whilst promising at first sight, the form was quite buggy to fill in. The ‘label’ doesn’t get out of the way when you start filling in the fields, so your input text is obfuscated:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/77c9cd36-4294-400b-8c90-2e9532f26453/ie8-gmail-labels.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/77c9cd36-4294-400b-8c90-2e9532f26453/ie8-gmail-labels.png" sizes="100vw" caption="The labels overlapped the text I was writing. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/77c9cd36-4294-400b-8c90-2e9532f26453/ie8-gmail-labels.png'>Large preview</a>)" alt="Screenshot of buggy labels" >}}

The markup for this label is actually a `<div>`, and some clever JS moves the text out of the way when the input is focussed. The JS doesn’t succeed on IE8, so the text stays stubbornly in place.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f8b946d3-e31a-477b-9ddd-7dc500a00071/ie8-screenshot-gmail-form-markup.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f8b946d3-e31a-477b-9ddd-7dc500a00071/ie8-screenshot-gmail-form-markup.png" sizes="100vw" caption="The ‘label’ is a <code>div</code> which is overlaid on form input using CSS. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f8b946d3-e31a-477b-9ddd-7dc500a00071/ie8-screenshot-gmail-form-markup.png'>Large preview</a>)" alt="Screenshot of gmail form markup" >}}

After filling in all my details, I hit “Next”, and waited. Nothing happened.

Then I noticed the little yellow warning symbol at the bottom left of my IE window. I clicked it and saw that it was complaining about a JS error:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/57987da8-95e7-4b41-b628-40efeb9c2655/ie8-gmail-error.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/57987da8-95e7-4b41-b628-40efeb9c2655/ie8-gmail-error.png" sizes="100vw" caption="I got reasonably far, but then the Next button didn’t work. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/57987da8-95e7-4b41-b628-40efeb9c2655/ie8-gmail-error.png'>Large preview</a>)" alt="Screenshot of Gmail error" >}}

I gave up on Gmail and turned to MSN.

## Signing Up To Hotmail

I was beginning to worry that email might be off-limits for a ten-year-old browser. But when I went to Hotmail, the signup form looked OK &mdash; so far so good:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24c1c3c9-5cde-459d-a3c9-207666791ce9/ie8-microsoft-signup.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24c1c3c9-5cde-459d-a3c9-207666791ce9/ie8-microsoft-signup.png" sizes="100vw" caption="The signup page looked fine. Guessed we’d have more luck with a Microsoft product! (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24c1c3c9-5cde-459d-a3c9-207666791ce9/ie8-microsoft-signup.png'>Large preview</a>)" alt="Screenshot of signup page for MSN" >}}

Then I noticed a CAPTCHA. I thought, “There’s no way I’ll get through this...”

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/84755078-e2c9-4db7-87a3-86ec4324b1d7/ie8-microsoft-recaptcha.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/84755078-e2c9-4db7-87a3-86ec4324b1d7/ie8-microsoft-recaptcha.png" sizes="100vw" caption="I could see and complete the CAPTCHA. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/84755078-e2c9-4db7-87a3-86ec4324b1d7/ie8-microsoft-recaptcha.png'>Large preview</a>)" alt="Screenshot of captcha verification of signup state" >}}

To my surprise, the CAPTCHA worked!

The only quirky thing on the form was some slightly buggy label positioning, but the signup was otherwise seamless:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/62e9ad9f-7e5a-4339-8ad1-b9b62f32d860/ie8-microsoft-label-positions.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/62e9ad9f-7e5a-4339-8ad1-b9b62f32d860/ie8-microsoft-label-positions.png" sizes="100vw" caption="The label positions were a bit off, but I guessed my last name followed by my surname would be fine. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/62e9ad9f-7e5a-4339-8ad1-b9b62f32d860/ie8-microsoft-label-positions.png'>Large preview</a>)" alt="Screenshot of first name label, surname label, and then two empty input fields, no clear visual hierarchy" >}}

Does that screenshot look OK to you? Can you spot the deliberate mistake?

The leftmost input should have been my _first_ name, not my surname. When I came back and checked this page later, I clicked on the “First name” label and it applied focus to the leftmost input, which is how I _could_ have checked I was filling in the correct box in the first place. This shows **the importance of accessible markup** &mdash; even without CSS and visual association, I could determine exactly which input box applied to which label (albeit the second time around!).

Anyhow, I was able to complete the sign-up process and was redirected to the MSN homepage, which rendered great.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/63fd9c7c-b22e-4fdb-b00e-0ba4e17984da/ie8-msn-homepage-success-screenshot.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/63fd9c7c-b22e-4fdb-b00e-0ba4e17984da/ie8-msn-homepage-success-screenshot.png" sizes="100vw" caption="If any site is going to work in IE8, it will be the Microsoft homepage. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/63fd9c7c-b22e-4fdb-b00e-0ba4e17984da/ie8-msn-homepage-success-screenshot.png'>Large preview</a>)" alt="Screenshot of MSN homepage looking good" >}}

I could even read articles and forget that I was using IE8:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6eb070fb-9d53-4a56-bc19-40b76848a37e/ie8-msn-article-screenshot.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6eb070fb-9d53-4a56-bc19-40b76848a37e/ie8-msn-article-screenshot.png" sizes="100vw" caption="The article works fine. No dodgy sidebars or borked images. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6eb070fb-9d53-4a56-bc19-40b76848a37e/ie8-msn-article-screenshot.png'>Large preview</a>)" alt="Screenshot of MSN article" >}}

With my email registered, I was ready to go and check out the rest of the Internet!

## Facebook

I visited the Facebook site and was immediately redirected to the mobile site:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ff067567-8afb-4951-8047-d0bee6fbfefd/ie8-facebook-redirect.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ff067567-8afb-4951-8047-d0bee6fbfefd/ie8-facebook-redirect.png" sizes="100vw" caption="“You are using a browser that is not supported by Facebook, so we have redirected you to a simpler version to give you the best experience.” (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ff067567-8afb-4951-8047-d0bee6fbfefd/ie8-facebook-redirect.png'>Large preview</a>)" alt="Screenshot of Facebook mobile" >}}

This is a clever fallback tactic, as Facebook need to support a large global audience on low-end mobile devices, so need to provide a basic version of Facebook anyway. Why not offer that same baseline of experience to older desktop browsers?

I tried signing up and was able to make an account. Great! But when I logged into that account, I was treated with suspicion &mdash; just like when I searched for things on YouTube &mdash; and was faced with a CAPTCHA.

Only this time, it wasn’t so easy.

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fc263a0d-eecd-4f1e-928f-edb14652c1d5/ie8-facebook-recaptcha-fail.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fc263a0d-eecd-4f1e-928f-edb14652c1d5/ie8-facebook-recaptcha-fail.png" sizes="100vw" caption="“Please enter the code below”. Yeah, right. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fc263a0d-eecd-4f1e-928f-edb14652c1d5/ie8-facebook-recaptcha-fail.png'>Large preview</a>)" alt="Screenshot of CAPTCHA message, but CAPTCHA image failing to load" >}}

I tried requesting new codes and refreshing the page several times, but the CAPTCHA image never loaded, so I was effectively locked out of my account.

Oh well. Let’s try some more social media.

{{% ad-panel-leaderboard %}}

## Twitter

I visited the Twitter site and had exactly the same mobile redirect experience.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6573d653-e63e-4c72-b716-9a1f857b4121/ie8-twitter-redirect.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6573d653-e63e-4c72-b716-9a1f857b4121/ie8-twitter-redirect.png" sizes="100vw" caption="Twitter treats IE8 as a mobile browser, like Facebook does. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6573d653-e63e-4c72-b716-9a1f857b4121/ie8-twitter-redirect.png'>Large preview</a>)" alt="Screenshot of mobile view for Twitter" >}}

But I couldn’t even get as far as registering an account this time:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53b9f0bd-05ff-4190-8f2d-a4cd96768507/ie8-twitter-unable-to-sign-up.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53b9f0bd-05ff-4190-8f2d-a4cd96768507/ie8-twitter-unable-to-sign-up.png" sizes="100vw" caption="Your browser is no longer supported. To sign up, please update it. You can still log in to your existing user accounts. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53b9f0bd-05ff-4190-8f2d-a4cd96768507/ie8-twitter-unable-to-sign-up.png'>Large preview</a>)" alt="Screenshot of Twitter registration screen" >}}

Oddly, Twitter is happy for you to log in, but not for you to register in the first place. I’m not sure why &mdash; perhaps it has a similar CAPTCHA scenario on its sign-up pages which won’t work on older browsers. Either way, I’m not going to be able to make a new account.

I felt awkward about logging in with my existing Twitter account. Call me paranoid, but vulnerabilities like the [CFR Watering Hole Attack](https://searchsecurity.techtarget.com/tip/Defending-against-watering-hole-attacks-Consider-using-a-secure-VM) of 2013 &mdash; where the mere act of visiting a specific URL in IE8 would install malware to your machine &mdash; had me nervous that I might compromise my account.

But, in the interests of education, I persevered (with a temporary new password):

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/de2a173c-f0e5-4f23-b683-30f1a5477c37/ie8-twitter-logged-in.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/de2a173c-f0e5-4f23-b683-30f1a5477c37/ie8-twitter-logged-in.png" sizes="100vw" caption="Successfully logged in. I can see tweets! (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/de2a173c-f0e5-4f23-b683-30f1a5477c37/ie8-twitter-logged-in.png'>Large preview</a>)" alt="Screenshot of Twitter feed" >}}

I could also tweet, albeit using the very basic `<textarea>`:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cf8193e9-aae5-4ac6-8989-4fcff1568c3c/ie8-twitter-tweet.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cf8193e9-aae5-4ac6-8989-4fcff1568c3c/ie8-twitter-tweet.png" sizes="100vw" caption="You only miss them when they’re gone. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cf8193e9-aae5-4ac6-8989-4fcff1568c3c/ie8-twitter-tweet.png'>Large preview</a>)" alt="Screenshot of me writing a tweet, lamenting about the lack of emojis in the IE8 twitter view" >}}

In conclusion, Twitter is basically fine in IE8 &mdash; as long as you have an account already!

I’m done with social media for the day. Let’s go check out some news.

## BBC News

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68e54abc-73c1-4595-a829-93d2d2684938/ie8-bbc-https.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68e54abc-73c1-4595-a829-93d2d2684938/ie8-bbc-https.png" sizes="100vw" caption="The BBC appears to be loading a mixture of HTTPS and HTTP assets. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68e54abc-73c1-4595-a829-93d2d2684938/ie8-bbc-https.png'>Large preview</a>)" alt="Screenshot of BBC homepage with “Security Warning” browser popup" >}}

The news homepage looks very basic and clunky but basically works &mdash; albeit with mixed content security warnings.

Take a look at the logo. As we’ve already seen on YouTube, IE8 doesn’t support SVG, so we require a PNG fallback.

The BBC uses the `<image>` fallback technique to render a PNG on IE:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d1a8460d-6f03-44a2-906f-3f19c4356963/ie8-bbc-devtools.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d1a8460d-6f03-44a2-906f-3f19c4356963/ie8-bbc-devtools.png" sizes="100vw" caption="IE8 finds the base64 image inside the SVG and renders it. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d1a8460d-6f03-44a2-906f-3f19c4356963/ie8-bbc-devtools.png'>Large preview</a>)" alt="Screenshot of IE8 BBC News logo with devtools open" >}}

...and to ignore the PNG when SVG is available:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1034710-fd70-4a4d-a458-1c45de9f7bfe/ie8-bbc-news-logo-devtools-chrome-svg.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1034710-fd70-4a4d-a458-1c45de9f7bfe/ie8-bbc-news-logo-devtools-chrome-svg.png" sizes="100vw" caption="The <code>image</code> part is ignored and the <code>svg</code> is rendered nicely. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1034710-fd70-4a4d-a458-1c45de9f7bfe/ie8-bbc-news-logo-devtools-chrome-svg.png'>Large preview</a>)" alt="Screenshot of Chrome BBC News logo with devtools open" >}}

This technique exploits the fact that older browsers used to obey both `<image>` and `<img>` tags, and so will ignore the unknown `<svg>` tag and render the fallback, whereas modern browsers ignore rendering `<image>` when inside an SVG. [Chris Coyier explains the technique in more detail](https://css-tricks.com/svg-fallbacks/).

I tried viewing an article:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4601d43e-e8ff-4702-b0c2-7f32a6e9833b/ie8-bbc-article.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4601d43e-e8ff-4702-b0c2-7f32a6e9833b/ie8-bbc-article.png" sizes="100vw" caption="This site is optimised for modern browsers, and does not fully support your browser. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4601d43e-e8ff-4702-b0c2-7f32a6e9833b/ie8-bbc-article.png'>Large preview</a>)" alt="Screenshot of a BBC article, which displays fine but has a warning message at the top" >}}

It’s readable. I can see the headline, the navigation, the featured image. But the rest of the article images are missing:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/970bcd5b-cd56-42ec-be66-5d50263d726e/ie8-bbc-article-missing-img.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/970bcd5b-cd56-42ec-be66-5d50263d726e/ie8-bbc-article-missing-img.png" sizes="100vw" caption="(<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/970bcd5b-cd56-42ec-be66-5d50263d726e/ie8-bbc-article-missing-img.png'>Large preview</a>)" alt="Screenshot of BBC article with references to images that are not displaying" >}}

This is to be expected, and is due to the BBC lazy-loading images. IE8 not being a ‘supported browser’ means it does not get the JavaScript that enables lazy-loading, thus the images never load at all.

Out of interest, I thought I’d see what happens if I try to access the BBC iPlayer:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/659f6ee3-1f93-4c8d-8e7c-65de71b05c2c/ie8-bbc-iplayer.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/659f6ee3-1f93-4c8d-8e7c-65de71b05c2c/ie8-bbc-iplayer.png" sizes="100vw" caption="...not a lot. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/659f6ee3-1f93-4c8d-8e7c-65de71b05c2c/ie8-bbc-iplayer.png'>Large preview</a>)" alt="Screenshot of BBC iPlayer - just a black screen" >}}

And that got me wondering about another streaming service.

## Netflix

I was half expecting an empty white page when I loaded up Netflix in IE8. I was pleasantly surprised when I actually saw a decent landing page:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7ba01f80-8787-4bc7-97e8-8da80d30db4d/ie8-netflix-ie8.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7ba01f80-8787-4bc7-97e8-8da80d30db4d/ie8-netflix-ie8.png" sizes="100vw" caption="“Join free for a month” call to action, over a composite image of popular titles. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7ba01f80-8787-4bc7-97e8-8da80d30db4d/ie8-netflix-ie8.png'>Large preview</a>)" alt="Screenshot of Netflix homepage" >}}

I compared this with the modern Chrome version:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24e45b09-49f0-4e02-8645-f994ff67f558/ie8-netflix-chrome-1.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24e45b09-49f0-4e02-8645-f994ff67f558/ie8-netflix-chrome-1.png" sizes="100vw" caption="“Watch free for 30 days” call to action, over a composite image of popular titles. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24e45b09-49f0-4e02-8645-f994ff67f558/ie8-netflix-chrome-1.png'>Large preview</a>)" alt="Screenshot of Netflix homepage" >}}

There’s a slightly different call to action (button text) &mdash; probably down to [multivariate testing](https://www.optimizely.com/optimization-glossary/multivariate-testing/) rather than what browser I’m on.

What’s different about the render is the centralized text and the semi-transparent black overlay.

The lack of centralized text is because of Netflix’s use of Flexbox for aligning items:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4b6d8d0d-84d2-480c-b8c0-e2c29d335112/ie8-netfliy-flexbox-aligning-items.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4b6d8d0d-84d2-480c-b8c0-e2c29d335112/ie8-netfliy-flexbox-aligning-items.png" sizes="100vw" caption="Netflix uses the Flexbox property <code>justify-content: center</code> to align its text. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4b6d8d0d-84d2-480c-b8c0-e2c29d335112/ie8-netfliy-flexbox-aligning-items.png'>Large preview</a>)" alt="Netflix Flexbox aligning items" >}}

A `text-align: center` on this class would probably fix the centering for IE8 (and indeed all old browsers). For maximum browser support, you can follow a CSS fallbacks approach with old ‘safe’ CSS, and then tighten up layouts with more modern CSS for browsers that support it.

The lack of background is due to use of `rgba()`, which is not supported in IE8 and below.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/56ea7d47-dd64-4433-8564-788e03985d0f/ie8-netflix-background-rgba-ie8.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/56ea7d47-dd64-4433-8564-788e03985d0f/ie8-netflix-background-rgba-ie8.png" sizes="100vw" caption="A background of <code>rgba(0,0,0,.5)</code> is meaningless to older browsers. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/56ea7d47-dd64-4433-8564-788e03985d0f/ie8-netflix-background-rgba-ie8.png'>Large preview</a>)" alt="A background of rgba(0,0,0,.5) is meaningless to older browsers" >}}

Traditionally it’s good to provide CSS fallbacks like so, which show a black background for old browsers but show semi-transparent background for modern browsers:

<pre><code class="language-css">rgb(0, 0, 0); /* IE8 fallback */
rgba(0, 0, 0, 0.8);
</code></pre>

This is a very IE specific fix, however, [basically every other browser supports `rgba`](https://caniuse.com/#feat=css3-colors). Moreover, in this case, you’d lose the fancy Netflix tiles altogether, so it would be better to have no background filter at all! The surefire way of ensuring cross-browser support would be to bake the filter into the background image itself. Simple but effective.

Anyway, so far, so good &mdash; IE8 actually rendered the homepage pretty well! Am I actually going to be watching _Breaking Bad_ on IE8 today?

My already tentative optimism was immediately shot down when I viewed the sign-in page:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8173b283-276e-4b70-9495-3c0804df8662/ie8-netflix-sign-in-combined.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8173b283-276e-4b70-9495-3c0804df8662/ie8-netflix-sign-in-combined.png" sizes="100vw" caption="Can you guess which side is IE8 and which is Chrome? (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8173b283-276e-4b70-9495-3c0804df8662/ie8-netflix-sign-in-combined.png'>Large preview</a>)" alt="Screenshot comparing sign-in page for Netflix on Chrome and IE8. IE version colors are all over the place, and it's hard to read the text" >}}

Still, I was able to sign in, and saw a pared-back dashboard (no fancy auto-expanding trailers):

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7646b2ab-c351-4550-91ba-6bd465dcff77/ie8-netflix-signed-in.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7646b2ab-c351-4550-91ba-6bd465dcff77/ie8-netflix-signed-in.png" sizes="100vw" caption="Each programme had a simple hover state with play icon and title. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7646b2ab-c351-4550-91ba-6bd465dcff77/ie8-netflix-signed-in.png'>Large preview</a>)" alt="Screenshot of Netflix dashboard for logged in user" >}}

I clicked on a programme with vague anticipation, but of course, only saw a black screen.

## Amazon

Ok, social media and video are out. All that’s left is to go shopping.

I checked out Amazon, and was blown away &mdash; it’s almost indistinguishable from the experience you’d get inside a modern browser:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d5024465-4bb6-4ef9-9df3-dee8bfe5232f/ie8-amazon.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d5024465-4bb6-4ef9-9df3-dee8bfe5232f/ie8-amazon.png" sizes="100vw" caption="The Amazon homepage looks almost as good on IE8 as it does on any other browser. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d5024465-4bb6-4ef9-9df3-dee8bfe5232f/ie8-amazon.png'>Large preview</a>)" alt="Screenshot of Amazon homepage" >}}

I’ve been drawn in by a good homepage before. So let’s click on a product page and see if this is just a fluke.

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88717791-168e-450c-9d1a-f11003760505/ie8-amazon-product-page.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88717791-168e-450c-9d1a-f11003760505/ie8-amazon-product-page.png" sizes="100vw" caption="The product page also looks fantastic (and makes me hungry). (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88717791-168e-450c-9d1a-f11003760505/ie8-amazon-product-page.png'>Large preview</a>)" alt="Screenshot of Amazon product page for Ferrero Rocher chocolates" >}}

No! The product page looked good too!

Amazon wasn’t the only site that surprised me in its backwards compatibility. Wikipedia looked great, as did the Gov.UK government website. It’s not easy to have a site that doesn’t look like an utter car crash in IE8. Most of my experiences were decidedly less polished…!

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1363c2d-a62b-4def-8714-eba176e40f07/ie8-sky-homepage-ie8.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1363c2d-a62b-4def-8714-eba176e40f07/ie8-sky-homepage-ie8.png" sizes="100vw" caption="It is difficult to read or navigate sky.com on IE8. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1363c2d-a62b-4def-8714-eba176e40f07/ie8-sky-homepage-ie8.png'>Large preview</a>)" alt="Screenshot of sky.com on IE8, layout is all over the place and text is hard to read when placed over images" >}}

But a deprecated warning notice or funky layout wasn’t the worst thing I saw today.

## Utterly Broken Sites

Some sites were *so* broken that I couldn’t even connect to them!

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/31218f1b-1b64-4a47-9589-73f9d62f21dd/ie8-github-fail.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/31218f1b-1b64-4a47-9589-73f9d62f21dd/ie8-github-fail.png" sizes="100vw" caption="No dice when accessing <a href='https://github.com'>GitHub</a>. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/31218f1b-1b64-4a47-9589-73f9d62f21dd/ie8-github-fail.png'>Large preview</a>)" alt="Screenshot: Internet Explorer cannot display the webpage" >}}

I wondered if it might be a temporary VM network issue, but it happened every time I refreshed the page, even when coming back to the same site later in the day.

This happened on a few different sites throughout the day, and I eventually concluded that this never affected sites on HTTP &mdash; *only* on HTTPS (but not *all* HTTPS sites). So, what was the problem?

Using [Wireshark](https://www.wireshark.org/) to analyze the network traffic, I tried connecting to GitHub again. We can see that the connection failed to establish because of a fatal error, “Description: Protocol Version.”

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/026101cc-4ee8-4681-9ff7-df2d95076d87/ie8-wireshark.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/026101cc-4ee8-4681-9ff7-df2d95076d87/ie8-wireshark.png" sizes="100vw" caption="TLSv1 Alert (Level: Fatal, Description: Protocol Version) (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/026101cc-4ee8-4681-9ff7-df2d95076d87/ie8-wireshark.png'>Large preview</a>)" alt="Screenshot of Wireshark output" >}}

Looking at the default settings in IE8, only TLS 1.0 is enabled &mdash; but [GitHub dropped support for TLSv1 and TLSv1.1 in February 2018](https://githubengineering.com/crypto-removal-notice/).

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1bdc0c15-7f18-446e-ae1c-cee7761d2527/ie8-default-tls.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1bdc0c15-7f18-446e-ae1c-cee7761d2527/ie8-default-tls.png" sizes="100vw" caption="Default advanced settings for IE8: TLS 1.0 is checked, TLS 1.1 and 1.2 are unchecked. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1bdc0c15-7f18-446e-ae1c-cee7761d2527/ie8-default-tls.png'>Large preview</a>)" alt="Screenshot of settings panel" >}}

I checked the boxes for TLS 1.1 and TLS 1.2, reloaded the page and &mdash; *voilà!* &mdash; I was able to view GitHub!

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c7be205e-2b29-40fd-8527-9a5aa4f90d67/ie8-tls-github.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c7be205e-2b29-40fd-8527-9a5aa4f90d67/ie8-tls-github.png" sizes="100vw" caption="It doesn’t look pretty, but at least I can now see it! (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c7be205e-2b29-40fd-8527-9a5aa4f90d67/ie8-tls-github.png'>Large preview</a>)" alt="Screenshot of GitHub homepage, with a “no longer supports Internet Explorer” message on it" >}}

Many thanks to my extremely talented friend [Aidan Fewster](https://twitter.com/fewstera) for helping me debug that issue.

I’m all for backwards compatibility, but this presents an interesting dilemma. According to the [PCI Security Standards Council](https://blog.pcisecuritystandards.org/are-you-ready-for-30-june-2018-sayin-goodbye-to-ssl-early-tls), TLS 1.0 is insecure and should no longer be used. But by forcing TLS 1.1 or higher, some users will invariably be locked out (and not all are likely to be tech-savvy enough to enable TLS 1.2 in their advanced settings).

By allowing older, insecure standards and enabling users to continue to connect to our sites, we’re not helping them &mdash; we’re hurting them, by not giving them a reason to move to safer technologies. So how far should you go in supporting older browsers?

## How Can I Begin To Support Older Browsers?

When some people think of “supporting older browsers”, they might be thinking of those proprietary old hacks for IE, like that time the BBC had to do some [incredibly gnarly things to support iframed content in IE7](https://responsivenews.co.uk/post/71845174511/responsive-iframes).

Or they may be thinking of making things work in the Internet Explorer “quirks mode”; an IE-specific mode of operation which [renders things very differently to the standards](https://jkorpela.fi/quirks-mode.html).

But “supporting older browsers” is _very_ different to “hacking it for IE”. I don’t advocate the latter, but we should pragmatically try to do the former. The mantra I try to live by as a web developer is this:

<blockquote>“Optimize for the majority, make an effort for the minority, and never sacrifice security.”</blockquote>

I’m going to move away from the world of IE8 now and talk about general, sustainable solutions for legacy browser support.

There are two broad strategies for supporting older browsers, both beginning with P:

1. **Polyfilling**  
Strive for feature parity for all by filling in the missing browser functionality.
2. **Progressive Enhancement**  
Start from a core experience, then use feature detection to layer on functionality.

These strategies are not mutually exclusive from one another; they can be used in tandem. There are a number of implementation decisions to make in either approach, each with their own nuances, which I’ll cover in more detail below.

## Polyfilling

For some websites or web pages, JavaScript is very important for functionality and you simply want to deliver working JavaScript to as many browsers as possible.

There are a number of ways to do this, but first, a history lesson.

### A Brief History Of ECMAScript

ECMAScript is a standard, and JavaScript is an implementation of that standard. That means that ES5 is “ECMAScript version 5”, and ES6 is “ECMAScript version 6”. Confusingly, ES2015 is the same as ES6.

ES6 was the popularized name of that version prior to its release, but ES2015 is the official name, and subsequent ECMAScript versions are all associated with their release year.

**Note**: *This is all helpfully explained by Brandon Morelli in a great blog post that explains [the full history of JavaScript versions](https://codeburst.io/javascript-wtf-is-es6-es8-es-2017-ecmascript-dca859e4821c).*

At time of writing, the latest standard is ES2018 (ES9). Most modern browsers support at least ES2015. Almost _every_ browser supports ES5.

Technically IE8 isn’t ES5. It isn’t even ES4 (which doesn’t exist &mdash; the project was abandoned). IE8 uses the Microsoft implementation of ECMAScript 3, called [JScript](https://docs.microsoft.com/en-us/previous-versions//hbxc2t98(v=vs.85)). IE8 does have some ES5 support but was released a few months before ES5 standards were published, and so has a mismatch of support.

### Transpiling vs Polyfilling

You can write ES5 JavaScript and it will run in almost every ancient browser:

<pre><code class="language-javascript">var foo = function () {
  return 'this is ES5!';
};
</code></pre>

You can also continue to write all of your JavaScript like that &mdash; to enable backwards compatibility forever. But you’d be missing out on new features and syntactic sugar that has become available in the evolving versions of JavaScript, allowing you to write things like:

<pre><code class="language-javascript">const foo = () => {
  return 'this is ES6!';
};
</code></pre>

Try running that JavaScript in an older browser and it will error. We need to _transpile_ the code into an earlier version of JavaScript that the browser will understand (i.e. convert our ES6 code into ES5, using automated tooling).

Now let’s say our code uses a standard ES5 method, such as `Array.indexOf`. Most browsers have a native implementation of this and will work fine, but IE8 will break. Remember IE8 was released a few months before ES5 standards were published, and so has a mismatch of support? One example of that is the `indexOf` function, which has been implemented for `String` but not for `Array`.

If we try to run the `Array.indexOf` method in IE8, it will fail. But if we’re already writing in ES5, what else can we do?

We can _polyfill_ the behavior of the missing method. Developers traditionally polyfill each feature that they need by copying and pasting code, or by pulling in external third-party polyfill libraries. Many JavaScript features have good polyfill implementations on their respective Mozilla MDN page, but it’s worth pointing out that there are multiple ways you can polyfill the same feature.

For example, to ensure you can use the `Array.indexOf` method in IE8, you would copy and paste a polyfill like this:

<div class="break-out">

 <pre><code class="language-javascript">if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = (function (Object, max, min) {
    // big chunk of code that replicates the behaviour in JavaScript goes here!
    // for full implementation, visit:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexof#Polyfill
  })(Object, Math.max, Math.min);
}
</code></pre>
</div>

So long as you call the polyfill before you pull in any of your own JS, and provided you don’t use any ES5 JavaScript feature other than `Array.indexOf`, your page would work in IE8.

Polyfills can be used to plug all sorts of missing functionality. For example, there are [polyfills for enabling CSS3 selectors](https://github.com/keithclark/selectivizr) such as `:last-child` (unsupported in IE8) or [the `placeholder` attribute](https://github.com/ginader/HTML5-placeholder-polyfill) (unsupported in IE9).

Polyfills vary in size and effectiveness and sometimes have dependencies on external libraries such as jQuery.

You may also hear of “shims” rather than “polyfills”. Don’t get too hung up on the naming &mdash; people use the two terms interchangeably. But technically speaking, a shim is code that intercepts an API call and provides a layer of abstraction. A polyfill is a _type of shim_, in the _browser_. It specifically uses JavaScript to retrofit new HTML/CSS/JS features in older browsers.

Summary of the “manually importing polyfills” strategy:

- ✅ Complete control over choice of polyfills;
- ✅ Suitable for basic websites;
- ⚠️ Without additional tooling, you’re forced to write in native ES5 JavaScript;
- ⚠️ Difficult to micromanage all of your polyfills;
- ⚠️ Out of the box, all your users will get the polyfills, whether they need them or not.

### Babel Polyfill

I’ve talked about transpiling ES6 code down to ES5. You do this using a _transpiler_, the most popular of which is Babel.

Babel is configurable via a `.babelrc` file in the root of your project. In it, you point to various Babel plugins and presets. There’s typically one for each syntax transform and browser polyfill you’ll need.

Micromanaging these and keeping them in sync with your browser support list can be a pain, so the standard setup nowadays is to delegate that micromanagement to the [@babel/preset-env](https://babeljs.io/docs/en/next/babel-preset-env.html) module. With this setup, you simply give Babel a list of browser versions you want to support, and it does the hard work for you:

<pre><code class="language-javascript">{
  "presets": [
    [
      "@babel/preset-env",
      {
        "useBuiltIns": "usage",
        "targets": {
          "chrome": "58",
          "ie": "11"
        }
      }
    ]
  ]
}
</code></pre>

The [`useBuiltIns` configuration option](https://babeljs.io/docs/en/next/babel-preset-env.html#usebuiltins) of `@babel/preset-env` is where the magic happens, in combination with an `import "@babel/polyfill"` (another module) in the entry point of your application.

- When omitted, `useBuiltIns` does nothing. The entirety of `@babel/polyfill` is included with your app, which is pretty heavy.
- When set to `"entry"`, it converts the `@babel/polyfill` import into multiple, smaller imports, importing the minimum polyfills required to polyfill the targeted browsers you’ve listed in your `.babelrc` (in this example, Chrome 58 and IE 11).
- Setting to `"usage"` takes this one step further by [doing code analysis and only importing polyfills for features that are actually being _used_](https://babeljs.io/blog/2018/08/27/7.0.0#automatic-polyfilling-experimental). It’s classed as “experimental” but errs on the side of “polyfill too much” rather than “too little”. In any case, I don’t see how it’s possible that it would create a bigger bundle than `"entry"` or `false`, so is a good option to choose (and is [the way we’re going at the BBC](https://github.com/bbc/simorgh/pull/1312)).

Using Babel, you can transpile and polyfill your JavaScript prior to deploying to production, and target support in a specific minimum baseline of browsers. NB, another popular tool is [TypeScript](https://www.typescriptlang.org/), which has its own transpiler that transpiles to ES3, in theory supporting IE8 out of the box.

Summary of using `@babel/preset-env` for polyfilling:

- ✅ Delegate micromanagement of polyfills to a tool;
- ✅ Automated tool helps prevent inclusion of polyfills you don’t need;
- ✅ Scales to larger, complex sites;
- ⚠️ Out of the box, all your users will get the polyfills, whether they need them or not;
- ⚠️ Difficult to keep sight of exactly what’s being pulled into your application bundle.

### Lazy Loading Polyfills With Webpack And Dynamic Imports

It is possible to leverage the new `import()` proposal to feature-detect and dynamically download polyfills prior to initializing your application. It looks something like this in practice:

<div class="break-out">

 <pre><code class="language-javascript">import app from './app.js';

const polyfills = [];

if (!window.fetch) {
  polyfills.push(import(/* webpackChunkName: "polyfill-fetch" &#42;/ 'whatwg-fetch'));
}

Promise.all(polyfills)
  .then(app)
  .catch((error) => {
    console.error('Failed fetching polyfills', error);
  });
</code></pre>
</div>

This example code is shamelessly copied from the very good article, “[Lazy Loading Polyfills With Webpack And Dynamic Imports](https://itnext.io/lazy-loading-polyfills-4b85c4951e73)” that delves into the technique in more detail.

Summary:

- ✅ Doesn’t bloat modern browsers with unnecessary polyfills;
- ⚠️ Requires manually managing each polyfill.

### polyfill.io

[polyfill.io](https://polyfill.io/) is polyfilling as a service, built by the Financial Times. It works by your page making a single script request to polyfill.io, optionally listing the specific features you need to polyfill. Their server then analyzes the user agent string and populates the script accordingly. This saves you from having to manually provide your own polyfill solutions.

Here is the JavaScript that polyfill.io returns for a request made from IE8:

{{< rimg breakout="true" href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3745771b-093a-4817-aaa4-7deffb239eb6/ie8-js-code-polyfill-date-now-behavior.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3745771b-093a-4817-aaa4-7deffb239eb6/ie8-js-code-polyfill-date-now-behavior.png" sizes="100vw" caption="Lots of JS code to polyfill standard ES5 methods in IE8. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3745771b-093a-4817-aaa4-7deffb239eb6/ie8-js-code-polyfill-date-now-behavior.png'>Large preview</a>)" alt="Screenshot of response from polyfill.io service for IE8" >}}

Here’s the same polyfill.io request, but where the request came from modern Chrome:

{{< rimg href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0e342cab-f6fc-40a2-8383-ae98de00d7fb/ie8-no-js-code-just-js-comment.png" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0e342cab-f6fc-40a2-8383-ae98de00d7fb/ie8-no-js-code-just-js-comment.png" sizes="100vw" caption="No JS code, just a JS comment. (<a href='https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0e342cab-f6fc-40a2-8383-ae98de00d7fb/ie8-no-js-code-just-js-comment.png'>Large preview</a>)" alt="Screenshot of response from polyfill.io service for Chrome - no polyfill was required" >}}

All that’s required from your site is a single script call.

Summary:

- ✅ Ease of inclusion into your web app;
- ✅ Delegates responsibility of polyfill knowledge to a third party;
- ⚠️ On the flipside, you’re now reliant on a third-party service;
- ⚠️ Makes a blocking `<script>` call, even for modern browsers that don’t need any polyfills.

## Progressive Enhancement

Polyfilling is an incredibly useful technique for supporting older browsers, but can be a bloat to web pages and is limited in scope.

The progressive enhancement technique, on the other hand, is a great way of guaranteeing a basic experience for _all_ browsers, whilst retaining full functionality for your users on modern browsers. It should be achievable on most sites.

The principle is this: start from a baseline of HTML (and styling, optional), and “progressively enhance” the page with JavaScript functionality. The benefit is that if the browser is a legacy one, or if the JavaScript is broken at any point in its delivery, your site should still be functional.

The term “progressive enhancement” is often used interchangeably with “[unobtrusive JavaScript](https://blog.teamtreehouse.com/unobtrusive-javascript-important)“. They do mean essentially the same thing, but the latter takes it a little further in that you shouldn’t litter your HTML with lots of attributes, IDs and classes that are only used by your JavaScript.

### Cut-The-Mustard

The [BBC technique of “cutting the mustard”](https://responsivenews.co.uk/post/18948466399/cutting-the-mustard) (CTM) is a tried and tested implementation of progressive enhancement. The principle is that you write a solid baseline experience of HTML, and before downloading any enhancing JavaScript, you check for a minimum level of support. The original implementation checked for the presence of standard HTML5 features:

<pre><code class="language-javascript">if ('querySelector' in document
  && 'localStorage' in window
  && 'addEventListener' in window) {
    // Enhance for HTML5 browsers
}
</code></pre>

<p>As new features come out and older browsers become increasingly antiquated, our cuts the mustard baseline will change. For instance, new JavaScript syntax such as ES6 arrow functions would mean this inline CTM check fails to even <em>parse</em> in legacy browsers &mdash; not even safely executing and failing the CTM check &mdash; so may have unexpected side-effects such as breaking other third-party JavaScript (e.g. Google Analytics).</p>

To avoid even attempting to parse untranspiled, modern JS, we can apply this “modern take” on the CTM technique, taken from [@snugug’s blog](https://snugug.com/musings/modern-cutting-the-mustard/), in which we take advantage of the fact that older browsers don’t understand the `type="module"` declaration and will safely skip over it. In contrast, modern browsers will ignore `<script nomodule>` declarations.

<pre><code class="language-html">&lt;script type="module" src="./mustard.js"&gt;&lt;/script&gt;
&lt;script nomodule src="./no-mustard.js"&gt;&lt;/script&gt;

&lt;!-- Can be done inline too --&gt;

&lt;script type="module"&gt;
  import mustard from './mustard.js';
&lt;/script&gt;

&lt;script nomodule type="text/javascript"&gt;
  console.log('No Mustard!');
&lt;/script&gt;
</code></pre>

This approach is a good one, provided you’re happy treating ES6 browsers as your new minimum baseline for functionality ([~92% of global browsers at the time of writing](https://caniuse.com/#feat=es6)).

However, just as the world of JavaScript is evolving, so is the world of CSS. Now that we have Grid, Flexbox, CSS variables and the like (each with a varying efficacy of fallback), there’s no telling what combination of [CSS support](https://www.smashingmagazine.com/2019/02/css-browser-support/) an old browser might have that might lead to a mishmash of “modern” and “legacy” styling, the result of which looks broken. Therefore, sites are increasingly choosing to CTM their _styling_, so now HTML is the core baseline, and both CSS and JS are treated as enhancements.

The JavaScript-based CTM techniques we’ve seen so far have a couple of downsides if you use the presence of JavaScript to apply CSS in any way:

1. Inline JavaScript is blocking. Browsers must download, parse and execute your JavaScript before you get any styling. Therefore, users may see a [flash of unstyled text](https://css-tricks.com/fout-foit-foft/).
2. Some [users may have modern browsers, but choose to disable JavaScript](https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/). A JavaScript-based CTM prevents them from getting a styled site even when they’re perfectly capable of getting it.

The ‘ultimate’ approach is to [use CSS media queries as your cuts-the-mustard litmus test](https://www.sitepoint.com/cutting-the-mustard-with-css-media-queries/). This “CSSCTM” technique is actively in use on sites such as [Springer Nature](https://github.com/springernature/frontend-playbook/blob/master/practices/graded-browser-support.md).

<div class="break-out">

 <pre><code class="language-html">&lt;head&gt;
  &lt;!-- CSS-based cuts-the-mustard --&gt;
  &lt;!-- IMPORTANT: the JS depends on having this rule somewhere in the CSS: `body { clear: both }` --&gt;
  &lt;link rel="stylesheet" href="mq-test.css"
      media="only screen and (min-resolution: 0.1dpcm),
      only screen and (-webkit-min-device-pixel-ratio:0)
      and (min-color-index:0)"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- content here... --&gt;
  &lt;script&gt;
    (function () { // wrap in an IIFE to prevent global scope pollution
      function isSupported () {
        var val = '';
        if (window.getComputedStyle) {
          val = window.getComputedStyle(document.body, null).getPropertyValue('clear');
        } else if (document.body.currentStyle) {
          val = document.body.currentStyle.clear;
        }
        if (val === 'both') { // references the `body { clear: both; }` in the CSS
          return true;
        }
        return false;
      }
      if (isSupported()) {
        // Load or run JavaScript for supported browsers here.
      }
    })();
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</div>

This approach is quite brittle &mdash; accidentally overriding the `clear` property on your `body` selector would ‘break’ your site &mdash; but it does offer the best performance. This particular implementation uses media queries that are only supported in at least IE 9, iOS 7 and Android 4.4, which is quite a sensible modern baseline.

“Cuts the mustard”, in all its various guises, accomplishes two main principles:

1.  Widespread user support;
2.  Efficiently applied dev effort.

It’s simply not possible for sites to accommodate every single browser / operating system / network connection / user configuration combination. Techniques such as cuts-the-mustard help to rationalize browsers into C-grade and A-grade browsers, according to the [Graded Browser Support](https://github.com/yui/yui3/wiki/Graded-Browser-Support) model by *Yahoo!*.

### Cuts-The-Mustard: An Anti-Pattern?

There is an argument that applying a global, binary decision of “core” vs “advanced” is not the best possible experience for our users. It provides sanity to an otherwise daunting technical problem, but what if a browser supports 90% of the features in your global CTM test, and this specific page doesn’t even make use of the 10% of the features it fails on? In this case, the user would get the core experience, since the CTM check would have failed. But we could have given them the full experience.

And what about cases where the given page _does_ make use of a feature the browser doesn’t support? Well, in the move towards componentization, we could have a feature-specific fallback (or [error boundary](https://reactjs.org/docs/error-boundaries.html)), rather than a page-level fallback.

We do this every day in our web development. Think of pulling in a web font; [different browsers have different levels of font support](https://css-tricks.com/understanding-web-fonts-getting/). What do we do? We provide a few font file variations and let the browser decide which to download:

<pre><code class="language-css">@font-face {
  font-family: FontName;
  src: url('path/filename.eot');
  src: url('path/filename.eot?#iefix') format('embedded-opentype'),
    url('path/filename.woff2') format('woff2'),
    url('path/filename.woff') format('woff'),
    url('path/filename.ttf') format('truetype');
}
</code></pre>

We have a similar fallback with HTML5 video. Modern browsers will choose which video format they want to use, whereas legacy browsers that don’t understand what a `<video>` element is will simply render the fallback text:

<pre><code class="language-html">&lt;video width="400" controls&gt;
  &lt;source src="mov_bbb.mp4" type="video/mp4"&gt;
  &lt;source src="mov_bbb.ogg" type="video/ogg"&gt;
  Your browser does not support HTML5 video.
&lt;/video&gt;
</code></pre>

The nesting approach we saw earlier used by the BBC for PNG fallbacks for SVG is the basis for the `<picture>` responsive image element. Modern browsers will render the best fitting image based on the `media` attribute supplied, whereas legacy browsers that don’t understand what a `<picture>` element is will render the `<img>` fallback.

<pre><code class="language-html">&lt;picture&gt;
  &lt;source media="(min-width: 650px)" srcset="img_pink_flowers.jpg"&gt;
  &lt;source media="(min-width: 465px)" srcset="img_white_flower.jpg"&gt;
  &lt;img src="img_orange_flowers.jpg" alt="Flowers" style="width:auto;"&gt;
&lt;/picture&gt;
</code></pre>

The HTML spec has carefully evolved over the years to provide a basic fallback mechanism for *all* browsers, whilst allowing features and optimisations for the modern browsers that understand them.

We could apply a similar principle to our JavaScript code. Imagine a Feature like so, where the `foo` method contains some complex JS:

<pre><code class="language-javascript">class Feature {
  browserSupported() {
    return ('querySelector' in document); // internal cuts-the-mustard goes here
  }

  foo() {
    // etc
  }
}

export default new Feature();
</code></pre>

Before calling `foo`, we check if the Feature is supported in this browser by calling its `browserSupported` method. If it’s not supported, we don’t even attempt to call the code that would otherwise have errored our page.

<div class="break-out">

 <pre><code class="language-javascript">import Feature from './feature';

if (Feature.browserSupported()) {
  Feature.foo();
}
</code></pre>
</div>

This technique means we can avoid pulling in polyfills and just go with what’s natively supported by each individual browser, gracefully degrading individual features if unsupported.

Note that in the example above, I’m assuming the code gets transpiled to ES5 so that the _syntax_ is understood by all browsers, but I’m not assuming that any of the code is _polyfilled_. If we wanted to avoid transpiling the code, we could apply the same principle but using the `type="module"` take on cuts-the-mustard, but it comes with the caveat that it already has a minimum ES6 browser requirement, so is only likely to start being a good solution in a couple of years:

<pre><code class="language-html">&lt;script type="module"&gt;
  import Feature from './feature.js';
  if (Feature.browserSupported()) {
    Feature.foo();
  }
&lt;/script&gt;
</code></pre>

We’ve covered HTML, and we’ve covered JavaScript. We can apply localized fallbacks in CSS too; [there’s a `@supports` keyword in CSS](https://alligator.io/css/feature-detection-css/), which allows you to conditionally apply CSS based on the presence or absence of support for a CSS feature. However, it is ironically caveated with the fact that it is not universally supported. It just needs careful application; there’s a great [Mozilla blog post on how to use feature queries in CSS](https://hacks.mozilla.org/2016/08/using-feature-queries-in-css/).

In an ideal world, we shouldn’t need a global cuts-the-mustard check. Instead, each individual HTML, JS or CSS feature should be self-contained and have its own error boundaries. In a world of web components, shadow DOM and custom elements, I expect we’ll see more of a shift to this sort of approach. But it does make it much more difficult to predict and to test your site as a whole, and there may be unintended side-effects if, say, the styling of one component affects the layout of another.

### Two Main Backwards Compatibility Strategies

A summary of **polyfilling as a strategy**:

- ✅ Can deliver client-side JS functionality to most users.
- ✅ Can be easier to code when delegating the problem of backwards-compatibility to a polyfill.
- ⚠️ Depending on implementation, could be detrimental to performance for users who don’t need polyfills.
- ⚠️ Depending on complexity of application and age of browser, may require lots of polyfills, and therefore run very poorly. We risk shipping megabytes of polyfills to the very browsers least prepared to accept it.

A summary of **progressive enhancement as a strategy**:

- ✅ Traditional CTM makes it easy to segment your code, and to manually test.
- ✅ Guaranteed baseline of experience for all users.
- ⚠️ Might unnecessarily deliver the core experience to users who could handle the advanced experience.
- ⚠️ Not well suited to sites that require client-side JS for functionality.
- ⚠️ Sometimes difficult to balance a robust progressive enhancement strategy with a performant first render. There’s a risk of over-prioritizing the ‘core’ experience to the detriment of the 90% of your users who get the ‘full’ experience (e.g. providing small images for noJS and then replacing with high-res images on lazy-load means we’ve wasted a lot of download capacity on assets that are never even viewed).

### Conclusion

IE8 was once a cutting edge browser. (No, seriously.) The same could be said for Chrome and Firefox today.

If today’s websites are totally unusable in IE8, the websites in ten years time’ are likely to be about as unusable in today’s modern browsers &mdash; despite being built upon the open technologies of HTML, CSS, and JavaScript.

Stop and think about that for a moment. Isn’t it a bit scary? (That said, if you can’t abandon browsers after ten years and after the company who built it has deprecated it, when can you?)

IE8 is today’s scapegoat. Tomorrow it’ll be IE9, next year it’ll be Safari, a year later it might be Chrome. You can swap IE8 out for ‘old browser of choice’. The point is, there will always be some divide between what browsers developers build for, and what browsers people are using. We should stop scoffing at that and **start investing in robust, inclusive engineering solutions**. The side effects of these strategies tend to pay dividends in terms of accessibility, performance and network resilience, so there’s a bigger picture at play here.

We tend not to think about screen reader numbers. We simply take it for granted that it’s morally right to do our best to support users who have no other way of consuming our content, through no fault of our own. The same principle applies to people using older browsers.

We’ve covered some high-level strategies for building robust sites that should continue to work, to some degree, across a broad spectrum of legacy and modern browsers.

Once again, a disclaimer: *don’t* hack things for IE. That would be missing the point. But be mindful that all sorts of people use all sorts of browsers for all sorts of reasons, and that there are some solid engineering approaches we can take to make the web accessible for everyone.

_Optimize for the majority, make an effort for the minority, and never sacrifice security._

### <span class="rh">Further Reading</span> on SmashingMag:

<ul>
<li><a title="Read 'Web Standards: The What, The Why, And The How'" href="https://www.smashingmagazine.com/2019/01/web-standards-guide/" rel="bookmark">Web Standards: The What, The Why, And The How</a></li>
<li><a title="Read 'Smart Bundling: How To Serve Legacy Code Only To Legacy Browsers'" href="https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/" rel="bookmark">Smart Bundling: How To Serve Legacy Code Only To Legacy Browsers</a></li>
<li><a title="Read 'Don’t Use The Placeholder Attribute'" href="https://www.smashingmagazine.com/2018/06/placeholder-attribute/" rel="bookmark">Don’t Use The Placeholder Attribute</a></li>
<li><a title="Read 'Designing For A Browserless Web'" href="https://www.smashingmagazine.com/2017/11/designing-for-a-browserless-web/" rel="bookmark">Designing For A Browserless Web</a></li>
</ul>

{{< signature "ra, il" >}}
